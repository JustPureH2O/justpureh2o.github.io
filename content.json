{"meta":{"title":"JustPureH2O的博客","subtitle":"深水摸大鱼","description":"JustPureH2O的小窝","author":"JustPureH2O","url":"https://justpureh2o.github.io","root":"/"},"pages":[{"title":"","date":"2023-11-04T03:04:22.865Z","updated":"2023-10-26T09:09:01.873Z","comments":true,"path":"404.html","permalink":"https://justpureh2o.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-10-26T08:03:52.000Z","updated":"2023-10-26T08:55:42.018Z","comments":true,"path":"about/index.html","permalink":"https://justpureh2o.github.io/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-04T03:04:22.867Z","updated":"2023-10-26T09:06:37.321Z","comments":true,"path":"friends/index.html","permalink":"https://justpureh2o.github.io/friends/index.html","excerpt":"","text":""},{"title":"DC Doujin 同人创作","date":"2023-11-04T08:33:40.000Z","updated":"2023-12-03T05:33:52.933Z","comments":true,"path":"dcdoujin/index.html","permalink":"https://justpureh2o.github.io/dcdoujin/index.html","excerpt":"","text":"DC Doujin 简介 DC Doujin 同人创作（以下简称DCD），由JustPureH2O于2023年11月5日创建。主要发布一些幽默视频，以及对应的幕后纪实。旨在用最真实最还原的镜头记录学校生活的点点滴滴。目前该频道的拍摄、剪辑、发布均由JustPureH2O一人承担，主要演员有木稿比你铁、狂三唯吾所爱 新闻 DC Doujin 2023 EP1 先行预告 DC Doujin 2023 EP1 一触即发 正式发布 演员 1. 木稿比你铁 DC Doujin 2023 EP1 拍摄前 2. 狂三唯吾所爱 （左侧）DC Doujin 2023 EP1 拍摄时"},{"title":"memes","date":"2023-11-04T08:33:30.000Z","updated":"2023-11-04T08:33:30.823Z","comments":true,"path":"memes/index.html","permalink":"https://justpureh2o.github.io/memes/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-10-26T08:56:08.000Z","updated":"2023-10-26T08:57:03.066Z","comments":true,"path":"tags/index.html","permalink":"https://justpureh2o.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-11-04T03:04:22.866Z","updated":"2023-10-26T08:58:13.786Z","comments":true,"path":"categories/index.html","permalink":"https://justpureh2o.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2023年度总结——机房管理软件的破解经验","slug":"new-year-crack","date":"2023-12-31T12:22:54.000Z","updated":"2023-12-31T12:30:40.322Z","comments":true,"path":"2023/12/31/new-year-crack/","link":"","permalink":"https://justpureh2o.github.io/2023/12/31/new-year-crack/","excerpt":"","text":"文中提到的核心程序代码及食用方法在文章末尾处，或者访问我的云剪贴板来复制代码 极域——世界上最弱小最单纯的机房软件 注意，极域由C/C++语言开发。对于极域的反编译工作可以基本认定为徒劳且耗费大量时间的。 开始的开始，我的脱控方式还仅限于最原始的taskkill和ntsd。这种做法不仅有时会失效，而且一旦老师发现你的机子的监控屏幕是纯黑一片、且无法控制，他就会气急败坏地冲向你对你进行一顿输出，结果自然是被班主任教训一顿、这学期的信息课停上。 令人欣慰的是：这种低级脱控方式已经在学子之间渐渐隐没不见，取而代之的是层出不穷的脱控软件，例如JYTrainer、还有本人开发的ClassX（doge）等等…… 因为本人不会那些所谓的网络IP、频道更改之类的高科技东西，另一方面实现如上的功能多半需要辅助程序（容易被反脱软件检测到进程名）。本着精简实现、不易查封的原则，我从非exe层面出发，编写了一套脱控程序供大家伙们免费使用，毕竟人生苦短，及时行乐嘛（doge）。 板块一 TD到底是啥的缩写？ 你知道明明U盘里装着几个G的学习资料却无法在计算机课上给周边的同学炫耀是怎么样一种感觉吗？你知道明明想要打开小破站观看最爱的coser投稿的新擦边视频却被提示“该网站已被禁止”是什么样的感觉吗？ 出于以上两种痛苦的经历，我立志要写出能够禁止极域牛马功能的脚本。就先从U盘解禁和网络解禁两个方面入手！ Windows服务概述：打开任务管理器，选项卡里不仅有经典的“进程”选项、也有装机大佬们引以为傲的“性能”选项，可是我们今天的主角：“服务”选项却几乎无人问津。 类似于cmd的打开方式，服务管理器则需要在Win+R后输入services.msc来使用；你也可以通过任务管理器“服务”选项卡进入。那么什么是服务呢？ Windows服务是指系统自动完成的，不需要和用户交互的过程，可长时间运行的可执行应用程序。这些服务可以在计算机启动时自动启动，可以暂停和重新启动而且不显示任何用户界面。一个词概括就是：“幕后黑手”。开头立的flag就需要通过这种方式巧妙解决。 定位到极域安装目录：会发现下面有好多TD打头的文件，而当你在服务里面搜索时，你会发现一个惊人的巧合：TDNetFilter和TDFileFilter早已在你的机器上悄然运行了很久。看到它的名字，容易知道前者禁掉了你的网络、后者ban掉了你的U盘。如何终止服务呢？这也非常的简单： 在Windows系统中，与服务有关的命令是sc。要想停止某个服务，只需安装如下模式输入指令：sc stop [NAME]（NAME是服务名称）。于是我在ClassX的开头加入了如下的指令： 12sc stop tdnetfiltersc stop tdfilefilter 这样就结束了吗？然而并没有…… 板块二 可疑的程序 上一节里遗留了一个小问题：停止了服务后他就真的解禁了吗？事实并非如此：没过几秒，你的网络又会恢复到先前的状态、U盘再次被封杀。一切的一切都是因为两个不起眼的可疑程序…… ProcHelper64.exe和MasterHelper.exe——《我们俩》 有人问我当时是怎么发现的。首先需要知道，每个版本的Windows系统几乎都有一套特别的图标主题（图标存放在Shell32.dll中），现如今大部分机房电脑使用的是Win10系统，然而上述两个进程使用的是WinXP风格的图标，直接一眼丁真掏出taskkill秒了。真是实力坑队友。 因此ClassX里面还有这一段代码： 12345:ataskkill /f /t /im ProcHelper64.exetaskkill /f /t /im MasterHelper.exegoto a :a定义了一个函数a，中间是函数体，最后一行的goto a则是调用这个函数，注意goto a写在了a函数内部，起到了while (true) &#123;...&#125;的死循环作用。你也可以在空行出添加一段TIMEOUT /T 1，即延时一秒，因为这两个程序的复活时间大概在1秒左右（终止后一秒就会重启）。 板块三 拒绝访问什么鬼？ 第一种情况：钩子程序 如果你是Win7及以下的系统，且直接使用任务管理器结束进程，那么很有可能会出现像标题这样的提示。这是因为极域启动了一个系统钩子（四川人莫笑，Hook翻译过来的确是钩子的意思）。 Windows钩子概述：类似于游戏（以及Scratch）的消息机制，Windows中存在一种事件系统，Win+R弹出运行、输入eventvwr.exe/eventvwr.msc打开事件管理器，你会看到本机所有事件的发生时间及概况。把Windows系统的事件系统比作一条河流，最上游是系统，负责抛出事件，事件信息顺流而下；把应用程序比作渔夫，它们在河岸两侧用网捞特定类型的事件，大多数情况下自行处理后再放回到河中。 对于极域来说，它在一个名叫NtTerminateProcess的系统函数上下钩，检测这个函数的传入信息，即终止对象的进程名，是否是StudentMain.exe（极域主程序），若是，就返回false，也就是失败。因而导致开头所说拒绝访问的情况，而把钩子钩在此处的，就是我们的TD圈大佬LibTDProcHook.dll。因为本人使用Win10系统，这个钩子对于Win7以后的系统都会失效，因此Win8/10/11用户可以直接用任务管理器。对于Win7系统用户，在这里使用WinAPI终止这个TD模块。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;processthreadsapi.h&gt;using namespace std;DWORD GetPID(const char* proc) &#123; PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(snapshot, &amp;entry) == TRUE) &#123; while (Process32Next(snapshot, &amp;entry) == TRUE) &#123; if (stricmp(entry.szExeFile, proc) == 0) &#123; HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, entry.th32ProcessID); DWORD pid = GetProcessId(hProc); CloseHandle(hProc); return pid; &#125; &#125; &#125;&#125;int main() &#123; HMODULE hook = GetModuleHandle(&quot;LibTDProcHook64.dll&quot;); FreeModule(hook); HANDLE handle = OpenProcess(PROCESS_TERMINATE, FALSE, GetPID(&quot;StudentMain.exe&quot;)); TerminateProcess(handle, 0); return 0;&#125; 第二种情况：时代变了 自从学校机房的极域从2014版更新到了2020版，上述朴素解决方案已经不见效了。我也不知道从哪一年的版本开始，它给自己的服务加了一层防护，普通地运行bat脚本还木有用。但是它解决起来也简单，右键文件“以管理员模式运行”即可。 除此之外，你还可以在脚本开头加入： 1234567891011&gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit) 来实现UAC自动提权管理员！ 板块四 留给2024的一个小问题 那天我在思考如何一劳永逸的结束红蜘蛛进程，我打开了服务列表，在里面看到两个纯大写拼成的服务名GATESRV和STUDSRV。可惜的是那天放学，我没能来得及探究清楚这两个服务与极域的关系，目前已知的信息就是它们绝对是极域自己启动的两个服务。 这个问题就留给2024的我解决吧 // TODO 红蜘蛛软件——可曾听闻我绿蜘蛛脚本的厉害？ 在本人印象中，红蜘蛛似乎就仅仅只是一个吉祥物，只有在开机后那么几秒，它拖着上世纪复古风的“高清”启动界面在我的眼前一闪而过，然后静静地躲在任务栏的小图标里，践行它大隐隐于市的人生信条…… 说实话要不是同学提醒我还真忘了机房里还有这位叫红蜘蛛的朋友，于是我着手开始破解它。红蜘蛛：我吃柠檬 1. 这玩意怎么跟2345一个德行？ 知道2345全家桶的同学们肯定对它恨之入骨，尤其是那些下载了2345的同学们。2345号称天朝第一大流氓软件，在无数人的电脑中如同鬼魂一般挥之不去。捆绑安装、弹窗广告、强制修改系统文件、浏览器劫持……无奇不有，关键是它的公司甚至推出极其出生的“推广包”机制来诱惑不良商户分发2345毒瘤软件。这篇文章介绍了清除2345的一种方案。 回到本节主题上来，为什么会取这样一种怨气十足的标题呢？是因为它和2345伪装成系统文件类似，红蜘蛛属于是反向利用了系统文件来给自己加上一层保护网。 打开任务管理器，除了霸占后台程序第一行的红蜘蛛本体，下面还有两个附属程序，名叫“3000soft通用组件”，如果直接终止进程，它很快会再次冒出来。将它们展开后发现叫做checkrs.exe和rscheck.exe的程序。那么运用上边经常用到的服务搜查法，我们发现了两个命名规则极其相似的服务：appcheck2和checkapp2。 然而我事后才发现红蜘蛛官网早已自报家门了……血亏！ 常规思想：我们使用sc命令结束这两个服务，然而…… // TODO 显示无法停止，那怎么办呢？ 考虑到这两个进程是红蜘蛛死掉后无限重启的命根，并且这两个进程也跟红蜘蛛主程序一样杀了就会重启……很明显，根本原因就是那两个服务，但是sc命令不管用了，咋办呢？（抠头） 这时我们就需要绕道而行，既然命令不行，我们转战注册表！打开注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services文件夹，它有很多个子文件夹，在下面定位到appcheck2和checkapp2，它的文件结构类似于这样（这里用别的服务替代一下）： （注意，这个并不是红蜘蛛的服务，是我临时找别的替代的，它们的文件名相同，只是数据不同而已） 容易发现：ImagePath项指向了服务的根文件地址，也就是俗称的万恶之源，既然每次终止组件后它会自动重启服务，那我们为何不破坏这个ImagePath，让它指向一个不存在的地址，这样它就启动不了任何东西了。在我的绿蜘蛛inf文件里如此写到： 123456789101112[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 然后你就可以用任务管理器终止两个通用组件，紧接着就可以终止红蜘蛛了！ 由于本人目前对红蜘蛛知之甚少，可以看这篇文章了解更多！ 学生机房管理助手——闻着臭吃着香 1. 不用逆向，能得到什么结论？ 其实一开始我以为它和极域一样是基于C++/C开发的因此无法反编译，直到回家之后我自己下载了一个。杀毒软件报毒删除了set.exe，打开main.exe主入口程序时它突然弹出了一条C#式的通知框提示set.exe未找到。于是果断打开dnSpy开启后面的破解，反编译破解的内容将在后面涉及到。 首先看到他的文件目录↓ 其中zy文件夹中存放的是各种浏览器的exe可执行文件，猜测是覆盖现有的高版本浏览器，以便它操作注册表禁止各种功能。 有一定经验的同学想必会一眼看到可疑的yl.reg注册表文件，但是先别急着合并注册表。首先，你的机器可能已经被禁用了注册表和任务管理器；第二，这个文件里也不是你心心念念的破解注册表（虽然后面我们会利用它破解机房管理助手）。对于未知的事物，最好还是保持谨慎勿近的态度为好…… 除此之外，一个名叫jfglzs.exe的程序吸引了我，根据我多年混迹于首拼梗圈的我一秒钟就反应过来，知道它就是“机房管理助手”的首拼。我们之后的破解也围绕着这个东西进行。 第一问 任务管理器、注册表、组策略咋解 本人Win11系统，正常情况下任务栏设置上端会有一个任务管理器选项。 如果你稍微懂一点高级知识，你也许会使用Win+R，并输入taskmgr试图使用任务管理器。然而这不可能奏效，因为你会接到一则提示： 输入regedit（注册表）和gpedit.msc（组策略管理器）也是一样的道理。很少很少的高材生会使用mmc试图加载组策略，但是这样也不可能奏效。搜索资料发现，修改注册表的某些键值可以实现禁用组策略、注册表、任务管理器的功能。深度分析yl.reg时就会发现这些东西： 第一行翻译过来就是：“禁用任务管理器”，它的值被设置成了1，也就是true。这一块还有禁止更改密码、禁止切换用户的设置等等。对于组策略，它的两个值则是存放在注册表：HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC中的RestrictToPermittedSnapins；和它的子目录HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;中的Restrict_Run。如果不出意外，它们的值都是非零的，意味着组策略被禁用了。要想破解，我们就需要用一个不直接调用注册表的方式来添加/更改注册表值，这也就是下面将要提出的inf安装文件法。 INF安装文件的机制 提起绿色版软件，大家应该不会陌生，它省去了冗杂的dll等库文件，仅仅一个exe文件驱动整个程序。在绿色版软件安装时，有时就是用的inf文件安装法。一个可运行的inf文件包含几个项： 123[Version]Signature=&quot;$CHICAGO$&quot;Provider=somebody Version段包含inf文件的基本信息，其中Signature指定了文件的适用系统，常见的值有MS、WindowsNT等，这里我们使用CHICAGO获得最广泛的支持（注意美元符号和引号的书写）。 123[DefaultInstall]DelReg=DeleteAddReg=Add 这一段声明了安装时所需的函数，DelReg负责删除注册表，AddReg负责创建/修改注册表。基本语法如下： DelReg：[ROOT] [PATH] [NAME]，ROOT就是注册表中HKEY开头的那些，你可以写全称，也可以写缩写形式（HK+后两个单词的首字母，HKEY_LOCAL_MACHINE=HKLM）；PATH是包含指定键值的文件夹路径；NAME就是键值的名字。 AddReg：[ROOT] [PATH] [NAME] [TYPE] [VALUE]，TYPE指定了注册表值的类型（0相当于缺省，默认字符串；1为DWORD值，设置十六进制值时只需两个数字一组，中间逗号分隔开，一定保证输入的十六进制为8位，一定记得写前导0！）；VALUE即为键值，值为字符串时需要在前后打上半角双引号。 等号右侧的值相当于C++中的typedef，用来重命名函数，因此，在后续的安装代码中，我们的字段标识符都要与等号右侧的值相符才可，在我们的inf中，它表现为这样（inf文件的注释用分号表示）： 12345678910111213[Delete]HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableCMD&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot; 在记事本里编辑即可，记得保存为.inf文件，而后右键“安装”，或者在cmd里运行：InfDefaultInstall + inf文件地址（前提是你的cmd没被禁止）。 除此之外，我们发现了一些好玩的东西：yl.reg的最后几十行，将常用浏览器的起始界面通过注册表的方式修改成了它的官网，学有余力的娃们可以通过刚才介绍的AddReg函数把它的值改成你想要的值，在这里我换成了我精心制作的嘲讽页面： 1234567891011[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; yl.reg——队友坑害全队的典型例子。 当一切完成之后，你就可以自由使用任务管理器了，被锁定了cmd的同学们也可以尽情使用taskkill了！诶等等，事情好像有点不对劲…… 第二问 我的taskkill去哪了 可是我的taskkill还好好地躺在System32文件夹里啊 机房管理助手一启动，所有使用taskkill的脚本/程序都会失效，属于是老阴B了。如果不逆向破解，我还真不清楚这是怎么做到的。总之你可以在网站上下载一个taskkill（对上网下载一个下来），或者顶住巨大的学习难度学习WinAPI（TerminateProcess函数）写出一个拔山盖世的C++程序来。这一节就不多赘述其他内容了…… 第三问 yl.reg到底写了啥 其实最扎眼的就是它里面写的宣（补）战（贴）名单各种脱控工具箱，说实话那些工具箱软件我基本上一个都没见过…… 这些注册表项有一个很普遍的特征，它们无一例外指向了注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Hashes下很多以GUID形式命名的文件夹，那么这些文件夹具体起什么作用呢？ 这其实是组策略管理器的黑名单，具体见此，没错，组策略可以限制指定软件的运行。但是很遗憾，这些配置全部存放在上述的注册表里面。你可以把注册表看做系统的配置文件，操作系统几乎所有配置信息、甚至包括大部分软件程序的配置都存放在注册表中。这么看来除了BIOS没别的安全地方了 如果想要禁用这些项，并不需要挨个将每个文件删去，而是看到他的其中一个父文件夹codeidentifiers。它里面有一个二进制值authenticodeenabled，它指定组策略黑名单的ID标识符，也就是codeidentifier文件夹下以数字命名的文件夹，只有当子文件夹的名称与ID标识符相同时才会启用该文件夹下的配置。因此我们釜底抽薪，直接更改authenticodeenabled的值： 12[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14 假如我掏出逆向工具，阁下又该如何应对？ 正如开头所说，学生机房管理助手由C#开发，因此可以用dnSpy反编译它的可执行文件，得到源码。那么我们就开始吧！ 第一框 密码是啥 将set.exe拖入dnSpy中反编译，我们会得到一大坨屎山代码，它看起来是这样的： （节选） 它充斥着大量的case判断，以及意义不明的变量名和数学操作。我自然是看得晕头转向，但是想到自己的主业——高贵的OIer，怎么能被这么小的挫折打倒呢？借助部分大佬的传世思路，我们于是发现这长达2600+行的屎山函数可以被写成这样的形式（完全等价）： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Security.Cryptography;using System.Text;using System.IO;public class Program&#123; public static void Main() &#123; // 更改这里的内容 string string_3 = &quot;12345678&quot;; // Class6.smethod_0() string value = &quot;C:\\\\WINDOWS&quot;; string s = value.Substring(0, 8); string s2 = value.Substring(1, 8); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); descryptoServiceProvider.Key = Encoding.UTF8.GetBytes(s); descryptoServiceProvider.IV = Encoding.UTF8.GetBytes(s2); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write); StreamWriter streamWriter = new StreamWriter(cryptoStream); streamWriter.Write(string_3); streamWriter.Flush(); cryptoStream.FlushFinalBlock(); memoryStream.Flush(); string string_4 = Convert.ToBase64String(memoryStream.GetBuffer(), 0, checked((int)memoryStream.Length)); // Class6.smethod_3() StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; string_4.Length; i++) stringBuilder.Append((char)(string_4[i] - 10)); string_3 = stringBuilder.ToString(); // Class6.smethod_2() MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider(); byte[] array2 = md5CryptoServiceProvider.ComputeHash(Encoding.Default.GetBytes(string_3)); stringBuilder.Clear(); for (int i = 0; i &lt; array2.Length; i++) stringBuilder.Append(array2[i].ToString(&quot;x2&quot;)); string str = stringBuilder.ToString().Substring(10); Console.WriteLine(str); &#125;&#125; 现在有点明白程序员的痛了 同时，机房管理助手的密码MD5文件存放在注册表HKEY_CURRENT_USER\\Software下的字符串值n里面。更改即生效！ 代码环节 ClassX 使用方法：另存为.bat文件直接运行 12345678910111213141516171819202122232425262728293031@echo off &gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit)sc stop tdnetfiltersc delete tdnetfiltersc stop tdfilefiltersc delete tdfilefiltersc stop GATESRVsc delete GATESRVsc stop STUDSRVsc delete STUDSRVregedit /c /s usb_reg.regecho Unhook through Regedit:ataskkill /f /t /im MasterHelper.exetaskkill /f /t /im ProcHelper64.exeTIMEOUT /T 1goto a 绿蜘蛛 使用方法：另存为.inf文件→右键安装；任务管理器先结束进程3000soft通用组件，再结束红蜘蛛软件 1234567891011[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 学生机房管理助手通用破解 使用方法：另存为.inf文件→右键安装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=Add[Delete] ; 大坏蛋，放开那个组策略管理器！HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete] ; 注册表和任务管理器我来接手，你可以卷铺盖走人了！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot;[Delete] ; 我就要切换用户！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot;[Delete] ; 如果把我桌面搞乱了张伟会清理掉我的文件滴HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer&quot;,&quot;DesktopProcess&quot;[Add] ; 加点料才香~; 破坏服务HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\zmserv&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\System32\\cnmd.exe&quot;; 杂项HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoConfigPage&quot;,1,00,00,00,01HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoDevMgrPage&quot;,1,00,00,00,01; 解除edge浏览器断网小游戏限制HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\MicrosoftEdge&quot;,&quot;AllowSurfGame&quot;,1,00,00,00,01[Add] ; 嘲讽一波这sb管理助手，关键你就算换成自己的网页学校的破网也加载不出来（笑）HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;; TODO 再给你多附赠几个浏览器hhHKCU,&quot;Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Storage\\microsoft.microsoftedgedevtoolsclient_8wekyb3d8bbwe\\MicrosoftEdgeMain&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; ; Edge 浏览器主页","categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"机房管理助手 v9.x已成功破解","slug":"cracked-23-12-23","date":"2023-12-24T00:45:33.000Z","updated":"2023-12-24T00:54:51.708Z","comments":true,"path":"2023/12/24/cracked-23-12-23/","link":"","permalink":"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23/","excerpt":"","text":"任务管理器已解禁，您也可以自由使用注册表和组策略进行其他操作","categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"}]},{"title":"DC Doujin 2023 EP1 一触即发正式发布","slug":"dcdep1-release","date":"2023-12-03T05:02:42.000Z","updated":"2023-12-03T05:32:34.969Z","comments":true,"path":"2023/12/03/dcdep1-release/","link":"","permalink":"https://justpureh2o.github.io/2023/12/03/dcdep1-release/","excerpt":"","text":"","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"信竞初等数论导论","slug":"number-theory-junior","date":"2023-11-26T01:37:52.000Z","updated":"2023-11-26T01:45:09.414Z","comments":true,"path":"2023/11/26/number-theory-junior/","link":"","permalink":"https://justpureh2o.github.io/2023/11/26/number-theory-junior/","excerpt":"","text":"引入 如果说数论是数学体系中专门用来研究数字性质的一个分支，那么初等数论则是对整数的性质进行系统性的探讨与研究。千万不要因为其中的“初等”二字小瞧这初等数论尽管名称和学习难度上都没有高等数论那么有逼格，就像初等数学之于高数，数论的所有内容均筑基于此。其中欧几里得证明的算数基本定理（一切合数都可被分解为有限个质数的乘积）在质数筛、GCD（以及LCA)计算、无理数证明等问题上均有用武之地。可以说高等数论奠基于初等数论。它同时也是初学者接触数论的必经之路。 Part1. 有关定理 算术基本定理：每一个合数都可以被分解为有限个质数的乘积。即对于任意合数nnn，都存在： n=p1c1p2c2p3c3...pkckn=p_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}n=p1c1​​p2c2​​p3c3​​...pkck​​，其中ppp为质数。 推论一：正整数nnn的正因数集合为： {n=p1b1p2b2p3b3...pibi∣1≤bi≤ci,1≤i≤k}\\{n=p_{1}^{b_1}p_{2}^{b_2}p_{3}^{b_3}...p_{i}^{b_i} \\mid 1 \\leq b_i \\leq c_i, 1 \\leq i \\leq k\\}{n=p1b1​​p2b2​​p3b3​​...pibi​​∣1≤bi​≤ci​,1≤i≤k} 推论二：正整数nnn的正因数个数为：τ(n)=(c1+1)⋅(c2+1)⋅(c3+1)...(ck+1)=∏i=1k(ci+1)\\tau (n)= (c_1+1) \\cdot(c_2+1) \\cdot (c_3+1) ... (c_k+1) =\\prod_{i=1}^{k}\\left( c_i+1\\right) \\\\τ(n)=(c1​+1)⋅(c2​+1)⋅(c3​+1)...(ck​+1)=∏i=1k​(ci​+1) 推论三：正整数nnn的所有正因数之和为 σ(n)=(p1+p12+...+p1c1+1)×(p2+p22+...+p2c2+1)×...×(pk+pk2+...+pkck+1)=∏i=1kpkck+1pk−1\\sigma(n)=(p_1+p_1^2+...+p_1^{c_1}+1)\\times (p_2+p_2^2+...+p_2^{c_2}+1)\\times...\\times (p_k+p_k^2+...+p_k^{c_k}+1)=\\prod_{i=1}^{k}\\frac{p_k^{c_k+1}}{p_k-1}σ(n)=(p1​+p12​+...+p1c1​​+1)×(p2​+p22​+...+p2c2​​+1)×...×(pk​+pk2​+...+pkck​​+1)=∏i=1k​pk​−1pkck​+1​​ 质数分布定理：区间[1,N][1,N][1,N]中，当N→∞N\\to \\inftyN→∞时，质数个数π(x)≈nln⁡n\\pi (x)\\approx \\frac{n}{\\ln n}π(x)≈lnnn​。 费马小定理： 若ppp是一个质数，则ap≡amod pa^p\\equiv a\\mod pap≡amodp（≡\\equiv≡为同余符号）。 欧拉定理（费马小定理扩展）： 若a⊥na\\perp na⊥n（aaa与nnn互质），则有aφ(n)≡1mod na^{\\varphi{(n)}} \\equiv 1 \\mod naφ(n)≡1modn，其中φ(n)\\varphi(n)φ(n)为欧拉函数。 Part2. 质数 质数的判断：除了它自身PPP以及111以外，不存在其他正整数NNN使得N∣PN\\mid PN∣P。 Div1. 质数判断 试除法： 这是三种方法中，唯一一种能做到100%正确的质数判断方法。对于给定数nnn，遍历所有[2,n][2,\\sqrt n][2,n​]间的正整数mmm，若出现m∣nm\\mid nm∣n则证明它不是质数，因为质数只能被1以及它本身整除。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及、提高 试除法の大胜利！ 费马素性检验： 是上述费马小定理的实际运用，它与常规算法思想有所不同：它主张在[2,n−1][2,n-1][2,n−1]中随机选取一个数aaa。若出现与费马小定理不符的情况，那么nnn一定为合数；若每次均符合定理，称为 费马伪素数 ，因为它很大概率是一个质数。 1234567891011bool isPrime(int n) &#123; if (n &lt;= 2) return false; int k = 10; while (k--) &#123; srand(time(0)); int a = rand() % (n - 2) + 2; if (__gcd(a, n) != 1) return false; if (qpow(a, n - 1, n) != 1) return false; &#125; return true;&#125; 复杂度：O(klog⁡n)\\mathcal O(k\\log n)O(klogn)，其中kkk为随机数检验次数，log⁡n\\log nlogn是因为使用了快速幂算法。 适用范围：提高T2及以下（慎用） 为什么用该方法判断的质数 大概率 是个质数呢？不妨测试一下561（3）、1105（5）、1729（7）（括号内为它的最小因子），你会发现函数的返回值均为true，即都为质数。可见这个算法不是100%正确的，这些“漏网之鱼”被称为“Carmichael数”。它们极其罕见，一亿范围内仅255个。也因如此，你可以通过打表特判的方式抠掉这些特例（你保证记得住就行）。2016年中国物流工人余建春给出了一个Carmichael数的判断准则，这个标准目前在国际上得到了广泛认同。 对于优化，你可以在函数起始点加入类似于if (n % 2 == 0 || n % 3 == 0) return false;的特判，进一步降低复杂度。 Miller-Rabin算法： 该算法同样无法保证结果100%准确，慎用！ MB算法实质上是对费马素性检验算法的效率和准确度优化。算法流程如下： 将n−1n-1n−1分解为2s+d2^s+d2s+d的形式，其中ddd为奇数 从[2,n−2][2,n-2][2,n−2]中选取整数aaa，称为“基数” 计算admod na^d \\mod nadmodn的值，若结果为111或n−1n-1n−1，则可能为质数，继续检验 若结果不等于111或n−1n-1n−1，计算a2dmod na^{2d} \\mod na2dmodn、a4dmod na^{4d} \\mod na4dmodn、a6dmod na^{6d} \\mod na6dmodn……a2s−1dmod na^{2^{s-1}d} \\mod na2s−1dmodn的值，若结果等于n−1n-1n−1，则可能为质数，继续检验 若都不等于111，则nnn一定是合数。称为强费马证据。 当然，它同样有特例，称为强伪质数，如2047（23）、3277（29）、4033（39）等（括号内为它的最小因子）。 Div2. 质数筛 常见的质数筛法有：试除法、埃氏筛、线性筛。 试除法：从质数定义出发，即存在一个正整数NNN，对于任意[2,N][2,\\sqrt N][2,N​]间的正整数MMM，总有Nmod M≠0N\\mod M \\neq 0NmodM​=0成立。代码实现只需枚举[2,N][2, \\sqrt N][2,N​]间所有正整数，并让NNN对其取余。若取模运算出现000则代表它不为质数，没有出现000则为质数。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(N)\\mathcal O( \\sqrt N )O(N​) 适用范围：普及T2及以下 这里所展示的试除法代码实际上经过一轮优化。若严格根据质数定义，第二行的循环上限应为n−1n-1n−1。考虑到如下性质：∀m∈[2,N]\\forall m\\in [2,\\sqrt N]∀m∈[2,N​]，若m∣Nm\\mid Nm∣N，则一定有Nm∣N\\frac{N}{m}\\mid NmN​∣N。因此可以将循环上限压缩至N\\sqrt NN​。 埃氏筛：全称叫埃拉托斯特尼筛法，老哥生活在2200年前的古希腊，不借助望远镜就计算出了地球的周长（与真实值偏差仅0.96%）、同时他也是第一位根据经纬线绘制出世界地图的人、也是最先提出将地球根据南北回归线分为“五带”的大人物。他提出的筛法核心思想如下： 第一步：列出从2开始的一列连续数字；第二步：选出第一个质数（本例中为2），将该质数标记，将数列中它的的所有倍数划去；第三步：若数列中的末项小于它前一项的平方，则质数已全部筛出；否则返回第二步。 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; &#125; for (int j = 2; i * j &lt;= n; j ++) vis[i * j] = true; &#125;&#125; 其中，prime数组存储质数，vis数组用于标记（即上文中“划去数字”），变量cnt则存储[2,N][2,N][2,N]中质数的个数。 复杂度：O(nln⁡n)\\mathcal O(n\\ln{n})O(nlnn) 适用范围：普及T2及以下 但是继续观察算法发现：我们其实无需将所有iii的倍数删去，只需删去前一步得出的质数的所有倍数即可。 这与前文介绍的埃氏法核心相符。因此将jjj循环迁移至条件判断中即可： 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) vis[j] = true; &#125; &#125;&#125; 优化复杂度：O(nlog⁡log⁡n)\\mathcal O(n\\log{\\log n})O(nloglogn) 适用范围：普及T3及以下 线性筛/欧拉筛：实质是埃氏筛的线性优化。因为在埃氏筛中，有些数字被重复筛了多次（例如30会被2、3、5筛到）。本着线性优化的原则，我们需要找到一个方法，使得每个合数仅被筛选一次。主要思想如下： 我们发现，线性筛和埃氏筛均使用了质数的nnn倍为合数的结论。我们只需要保证每一个数仅被它自身的最小质因数筛出即可。即对于数字mmm，m⋅pim\\cdot p_im⋅pi​是一个合数，且m⋅pim\\cdot p_im⋅pi​只会被pip_ipi​筛出。 123456789void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) &#123; vis[prime[j] * i] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及、提高 Part3. 因数 因数定义： 对于一个数nnn，若存在一个正整数mmm使得m∣nm\\mid nm∣n，则称mmm是nnn的因数。 Div1. 因数分解法 试除法：万能暴力解法。即遍历[2,n][2,\\sqrt n][2,n​]间的所有数mmm，若可以整除nnn，则mmm和nm\\frac{n}{m}mn​均为nnn的因数。特殊情况：n\\sqrt nn​为整数时，因数仅有n\\sqrt nn​本身，因此需特判。 123456789101112vector&lt;int&gt; get(int n) &#123; vector&lt;int&gt; ret; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret.push_back(i); ret.push_back(n / i); &#125; if (n % (i * i) == 0) ret.pop_back(); &#125; sort(ret.begin(), ret.end()); return ret;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及T1 Div2.最大公约数 辗转相除法： 又是我们大名鼎鼎的欧几里得老先生提出的一套公约数算法，整个算极其简洁：核心只有一行，即： 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数 可以写出： 123int gcd(int a, int b) &#123; return b ? gcd(a, a % b) : a; &#125; 但是为什么gcd(a,b)=gcd(a,amod b)gcd(a,b)=gcd(a,a\\mod b)gcd(a,b)=gcd(a,amodb)呢？我们可以通过以下方法证明： 假设如下关系：A=B⋅C+DA=B\\cdot C + DA=B⋅C+D。其中被除数AAA，除数BBB，商CCC，余数DDD。则Amod B=Amod C=DA\\mod B=A\\mod C=DAmodB=AmodC=D。 首先证明充分性：令A=a⋅kA=a\\cdot kA=a⋅k、B=b⋅kB=b\\cdot kB=b⋅k，即二者有相同因子kkk。 代入初始除法算式得：D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C)D=A-B\\cdot C\\rightarrow a\\cdot k-b\\cdot k\\cdot C\\rightarrow k(a-b\\cdot C)D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C) 接着由于加减乘法的封闭性，即一个整数进行加减乘运算得到的结果同样是一个整数。可以得出：D=k⋅N∣N∈N+D=k\\cdot N\\mid N\\in \\mathbb{N_+}D=k⋅N∣N∈N+​。即DDD（Amod BA\\mod BAmodB）与AAA有共同因子。 接下来证必要性。令B=b⋅qB=b\\cdot qB=b⋅q、D=d⋅qD=d\\cdot qD=d⋅q Stein算法： 上一个方法的明显缺点在于，它处理大质数的效率并不好（但总体来说是很好的），因为它使用了取余运算，这会减慢一些速度。可以理解，生在2000多年前——一个没有电脑和OI的古希腊社会，这个算法已经足够兼顾常规效率和手推难度了。但是步入21世纪，加快的生活节奏毒瘤数据使得人们对更快算法的需求空前高涨。Stein算法便应运而生。 算法流程如下： 任意给定两个正整数，先判断它们是否都是偶数，若是，则用2约简，若不是，则执行第二步。 若两数是一奇一偶，则偶数除以2，直至两数都成为奇数。再以较大的数减较小的数，接着取所得的差与较小的数，若两数一奇一偶，仍然偶数除以2，直至两数都成为奇数。再次以大数减小数。不断重复这个操作，直到所得的减数和差相等为止。 两数相等时，第一步中约掉的若干个2与第二步中最终的等数的乘积就是所求的最大公约数。 123456789101112131415161718192021222324int gcd(int a, int b) &#123; int p = 0, t; if (!(1 &amp; a) &amp;&amp; !(1 &amp; b)) &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; p++; &#125; while (!(1 &amp; a)) a &gt;&gt;= 1; while (!(1 &amp; b)) b &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (a = ((a - b) &gt;&gt; 1)) &#123; while (!(1 &amp; a)) a &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; &#125; return b &lt;&lt; p;&#125; 这个算法的优点在于：它大大优化了大质数的运算。但可惜的是，它的代码量膨胀了8倍，因此不太建议赛时使用。毕竟C++都给你内置了__gcd()函数嘛，干嘛不偷个懒？ Div3. 最小公倍数 我们可以简单概括成一句话： 两个数的最小公倍数等于这两个数的乘积与这两个数最大公约数的商 即：lca(a,b)=a⋅bgcd(a,b)lca(a,b)=\\frac{a\\cdot b}{gcd(a,b)}lca(a,b)=gcd(a,b)a⋅b​ 凭啥呀？ 我们假设两个数AAA和BBB有最大公约数xxx，则A=a⋅xA=a\\cdot xA=a⋅x，且B=b⋅xB=b\\cdot xB=b⋅x。并且aaa和bbb一定互质（若不互质，AAA和BBB的最大公约数就不会是xxx，而是一个比xxx大的值）。 由乘法交换律，可知：A⋅B=B⋅A→A⋅b⋅x=B⋅a⋅xA\\cdot B = B\\cdot A\\rightarrow A\\cdot b \\cdot x=B\\cdot a\\cdot xA⋅B=B⋅A→A⋅b⋅x=B⋅a⋅x 消去xxx得：A⋅b=B⋅aA\\cdot b=B\\cdot aA⋅b=B⋅a。因为aaa、bbb互质，所以A⋅bA\\cdot bA⋅b或者B⋅aB\\cdot aB⋅a即为两个数的最小公倍数。得证。 Part4. 欧拉函数相关 Div1. 欧拉函数推导 问：论牧师欧拉有多么的高产 答：平均每年800页数学论文你说高不高产嘛 欧拉函数，记作φ(n)\\varphi(n)φ(n)。表示[1,n)[1,n)[1,n)中与nnn互质的数的个数，即∀m∈[1,n)\\forall m\\in [1,n)∀m∈[1,n)，满足gcd(n,m)=1gcd(n,m)=1gcd(n,m)=1的mmm的总个数即为φ(n)\\varphi(n)φ(n)的值。举个例子，φ(3)=2\\varphi(3)=2φ(3)=2，因为在[1,3)[1,3)[1,3)中，111和222均与333互质。特殊地，φ(1)=1\\varphi(1)=1φ(1)=1。 欧拉函数有如下计算公式：若nnn可被表示为n=∏i=1kpiαin=\\prod\\limits_{i=1}^{k}p_i^{\\alpha_i}n=i=1∏k​piαi​​（算术基本定理分解式）的形式，则φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk)=n∗∏i=1k(1−1pi)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})=n*\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk​1​)=n∗i=1∏k​(1−pi​1​)。 推导思想即为用nnn减去所有[1,n)[1,n)[1,n)中所有与nnn不互质的数。在计算机上实现，首先需要分解质因数。思路如下：首先抛出第一个质因数p1p_1p1​，那么将[1,n][1,n][1,n]中所有的p1p_1p1​的倍数删去，因而可以保证筛出的数一定是nnn的质因子，否则他们将存在最大公约数p1p_1p1​。那么能被p1p_1p1​整除的数的个数（也就是nnn以内p1p_1p1​的倍数个数）为[np1][\\frac{n}{p_1}][p1​n​]——其中的中括号代表整除。 因此我们离解出欧拉函数就进了一步了，我们的过渡式子就是TS1(n)=n−[np1]−[np2]−⋯−[npk−1]−[npk]TS_1(n)=n-[\\frac{n}{p_1}]-[\\frac{n}{p_2}]-\\dots-[\\frac{n}{p_{k-1}}]-[\\frac{n}{p_k}]TS1​(n)=n−[p1​n​]−[p2​n​]−⋯−[pk−1​n​]−[pk​n​]。 好耶 别急着好耶，我们可以发现一个小小的推导谬误（可能并不是很容易发现）。当我们用p2p_2p2​去筛数时，使用的算式仍然是[np2][\\frac{n}{p_2}][p2​n​]。对于形如p1np2mp_1^np_2^mp1n​p2m​的数，会被重复筛去多次，导致多减，最终结果会小于φ(n)\\varphi(n)φ(n)。有些抽象，我们来看这张图： 易知[1,30][1,30][1,30]中可被222整除的数字共有30÷2=1530\\div 2=1530÷2=15个，能被555整除的数字共有30÷5=630\\div 5=630÷5=6个。但是如果说能被222和555整除的数字共有15+6=2115+6=2115+6=21个，显然不合常理，因为101010、202020、303030都既能被222整除，也能被555整除，如果不加排除，他们将会被减去2次。因此需要补偿损失，正确的计算方法是（仅计算能被222和555整除的数的总个数）： 能被222整除的：30÷2=1530\\div 2=1530÷2=15个 能被555整除的：30÷5=630\\div 5=630÷5=6个 同时被222和555整除的：30÷lca(2,5)=30÷10=330\\div lca(2,5)=30 \\div 10=330÷lca(2,5)=30÷10=3个 总个数：15+6−(2−1)×3=1815+6-(2-1)\\times 3=1815+6−(2−1)×3=18个（就是被绿圈和橙圈捆住的的数的个数） 那么对于222、333、555整除问题，中间的303030被重复加了3次，需减去两次平衡收支。此即容斥原理的简单思想表示。 回到欧拉函数推导上来：过渡公式TS1TS_1TS1​中的容斥问题可以解决一部分了。对于可同时被两个不同质数整除的数（例如6=2×36=2\\times36=2×3、15=3×515=3\\times515=3×5），我们加上它的总个数。 得到TS2=TS1+[np1p2]+[np1p3]+⋯+[np1pk]+[np2p3]+[np2p4]+⋯+[npk−1pk]TS_2=TS_1+[\\frac{n}{p_1p_2}]+[\\frac{n}{p_1p_3}]+\\dots+[\\frac{n}{p_1p_k}]+[\\frac{n}{p_2p_3}]+[\\frac{n}{p_2p_4}]+\\dots+[\\frac{n}{p_{k-1}p_k}]TS2​=TS1​+[p1​p2​n​]+[p1​p3​n​]+⋯+[p1​pk​n​]+[p2​p3​n​]+[p2​p4​n​]+⋯+[pk−1​pk​n​]。 当然这又有一个小问题没完没了了是不是？：对于p1 p2 p3p_1\\;p_2\\;p_3p1​p2​p3​的公倍数，会被先减去3次，然后被上一步的操作加上3次，总体不加不减。还是回到上图：中间的303030会被每个颜色的圈先减去一次、共3次，上一步的补偿操作，可以看作又被橙绿圈（橙圈和绿圈的交集）、蓝绿圈、蓝橙圈一共加上了3次。减3次加3次相当于没动，为了让它被算上，我们需要加上它，对于φ(n)\\varphi(n)φ(n)则是全部减去（因为括号外有减号需要变号，不要忘记φ(n)\\varphi(n)φ(n)是由一系列不合规的数字个数相减得来的）。得到我们的过渡态3：TS3=TS2−[np1p2p3]−[np1p2p4]−[np1p2p5]−⋯−[npk−2pk−1pk]TS_3=TS_2-[\\frac{n}{p_1p_2p_3}]-[\\frac{n}{p_1p_2p_4}]-[\\frac{n}{p_1p_2p_5}]-\\dots-[\\frac{n}{p_{k-2}p_{k-1}p_{k}}]TS3​=TS2​−[p1​p2​p3​n​]−[p1​p2​p4​n​]−[p1​p2​p5​n​]−⋯−[pk−2​pk−1​pk​n​] 又是如上的容斥判断，这里我们省去讨论。将最终的产物合并得到：φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)！（我不会合并，但是你可以把φ(n)\\varphi(n)φ(n)括号拆开看看是不是上述形式。总之，欧拉牛逼！） QEDQEDQED，好耶！终于可以好耶了…… Div2. 欧拉函数代码实现 主要是如果压成一个Div会非常的长，因此这里新开一个Div2 我们明确了欧拉函数的推导，接下来就是整理思路写代码的时间了！我们也只需跟着原始思路走就可以了。再次回忆一下：首先我们需要筛出质因数，除去它的所有倍数，再用公式φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)代入pip_ipi​就可以了。 1234567891011int eular(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; res = res * (n - 1) / n; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125; 时间复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：All Clear","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"一命已出，前来还愿","slug":"thanks","date":"2023-11-12T01:42:41.000Z","updated":"2023-11-12T01:45:04.509Z","comments":true,"path":"2023/11/12/thanks/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/thanks/","excerpt":"","text":"","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"}]},{"title":"Latex常用符号大全","slug":"latex-symbols","date":"2023-11-12T01:23:35.000Z","updated":"2023-11-26T00:56:36.729Z","comments":true,"path":"2023/11/12/latex-symbols/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/latex-symbols/","excerpt":"","text":"Part1. 运算符 Div1. 基本运算 加号：+++，键盘上有 减号：−-−，键盘上有 乘号（叉乘）: $ \\times $ \\times 乘号（数量积/点乘）：⋅\\cdot⋅ \\cdot 除号：÷\\div÷ \\div 开方/N次方根：ABCN\\sqrt[N]{ABC}NABC​ \\sqrt[N]&#123;ABC&#125; 乘方/N次幂：ANA^NAN A^N 下标：ANA_NAN​ A_N 分数：AB\\frac{A}{B}BA​ \\frac&#123;A&#125;&#123;B&#125; 等于号：===，键盘上有 约等号：≈\\approx≈ \\approx 加粗 ≈\\thickapprox≈ \\thickapprox 不等号：≠\\neq​= \\neq 恒等号/定义为：≡\\equiv≡ \\equiv 大于号：&gt;\\gt&gt; \\gt 小于号：&lt;\\lt&lt; \\lt 大于等于：≥\\geq≥ \\geq 小于等于：≤\\leq≤ \\leq 远大于：≫\\gg≫ \\gg 远小于：≪\\ll≪ \\ll 正负：±\\pm± \\pm 负正：∓\\mp∓ \\mp Div.2 几何表示 垂直：⊥\\perp⊥ \\perp 平行：∥\\parallel∥ \\parallel 角/无标记角：∠\\angle∠ \\angle 角/标记角：∡\\measuredangle∡ \\measuredangle 一般全等：≅\\cong≅ \\cong 相似：∼\\sim∼ \\sim，加粗 ∼\\thicksim∼ \\thicksim 三角形：△\\triangle△ \\triangle 正方形：□\\square□ \\square 圆：⊙\\odot⊙ \\odot 向量：AB⃗\\vec{AB}AB \\vec_&#123;AB&#125; 或 AB→\\overrightarrow{AB}AB \\overrightarrow&#123;AB&#125; Div.3 集合 属于：∈\\in∈ \\in 不属于：∉\\notin∈/​ \\notin 子集：⫅\\subseteqq⫅ \\subseteqq 真子集：⫋\\varsubsetneqq \\varsubseteqq 或 ⫋\\subsetneqq⫋ \\subsetneqq 真子集/直线在平面上：⊂\\subset⊂ \\subset 正整数集：N∗N^*N∗ N^* 或 N+N_+N+​ N_+ 并集：∪\\cup∪ \\cup 交集：∩\\cap∩ \\cap 补集：∁UA\\complement{_U^A}∁UA​ \\complement&#123;_U^A&#125; Div.4 逻辑符号 因为：∵\\because∵ 所以：∴\\therefore∴ 存在：∃\\exists∃ \\exists 不存在：∄\\nexists∄ \\nexists 任意/对于所有：∀\\forall∀ \\forall 空集：∅\\varnothing∅ \\varnothing 逻辑或：∪\\cup∪ \\cup 或 ∨\\lor∨ \\lor 逻辑与：∩\\cap∩ \\cap 或 ∧\\land∧ \\land 逻辑非：¬\\lnot¬ \\lnot 充分条件/右双箭头：⇒\\Rightarrow⇒ \\Rightarrow 大小写敏感 必要条件/左双箭头：⇐\\Leftarrow⇐ \\Leftarrow 大小写敏感 充要条件/双向双箭头：⇔\\Leftrightarrow⇔ \\Leftrightarrow 大小写敏感 Div.5 高级数学 成正比：∝\\propto∝ \\propto 定积分：∫ab\\int_{a}^{b}∫ab​ \\int_&#123;a&#125;^&#123;b&#125; 多重积分：∬ab\\iint_{a}^{b}∬ab​ \\iint_&#123;a&#125;^&#123;b&#125; 及 ∭ab\\iiint_{a}^{b}∭ab​ \\iiint_&#123;a&#125;^&#123;b&#125; 导函数/上撇号：′\\prime′ \\prime 求和：∑i=1n\\sum_{i=1}^{n}∑i=1n​ \\sum_&#123;i=1&#125;^&#123;n&#125; 求积：∏i=1n\\prod_{i=1}^{n}∏i=1n​ \\prod_&#123;i=1&#125;^&#123;n&#125; 字母数位/平均数：ABCD‾\\overline{ABCD}ABCD \\overline&#123;ABCD&#125; 整除符号：∣\\mid∣ \\mid 新定义运算符：⊕\\oplus⊕ \\oplus 及 ⊗\\otimes⊗ \\otimes 及 ⊖\\ominus⊖ \\ominus 扰动值：K~\\tilde{K}K~ \\tilde&#123;K&#125; 高德纳箭头/上箭头：3↑↑23\\uparrow \\uparrow 23↑↑2 3\\uparrow \\uparrow 2 Div.6 常数 无穷大/无限：∞\\infty∞ \\infty 圆周率：π\\piπ \\pi 普朗克常数：ℏ\\hbarℏ \\hbar 或 ℏ\\hslashℏ \\hslash Div.7 注音 一声：eˉ\\bar{e}eˉ \\bar&#123;e&#125; 二声/法语闭音符：eˊ\\acute{e}eˊ \\acute&#123;e&#125; 三声：eˇ\\check{e}eˇ \\check&#123;e&#125; 四声/法语重音符：eˋ\\grave{e}eˋ \\grave&#123;e&#125; 字母双点/德语特殊字母/特殊拼音：u¨\\ddot{u}u¨ \\ddot&#123;u&#125; 特殊发音符：a~\\tilde{a}a~ \\tilde&#123;a&#125; 抑扬符：a^\\hat{a}a^ \\hat&#123;a&#125; Div.8 希腊/希伯来字母 小写希腊字母 α\\alphaα \\alpha β\\;\\;\\;\\;\\betaβ \\beta χ\\;\\;\\;\\;\\chiχ \\chi δ\\;\\;\\;\\;\\deltaδ \\delta ϵ\\;\\;\\;\\;\\epsilonϵ \\epsilon η\\;\\;\\;\\;\\etaη \\eta γ\\gammaγ \\gamma ι\\;\\;\\;\\;\\iotaι \\iota κ\\;\\;\\;\\;\\kappaκ \\kappa λ\\;\\;\\;\\;\\lambdaλ \\lambda μ\\;\\;\\;\\;\\muμ \\mu ν\\;\\;\\;\\;\\nuν \\nu ooo o ω\\;\\;\\;\\;\\omegaω \\omega ϕ\\;\\;\\;\\;\\phiϕ \\phi π\\;\\;\\;\\;\\piπ \\pi ψ\\;\\;\\;\\;\\psiψ \\psi ρ\\;\\;\\;\\;\\rhoρ \\rho σ\\sigmaσ \\sigma τ\\;\\;\\;\\;\\tauτ \\tau θ\\;\\;\\;\\;\\thetaθ \\theta υ\\;\\;\\;\\;\\upsilonυ \\upsilon ξ\\;\\;\\;\\;\\xiξ \\xi ζ\\;\\;\\;\\;\\zetaζ \\zeta 变量希腊字母 ϝ\\digammaϝ \\digamma ε\\;\\;\\;\\;\\varepsilonε \\varepsilon ϰ\\;\\;\\;\\;\\varkappaϰ \\varkappa φ\\;\\;\\;\\;\\varphiφ \\varphi ϖ\\;\\;\\;\\;\\varpiϖ \\varpi ϱ\\;\\;\\;\\;\\varrhoϱ \\varrho ς\\varsigmaς \\varsigma ϑ\\;\\;\\;\\;\\varthetaϑ \\vartheta 大写希腊字母（仅展示大小写字母样式有差别者） Δ\\DeltaΔ \\Delta Γ\\;\\;\\;\\;\\GammaΓ \\Gamma Λ\\;\\;\\;\\;\\LambdaΛ \\Lambda Ω\\;\\;\\;\\;\\OmegaΩ \\Omega Φ\\;\\;\\;\\;\\PhiΦ \\Phi Π\\;\\;\\;\\;\\PiΠ \\Pi Ψ\\PsiΨ \\Psi Σ\\;\\;\\;\\;\\SigmaΣ \\Sigma Θ\\;\\;\\;\\;\\ThetaΘ \\Theta Υ\\;\\;\\;\\;\\UpsilonΥ \\Upsilon Ξ\\;\\;\\;\\;\\XiΞ \\Xi 希伯来文字母 ℵ\\alephℵ \\aleph ℶ\\;\\;\\;\\;\\bethℶ \\beth ℸ\\;\\;\\;\\;\\dalethℸ \\daleth ℷ\\;\\;\\;\\;\\gimelℷ \\gimel","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"}]},{"title":"DC Doujin 2023 EP1 先行预告","slug":"dcd2023ep1-trailer","date":"2023-11-05T04:32:52.000Z","updated":"2023-11-05T05:25:44.130Z","comments":true,"path":"2023/11/05/dcd2023ep1-trailer/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/dcd2023ep1-trailer/","excerpt":"","text":"DC Doujin 2023，点击访问。 DC Doujin将在11月带来他的第一部视频作品“一触即发 A Cusp Before It Rings”。这个视频，对日常学校干饭的情景进行真实再现。其中由木稿比你铁饰演的受伤学生受到热烈关注，其原型是初中部的一位学生，我们将其镜头化，力求最真实地表现出其强烈的反差感。 禁止用于商业用途，转载请注明出处 DC Doujin。 Copyright © 2023 DC Doujin, JustPureH2O. All Rights Reserved.","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"《原神》枫丹语言考究","slug":"fontainish-research","date":"2023-11-05T02:59:02.000Z","updated":"2023-11-05T04:30:50.613Z","comments":true,"path":"2023/11/05/fontainish-research/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/fontainish-research/","excerpt":"","text":"起因 这天月假，当我正为即将到来的水神池子疯狂做任务屯原石时，在列表里看到了一个悬赏整整30原石的世界任务。本着不放过任何一个给原石的任务的宗旨，我来到了秋分山西侧，白淞镇东北方向的海边房屋处。只见一位男子全身掩埋在海沙之下、动弹不得，面前摆放着一只散发香味的甜甜花酿鸡。我看他精神失常，满嘴都是“新型美容方式”的胡话又哭又闹，呜呜呜呜，好可怜呀。于是我决定帮他一把……找出了幕后黑手，此时他举起一个木牌，只见上面用老米祖传的架空文字写了一些东西，随着剧情推进，我们得知这是“抗议”（protest）。枫丹作为两个月前才开放的新国家，其文学文化充满乐子的xxs神明固然吸引了我。于是我决定用手头上有限的图片资料，整理出一份类似于枫丹语言图鉴的资料来。以便后期深入探究枫丹的风土人情。 初探 这是在上一部分中提到的，写有“抗议”（protest）的木牌，其中各个字母的对应关系已经标注出来了（相信不用标注也看得出来）。不难发现，最后一个字母与倒数第四个字母是相同的，恰巧对应上protest中字母t的位置。某种方面上证明了这一猜测的正确性，但是鉴于这抽象到与原英文字母完全不搭边的枫丹字体~~（很水体）~~实在是太过亮眼，我的内心还是有一点怀疑和否定的。那么我们将这七个字母挨个抽取出来，放到别的语境中去转译，不就可以验证它的准确性了吗？ 其实也无需这么麻烦，读完前面的大佬对提瓦特通用语的解析。我们惊奇地发现，这很水体居然与提瓦特通用语的字母如出一辙： 图片来源于：哔哩哔哩，语颂源，【原神考据】提瓦特通用文 当然也有一些变化，比如哪里可能突然多出来一横、又或者是将圆弧形的笔画变得棱角分明。图中的S和E就是两个典型例子。考虑到可能是手写体带来的美化、钝化等，我接下来去到了枫丹的主城区中，分别在蒸汽鸟报社、卡郎代沙龙前拍下了这几张图片~~（因为他们离锚点非常的近，不需要跑图）~~。 我们根据已经解译出来的提瓦特通用语字母进行对拍，发现蒸汽鸟报社的招牌上写着：LOISEAU DE VAPEUR。明显是法语，但是其中的VAPEUR和英语的VAPOR（蒸气）非常相似，因此对拍基本无误。但是由于我本人不懂法语，解释不了第一个词，只能求助于度娘。度娘也是给我甩了一个解释：鸟。并纠正了一个小错误：LOISEAU应为L’OISEAU。完美契合蒸汽鸟报社的招牌。 同理，卡郎代沙龙的门牌上写着：CARITAT。推测其原型是18世纪的姓氏德·卡里塔，孔多塞侯爵（Nicolas de Caritat）的妻子便是18世纪的一位著名沙龙主人。 最后放出蒸汽鸟报社门前牌子上的翻译： Exploring the manufacture of security machinery 探秘发条机关（守卫机器）的制造流程 Joyous tour through the aquatic workshop 水下工坊快乐一日游游记 Exclusive compilation of the past top duellists 旧时顶级决斗代理人的独家专访合集 Interview with the deboard restaurant artists 采访德波饭店的艺术家们 Iridescene tour and the new trend of music 虹彩巡游之旅，以及新派音乐","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"}]},{"title":"常用算法模板","slug":"common-algo-templates","date":"2023-10-28T06:11:51.000Z","updated":"2023-11-05T02:33:44.995Z","comments":true,"path":"2023/10/28/common-algo-templates/","link":"","permalink":"https://justpureh2o.github.io/2023/10/28/common-algo-templates/","excerpt":"","text":"1. Trie树（字典树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int son[N][70], idx = 0, cnt[N];int map(char c) &#123; // 字符映射到对应数字 if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return c - &#x27;0&#x27;; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 11; if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 37;&#125;void insert(char s[]) &#123; // 插入一个字符串 int len = strlen(s); int p = 0; // 指针 for (int i = 0; i &lt; len; i++) &#123; // 遍历字符串中每一个字符 int u = map(s[i]); // 映射到数字 if (!son[p][u]) son[p][u] = ++idx; p = son[p][u] // 更新指针，指向下一个节点 &#125; cnt[p]++;&#125;bool query(char s[]) &#123; // 查询一个字符串 int len = strlen(s); int p = 0; for (int i = 0; i &lt; len; i++) &#123; // 遍历+查找 int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return false; &#125; return cnt[p];&#125;int count(char s[]) &#123; // 对指定字符串计数 int len = strlen(s); int p = 0; // 可以用 if (query(s)) 代替下边的遍历查找 for (int i = 0; i &lt; len; i++) &#123; int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return 0; &#125; return cnt[p];&#125; 并查集 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int p[N];int find(int x) &#123; // 查找父节点+路径压缩 if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;void merge(int a, int b) &#123; // 合并两个集合 p[find(a)] = find(b);&#125;bool query(int a, int b) &#123; // 查询两个节点是否在同一个集合中 return find(a) == find(b);&#125; 单调队列 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];deque&lt;Node&gt; q;void peak(int k) &#123; // 查找区间最值，n为数组大小，k为区间大小，即区间中有k个元素 for (int i = 1; i &lt;= N; i++) &#123; // while (!q.empty() &amp;&amp; nodes[i].val &lt;= q.back().val) q.pop_back(); // 查找区间最小值，将大于号改为小于号 while (!q.empty() &amp;&amp; nodes[i].val &gt;= q.back().val) q.pop_back(); // 当新进元素大于队尾元素，删除队尾直到队尾大于新元素，或者直到队列为空 q.push_back(nodes[i]); // 将新进元素压入队尾 if (i - q.front().idx == k) q.pop_front(); // 滑出队头元素所在区间，弹出队头 if (i &gt;= k) cout&lt;&lt;q.front().val&lt;&lt;endl; &#125; &#125; 单调栈 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];stack&lt;Node&gt; stk;int ans[N];void NGE(int k) &#123; // 查找下一个更大的元素，即NGE问题 for (int i = 1; i &lt;= N; i++) &#123; // while (!stk.empty() &amp;&amp; nodes[i].val &lt; stk.back().val) // NSE问题，下一个更小的元素，仅改变大于小于号 while (!stk.empty() &amp;&amp; nodes[i].val &gt; stk.top().val) stk.pop(); // 将栈顶比当前更小的元素弹出 if (stk.empty()) ans[i] = 0; // 查无 else ans[i] = s.top(); // 顶为最大 stk.push(nodes[i]); // 压入当前 &#125; &#125; 单源最短路径 朴素Dijkstra 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稠密图，使用邻接矩阵存图int g[N][N], dist[N];bool st[N];int n; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 dist[1] = 0; // 起点最短路径就是0 for (int i = 1; i &lt;= n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; // 循环所有未确定距离的点，找出最小值 &#125; st[t] = true; // 标记访问 for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); // 间接的路径：从起点经t再连接到j点 &#125; &#125;&#125; 单源最短路径 堆优化Dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稀疏图，使用接表存图int head[N], e[N], w[N], ne[N];int idx = 0;void add(int a, int b, int x) &#123; idx++; e[idx] = b; w[idx] = x; ne[idx] = head[a]; head[a] = idx;&#125;int dist[N];bool st[N];int n;typedef pair&lt;int, int&gt; PIR; // 二元组存储点序号-距离 priority_queue&lt;PIR, vector&lt;PIR&gt;, greater&lt;PIR&gt; &gt; heap; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 heap.push((PIR) &#123;1, 0&#125;); // 初始点入队，序号为1距离为0 while (!heap.empty()) &#123; // 堆不空时 PIR t = heap.top(); // 优先队列，队头元素总为未确定点中最近的一个 int id = t.first, dis = t.second; if (st[id]) continue; for (int i = head[id]; ~i; i = ne[idx]) &#123; int j = e[i]; // 边终点 if (dist[j] &gt; dis + w[i]) &#123; dist[j] = dis + w[i]; // 更新最短距离 heap.push((PIR) &#123;j, dist[j]&#125;); // 更新的点压入优先队列 &#125; &#125; &#125;&#125; 背包类动态规划 01背包 想象你在一个绝版手办售卖会上。这里的每种手办由于需要保证它的稀有程度，活动主办方提前向卖家商议了一个计策：即保证每种老婆 手办有且只能有一个。这样他们就可以开出天价 （但要保证在物价局划定的价格上限内） （爆long long也没问题！）。那么作为一个资深 御宅 手办收藏家的你，自然不会错过这次难得的机会，你出门时偷偷拿走了麻麻の钱包，发现里面有NNN元现金（假定你不知道麻麻の银行卡密码），那么你可以买到手办的最大价值是多少？ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = c; j &gt;= v[i]; j--) &#123; // 倒着循环，c为容量上限，防止做减法时减为负数内存异常 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 但是最后还是被麻麻发现力（悲 背包类动态规划 完全背包 这种问题类似于西方魔幻小说里的情节：一位勇士无意间闯进了古代君王的藏宝阁，受金钱和权力的蛊惑。看着地上不尽的金币与皇冠，他拿出了一个麻袋。他想要在麻袋规定的最大容量内装尽可能最大价值的物品，超出规定容量，这个袋子很可能破掉，导致财宝落入山谷、沼泽等任何危险的地方。这位勇士十分谨慎，他不希望总重量超过额定重量，那么他能装的最大物品价值是多少？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; // 完全背包，即每个物品数量有无限个，可以自由装配 for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = v[i]; j &lt;= c; j++) &#123; // 正着循环，与01背包相反，c为容量上限 // 由于计算当前状态需用到dp[j-v[i]]状态，若升序循环，这个状态总会在前几步被算出 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 // dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) // 若不选择当前物品，最大价值为dp[i-1][j]，即前一个/i-1个物品，容量上限为j (j&lt;=c)时的最大价值 // 若选择当前物品，最大价值为dp[i][j-v[i]]+w[i]，因为每种物品可以放入无限个，放入第i个物品后仍然可以继续放入相同物品直到超出容量上限j &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 然而我们的勇士痴迷于装入财宝，忽视了高悬在他头顶的致命机关，随着绳子断裂，我们的勇士就此葬身于这个隐蔽的藏宝阁中，带不走任何一枚金币。因此我们的最大价值应该是000 因此我们应该拒绝这种来历不明的诱惑，青少年反诈，从我做起！ 背包类动态规划 多重背包 《竞赛班传奇》 第一部，第一幕 人物：“和蔼可亲滴”福建籍物理竞赛教练 茂华；“偷奸耍滑的”山东老家OIer 国祯；“热心尽职喜欢让同学们多多预习物理知识的”物理课代表曹牧 茂华上场，开玩笑的语气说 茂华： 电荷量滴单位是~库 仑，符号C（写下一个大C），艹！ 全班哄笑，国祯猥琐的笑，茂华眉头一蹙，表情严肃，严肃语气 茂华： 国祯！还在那里笑，曹牧，检查一下国祯有没有记笔记！ 曹牧起身走向国祯，其他人目光盯着曹牧，国祯将物理书翻开，指着笔记处，曹牧低头查看，然后抬头 曹牧： 他写了，但是…… 严肃的，急速的，愤怒之极的，气震寰宇的，振聋发聩的，势如破竹的，响彻云霄的，如雷贯耳的，不共戴天的，耳机党爆炸的，外放党社死的 茂华： 站起来！没写笔记！ 国祯吓一跳，乖乖站起，曹牧缓缓退回，众人起哄国祯，茂华声音略小 茂华： 在这里偷奸耍滑是会被刷出去滴。到时候你竞赛搞不好，高考也考滴西撇，看你到时候怎么办！ 国祯： （解释的语气）我没有偷奸耍滑！ 茂华语气有所缓和 茂华： 那你把这道题解出来，你就可以坐下了 题面： 给定NNN个物品，背包最大容量CCC。对于第iii种物品，给定每个iii种物品的大小ViV_iVi​，价值WiW_iWi​，以及个数SiS_iSi​，试求出背包可以装下物品的最大价值AAA。 国祯小嘴一撇，这还不简单？他立马拿起了一支0.5mm的黑色签字笔在草稿纸上飞速演算。得益于他积累了一坤年的OI知识，2分钟后，在众人惊异的目光中，国祯自信满满地拿出了写有正确答案的草稿纸。他将右手伸得十分用力，好像要把草稿纸怼到茂华脸上一样，他的嘴角浮现出一抹byd笑容。 只见茂华呆立原地，嘴巴微张，如同按下了暂停键。3秒钟的寂静过后，下课铃如同国祯的战鼓一般敲响，宣告这次对决以国祯的大比分取胜而落下帷幕。茂华直立的双腿尴尬的向门口转去，颤抖的双唇之间轻飘飘冒出了两个字：“下课”。随后咬紧嘴唇，一步一步踱向门外。 国祯如获新生。在众人崇拜和惊诧的目光中，他迷失了自我，他快步走向一体机，熟练地打开希沃白板，好像已经练习过成千上万遍似的，将一句话加粗写在了白板上： 通常情况下，多重背包的思路是将一堆A物品拆分成n个A物品，每个物品只能使用一次，便可转化为01背包问题 他不管大家是否了解01背包的含义，他此刻只想在众人面前分享打败茂华的喜悦感，以及打败茂华所需要的知识，这又何尝不是一种爱屋及乌的思想呢？ 第二天，当上午的物理课准时来到，茂华却没有准时跨进教室的门。通常情况下，他每次课前都会提前2分钟来到教室里对同学进行题目过关。 1分钟后，茂华挟着几本不合身份的普及组信息竞赛导论及考纲，昂首阔步地走进了一班教室。他大声说着：“通常情况下。这是国祯同学昨天下课后给你们上的课里的一句原话！” 原来茂华前一天下课后并没有跑回办公室又哭又闹大发牢骚，而是现场网购了信息竞赛教程，准备在第二天的物理课上给国祯单独上节课：学生是永远无法击败老师滴！ 他打开了浏览器，输入一行神秘的IP地址，按下回车，一个界面清爽的网站跳了出来。顶端用紫色的大写字母写着MHOI四个大字。 “牛逼吧，这是我连夜赶工自创的网站，”他笑着打开了题目列表中的第一道题，标题： 国祯接招 。国祯轻蔑地瞥了一眼，题干还是昨天那样，一模一样，“看好了国祯，”他指向下排的一行小字，“数据范围：n≤10000n \\leq 10000n≤10000！看你那吃了食的小脑袋还能不能算出这道题目。” 显然，茂华是有备而来，国祯倒吸一口冷气。手工计算绝对是行不通了，但是对于竞赛班的高思娃国祯，绝对是有两把刷子的，毕竟正如茂华所说：“偷奸耍滑耍小聪明早就被刷下去了”。 面对如此巨大的物品总数，一些牛逼娃想到了用二进制拆分表示物品个数的方法。尽管换汤不换药，本质还是一个01背包问题，但是经过祖先们灵魂的注入，茂华是肯定不敢把你踢出竞赛班滴。 ForExampleFor ExampleForExample 假设原有10个价值为2的物品，将10分为1+2+4+3，等同于有4个不同的01物品，价值分别为12=2，22=4，42=8，32=6，即2，4，8，6 国祯很快在VSCode上写出了一段教科书式的、注释易懂的模板代码，这次就算是物竞数竞化竞生竞的人也可以轻易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int idx = 0;// 记录数组下标 int main() &#123; int n, c; cin&gt;&gt;n&gt;&gt;c; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; // v w n // 即体积，价值，个数 cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k = 1; // 记录2的幂，初始值为2的0次幂，即1 //if (s == 0) s = INF; // 当题目中说数量0时默认为无限次时可以使用，这其实已经属于混合背包（多重+完全）的范畴 while (k &lt;= s) &#123; // 个数可以继续被分解 s -= k; // 更新个数 idx++; // 新的下标 v[idx] = a * k; // 分解后该物品的大小 w[idx] = b * k; // 分解后该物品的价值 k *= 2; // k更新为2的下一个幂 &#125; if (s) &#123; // 若无法被完全分解，剩下一部分 idx++; // 记录新的下标 v[idx] = a * s; // 大小 w[idx] = b * s; // 价值 &#125; &#125; // 01背包模板 for (int i = 1; i &lt;= n; i++) &#123; for (int j = c; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 国祯长舒一口气，这次他又获得了胜利。评测点加载了几秒。国祯定住了，#10号点出现一个大大的WrongAnswerWrong AnswerWrongAnswer。国祯感觉堕入了万丈深渊，只见茂华狂笑了起来，带动全班其他同学的笑容，一班霎时被笑声吞没。国祯盯着评测信息，783ms783ms783ms的运行时间让他更为疑惑，莫非茂华手动写了一个错误答案？ 国祯尴尬的转向各位同学，其他同学瞬间停止了笑容。先前还在交头接耳的同学们如同机器一般齐刷刷的转向国祯，给人一种惊悚透骨的感觉。他们异口同声张开了嘴，在茂华扭曲的笑容下，说出了让国祯后悔了一辈子的话来： “三年OI一场空，不开long long见祖宗！” OVER\\mathcal {OVER} OVER 背包类动态规划 混合背包 混合背包，顾名思义。它混合了多种背包，实际应用中这一类问题比较有现实意义。主要思路是，将分属于各个类型背包的物品用几个条件判断语句写出来，然后分别套用各类背包的解决方案进行求解。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (A) &#123; // 01背包物品，写01背包模板 &#125; if (B) &#123; // 完全背包物品，写完全背包模板 &#125; if (C) &#123; // 其他…… &#125; &#125; return 0; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"}]},{"title":"国祯文集","slug":"gz-articles","date":"2023-10-26T09:29:45.000Z","updated":"2023-11-04T08:27:07.535Z","comments":true,"path":"2023/10/26/gz-articles/","link":"","permalink":"https://justpureh2o.github.io/2023/10/26/gz-articles/","excerpt":"","text":"曾茂华到底有多六 ——By 国祯 曾茂华是中国当代著名的科学家和教育家，他以“慈父”、“良师”、“学者”等称号闻名于世。 1：曾茂华的蠢行为 曾茂华的蠢行为: 他在大学期间参加了一个乐队，并担任主唱。然而，不幸的是，由于自己的疏忽，他犯下了一件愚蠢的事情——用刀砍掉了对方的手指头。这件事让他成了学校里的头号人物之一。从那以后，他再也不敢做任何愚蠢的事情了。这是因为他害怕自己会被开除出乐队或者成为众矢之的的对象。如果他继续做出这些错误的举动，那么他会失去自己的乐队成员资格，甚至还会遭到开除。所以，为了避免发生这样的悲剧，他必须要记住：永远不要犯错！ 2：为什么他会做出这种愚蠢的事情? 曾茂华的蠢行为发生在他身上，是因为他自己没有意识到他自己的愚蠢。他不知道怎么做才能让事情变得更好，他只想走捷径，而不是去努力做好事情。这种心态会导致他做出错误的决定，因为他会忽略一些重要的信息，或者选择性地记住某些信息。当我们看到一个人犯了下述三种类型的罪时，我们通常就能预测到这个人会再犯同样的问题：1. 根本不会思考问题2. 一味追求便利3. 盲目模仿别人 3: 该如何面对这个问题? 要想解决问题,首先要认识到自己的行为是愚蠢的。只有当你明白自己做了什么蠢事时,才能够改变你的行为来避免这种错误。其次，不要让别人知道你所犯下的错误。这并不是因为你不想坦白自己所犯错误,而是因为这样会给别人带来困扰。最后,如果你真的想要解决这个问题,可以尝试通过一些有趣的方式来实现它。例如,你可以去找一位专业人士帮助你分析一下这件事情,或者试着去找到一个愿意与你分享观点和建议的人。总之,如果你认为自己的行为很蠢,那么就要大胆地承认出来。只有敢于直面自己的无知,才能真正地改善自己的生活。 曾茂华先生不仅对科学领域做出了巨大贡献，而且为国家培养出一批优秀的人才。这些人中不乏有牛顿这样伟大的人物，也有王选这样杰出的人物。","categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"CSP-J 2023 游记","slug":"journey-to-the-cspj2023","date":"2023-10-24T08:21:36.000Z","updated":"2023-11-05T00:22:51.337Z","comments":true,"path":"2023/10/24/journey-to-the-cspj2023/","link":"","permalink":"https://justpureh2o.github.io/2023/10/24/journey-to-the-cspj2023/","excerpt":"","text":"又名：《第一次考就被小学生薄纱的一集》 本次考场：绵阳东辰国际学校 第一节 赛前准备 插一句：CSP-J 2023没有设置赛前试机环节（包括CSP-S，成都绵阳都这样），个人推测可能是由于开放自选Windows和Linux系统带来的结果。如果你听见诸如：不要操作电脑，违者将作作弊处理 的话时，请将你按捺不住的双手安稳的放在双腿上，避免出现意料之外的事来。 然而赛前试机仍然是必要的一环（但是如果考场纪律有要求那就算了），因为这样可以让选手对机器有一个初步的了解。因为我本人习惯使用Win+E打开文件系统管理器，用Win+V记录剪切板数据，可是这些功能在考场电脑上都无法使用，进行赛前试机不仅可以避免因赛时临时发现无法使用某些功能而带来的苦恼~~（心态爆炸点+1）~~，而且还可以将IDE环境调整到个人喜欢的状态（例如缺省源代码，相当于每次新建代码不用重新打头文件）。选手可以不占用正式比赛时间完成一些个性化操作，方便赛时操作，其重要性不言而喻。 当然，开赛前乱猜试题PDF密码是极其无意义且几乎不可能成功的一件事，更不要使用暴力破解密码工具破解文件（相信守规矩的你也不会将这种工具带进考场里来），这么做不仅会被当做作弊者处理，而且造成的数据丢失也只能由你自己负责。 第二节 开赛之初 **考场下发的PDF文件带有密码保护，输入时请务必瞪大眼睛区分大小写字母O、o与数字0；小写字母l、大写字母I与数字1，并且将其中的特殊字符认真核对一遍。**本次考试，我有幸将密码中的数字0写成了小写字母o，于是浪费了宝贵的2分钟时间改正密码（真实情况是监考老师在黑板上书写密码时字迹不规范导致的混淆）。因此需要认真看好你的密码。 就我认为：在一开始就仔细写好文件重定向输入输出是极其重要的，因为随着考试时间的推进，你的思考重点将从细节性问题变为如何拿到更多的分数上~~（骗分）~~。你就会忽略重新写上两行重定向IO的代码，因而可能Au-&gt;Cu，光荣AFO。为了引起你的注意，使用极长的注释双斜线是可行的，我本人习惯打上断点。例如： 12//////////////////////////////////////////////// freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//////////////////////////////////////////////// freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 将比 12//freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 显眼得多——尤其是当你喜欢为每行代码写上包含心血的易懂注释时。事后你可以通过长按Ctrl+逗号（Dev-C++）的方式快速且安全的删除这些斜线。 不仅如此，看好输入输出文件名也是一个非常重要的细节，建议直接复制粘贴。对于标准样例，直接选中PDF文字再复制一般都不是一个明智的做法，手动输入也是可行的，但是对拍有时会比较繁琐（例如普及组T3的样例）。这边传授一个方便的做法：选中代码左侧序号，在WPS中直接右键菜单点击消除文字即可（本次考试我就是使用的这个方便技巧快捷复制样例数据）。最好找张纸记下来，后面会讲到原因。 顺利解锁了PDF文件，你要做的第一件事就是将四道题全部读熟。对整场比赛的题目有大致的规划，有可能你先前做题时做过与T4极其相似的题目，那么放弃显然是一个很不划算的决策。将题目读熟，大概判断一下算法实现，评估自己哪些题能做好，哪些题要放一放/完全放弃。知己知彼方能百战百胜。 赛初的状态基本上决定了你整场比赛的表现，因此在赛初就做好一切细节方面的完全准备，对你的信心增长是非常重要的！ 第三节 赛中时期 那么你现在拿到了第一题（信心题）。一般来说，CSP的复赛，算法很少裸露地出现在题目之中，前两题近似看作数学题。保证你的数学思维在线，因为第一题的思路可能千奇百怪，如果你一段时间没有思路（对于第一题大概是5~15分钟），可以考虑先做其他题目。刷新一下思维定势，有可能T1的灵感就乍现于其他题目之中。 在符合时间规划的前提下尽可能多去造hack数据，写出一段代码（尤其是T3放大模拟时）后，千万保证没有任何逻辑问题。当然，不是所有人都能只看代码就能检查的出其中的逻辑漏洞。因此你需要多造hack数据。hack数据多数情况下包括这几个要素：方程的特殊解、极端值/边界值、大数据（int越界）。在规划好的时间内想尽办法为你的代码多挑几根刺出来，你的代码才能更加趋近于满分解。 **千万不要看你旁边的人！！！**除非S组巨佬闯进了J组蒟蒻区，否则千万不要在比赛中途去看任何人的任何行为。一方面，你的行为可能被视作交谈作弊~~（喜提CCF全国通报、禁赛3年大礼包）~~；另一方面，如果你抱着嘲笑别人的心态去观察别人，那么你的脸很可能就会被你自己打烂。我在考试时因为瞧不起隔壁的一位小学生，当他开始疯狂敲代码时，我自己的心态就爆炸了——把所有人，不分男女、年龄高低，都当作你的敌人，轻视则死。同时这也给你带来一部分紧张感，会使你的发挥更佳。 给自己适当的放松与勉励，要相信，上天不是无故给你这个周末不用冒着风雨大太阳上补习班的珍贵机会（对于高中生，则是周六不用坐在教室里上正课的机会）。当你完全确认你的代码已经完美无瑕时，告诉自己：*同学们都还在悲催的上着课，我却在外边快乐的敲着代码。*如此一来可以起到调整心态的作用。 别激动到顺手关了PDF文件。如果你还记得或者是在草稿纸上写了密码，那无所谓；但是如果你没写，你的处境就非常尴尬，这时你可以举手找老师再要，但这绝对对你的心态是一个不小的打击。 第四节 赛末时期 经历三个半小时的不懈奋斗，比赛终于迎来最后的半小时。**无论你的完成情况如何，一定要用这最后的时间好好检查一下你的代码。**瞄一眼你是否有与下面类似的代码： 12freopen(&quot;uqe2.in&quot;, &quot;r&quot;, stdin); // 危freopen(&quot;uqe2.out&quot;, &quot;w&quot;, stdout); // 爆零警告 这段代码的主人是个懒人无疑了，如果你把CCF提供的附加样例复制了出来。切记最后把文件名里的序号删除，否则你就可以AFO了。 或者以下的代码： 1234#include &lt;Windows.h&gt;//其他的代码if (system(&quot;fc uqe.out uqe.ans&quot;)) cout&lt;&lt;&quot;WA&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;AC&quot;&lt;&lt;endl; 这位同学也是个Windows爱好者受害者无疑了，CCF明文规定了测试用系统为NOI Linux。因此不存在Windows.h这个头文件，如果你忘记删除了，那一定是个大大滴CE。正式比赛时，用bits/stdc++.h万能头即可(Windows和Linux通用）。我有一个考S组的朋友，因为忘记删除这个对拍头文件而喜提一个0分，直接亏大发。 不要忘记将你的重定向取消注释。你连读入输出都没有了，属实是可以AFO了。最后三分钟，请将你的蹄子挪开键盘鼠标。否则可能会越改越慌，不妨好好回想一下这周老师留了什么作业，你缺了哪些课需要去补，总之不要再动你的鼠标键盘了！如果实在是不放心编译问题，按一下F11，通过即可。保证你的工作目录下只留.cpp文件，所以将你复制的样例文件和编译的exe文件全部删除。 第五节 考试结束 **请你千万保持冷静，不要习惯性地把机器关机了。**CCF明文规定：*由关机造成的数据损失，责任由考生自负。*只需要把你的IDE关闭就好。 回家后，把周一要交的作业补好。别再谈考试的事情了，让你自己有个好心情。毕竟不管你的表现怎么样，它都过去了不是吗？","categories":[],"tags":[{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}],"categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}