{"meta":{"title":"JustPureH2O的博客","subtitle":"深水摸大鱼","description":"JustPureH2O的小窝","author":"JustPureH2O","url":"https://justpureh2o.github.io","root":"/"},"pages":[{"title":"","date":"2023-11-04T03:04:22.865Z","updated":"2023-10-26T09:09:01.873Z","comments":true,"path":"404.html","permalink":"https://justpureh2o.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2023-11-04T03:04:22.866Z","updated":"2023-10-26T08:58:13.786Z","comments":true,"path":"categories/index.html","permalink":"https://justpureh2o.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-10-26T08:03:52.000Z","updated":"2023-10-26T08:55:42.018Z","comments":true,"path":"about/index.html","permalink":"https://justpureh2o.github.io/about/index.html","excerpt":"","text":""},{"title":"DC Doujin 同人创作","date":"2023-11-04T08:33:40.000Z","updated":"2023-12-03T05:33:52.933Z","comments":true,"path":"dcdoujin/index.html","permalink":"https://justpureh2o.github.io/dcdoujin/index.html","excerpt":"","text":"DC Doujin 简介 DC Doujin 同人创作（以下简称DCD），由JustPureH2O于2023年11月5日创建。主要发布一些幽默视频，以及对应的幕后纪实。旨在用最真实最还原的镜头记录学校生活的点点滴滴。目前该频道的拍摄、剪辑、发布均由JustPureH2O一人承担，主要演员有木稿比你铁、狂三唯吾所爱 新闻 DC Doujin 2023 EP1 先行预告 DC Doujin 2023 EP1 一触即发 正式发布 演员 1. 木稿比你铁 DC Doujin 2023 EP1 拍摄前 2. 狂三唯吾所爱 （左侧）DC Doujin 2023 EP1 拍摄时"},{"title":"友情链接","date":"2023-11-04T03:04:22.867Z","updated":"2023-10-26T09:06:37.321Z","comments":true,"path":"friends/index.html","permalink":"https://justpureh2o.github.io/friends/index.html","excerpt":"","text":""},{"title":"memes","date":"2023-11-04T08:33:30.000Z","updated":"2023-11-04T08:33:30.823Z","comments":true,"path":"memes/index.html","permalink":"https://justpureh2o.github.io/memes/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-10-26T08:56:08.000Z","updated":"2023-10-26T08:57:03.066Z","comments":true,"path":"tags/index.html","permalink":"https://justpureh2o.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机房管理助手 v9.x已成功破解","slug":"cracked-23-12-23","date":"2023-12-24T00:45:33.000Z","updated":"2023-12-24T00:47:19.915Z","comments":true,"path":"2023/12/24/cracked-23-12-23/","link":"","permalink":"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23/","excerpt":"","text":"任务管理器已解禁，您也可以自由使用注册表和组策略进行其他操作","categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"}]},{"title":"DC Doujin 2023 EP1 一触即发正式发布","slug":"dcdep1-release","date":"2023-12-03T05:02:42.000Z","updated":"2023-12-03T05:32:34.969Z","comments":true,"path":"2023/12/03/dcdep1-release/","link":"","permalink":"https://justpureh2o.github.io/2023/12/03/dcdep1-release/","excerpt":"","text":"","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"信竞初等数论导论","slug":"number-theory-junior","date":"2023-11-26T01:37:52.000Z","updated":"2023-11-26T01:45:09.414Z","comments":true,"path":"2023/11/26/number-theory-junior/","link":"","permalink":"https://justpureh2o.github.io/2023/11/26/number-theory-junior/","excerpt":"","text":"引入 如果说数论是数学体系中专门用来研究数字性质的一个分支，那么初等数论则是对整数的性质进行系统性的探讨与研究。千万不要因为其中的“初等”二字小瞧这初等数论尽管名称和学习难度上都没有高等数论那么有逼格，就像初等数学之于高数，数论的所有内容均筑基于此。其中欧几里得证明的算数基本定理（一切合数都可被分解为有限个质数的乘积）在质数筛、GCD（以及LCA)计算、无理数证明等问题上均有用武之地。可以说高等数论奠基于初等数论。它同时也是初学者接触数论的必经之路。 Part1. 有关定理 算术基本定理：每一个合数都可以被分解为有限个质数的乘积。即对于任意合数nnn，都存在： n=p1c1p2c2p3c3...pkckn=p_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}n=p1c1​​p2c2​​p3c3​​...pkck​​，其中ppp为质数。 推论一：正整数nnn的正因数集合为： {n=p1b1p2b2p3b3...pibi∣1≤bi≤ci,1≤i≤k}\\{n=p_{1}^{b_1}p_{2}^{b_2}p_{3}^{b_3}...p_{i}^{b_i} \\mid 1 \\leq b_i \\leq c_i, 1 \\leq i \\leq k\\}{n=p1b1​​p2b2​​p3b3​​...pibi​​∣1≤bi​≤ci​,1≤i≤k} 推论二：正整数nnn的正因数个数为：τ(n)=(c1+1)⋅(c2+1)⋅(c3+1)...(ck+1)=∏i=1k(ci+1)\\tau (n)= (c_1+1) \\cdot(c_2+1) \\cdot (c_3+1) ... (c_k+1) =\\prod_{i=1}^{k}\\left( c_i+1\\right) \\\\τ(n)=(c1​+1)⋅(c2​+1)⋅(c3​+1)...(ck​+1)=∏i=1k​(ci​+1) 推论三：正整数nnn的所有正因数之和为 σ(n)=(p1+p12+...+p1c1+1)×(p2+p22+...+p2c2+1)×...×(pk+pk2+...+pkck+1)=∏i=1kpkck+1pk−1\\sigma(n)=(p_1+p_1^2+...+p_1^{c_1}+1)\\times (p_2+p_2^2+...+p_2^{c_2}+1)\\times...\\times (p_k+p_k^2+...+p_k^{c_k}+1)=\\prod_{i=1}^{k}\\frac{p_k^{c_k+1}}{p_k-1}σ(n)=(p1​+p12​+...+p1c1​​+1)×(p2​+p22​+...+p2c2​​+1)×...×(pk​+pk2​+...+pkck​​+1)=∏i=1k​pk​−1pkck​+1​​ 质数分布定理：区间[1,N][1,N][1,N]中，当N→∞N\\to \\inftyN→∞时，质数个数π(x)≈nln⁡n\\pi (x)\\approx \\frac{n}{\\ln n}π(x)≈lnnn​。 费马小定理： 若ppp是一个质数，则ap≡amod pa^p\\equiv a\\mod pap≡amodp（≡\\equiv≡为同余符号）。 欧拉定理（费马小定理扩展）： 若a⊥na\\perp na⊥n（aaa与nnn互质），则有aφ(n)≡1mod na^{\\varphi{(n)}} \\equiv 1 \\mod naφ(n)≡1modn，其中φ(n)\\varphi(n)φ(n)为欧拉函数。 Part2. 质数 质数的判断：除了它自身PPP以及111以外，不存在其他正整数NNN使得N∣PN\\mid PN∣P。 Div1. 质数判断 试除法： 这是三种方法中，唯一一种能做到100%正确的质数判断方法。对于给定数nnn，遍历所有[2,n][2,\\sqrt n][2,n​]间的正整数mmm，若出现m∣nm\\mid nm∣n则证明它不是质数，因为质数只能被1以及它本身整除。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及、提高 试除法の大胜利！ 费马素性检验： 是上述费马小定理的实际运用，它与常规算法思想有所不同：它主张在[2,n−1][2,n-1][2,n−1]中随机选取一个数aaa。若出现与费马小定理不符的情况，那么nnn一定为合数；若每次均符合定理，称为 费马伪素数 ，因为它很大概率是一个质数。 1234567891011bool isPrime(int n) &#123; if (n &lt;= 2) return false; int k = 10; while (k--) &#123; srand(time(0)); int a = rand() % (n - 2) + 2; if (__gcd(a, n) != 1) return false; if (qpow(a, n - 1, n) != 1) return false; &#125; return true;&#125; 复杂度：O(klog⁡n)\\mathcal O(k\\log n)O(klogn)，其中kkk为随机数检验次数，log⁡n\\log nlogn是因为使用了快速幂算法。 适用范围：提高T2及以下（慎用） 为什么用该方法判断的质数 大概率 是个质数呢？不妨测试一下561（3）、1105（5）、1729（7）（括号内为它的最小因子），你会发现函数的返回值均为true，即都为质数。可见这个算法不是100%正确的，这些“漏网之鱼”被称为“Carmichael数”。它们极其罕见，一亿范围内仅255个。也因如此，你可以通过打表特判的方式抠掉这些特例（你保证记得住就行）。2016年中国物流工人余建春给出了一个Carmichael数的判断准则，这个标准目前在国际上得到了广泛认同。 对于优化，你可以在函数起始点加入类似于if (n % 2 == 0 || n % 3 == 0) return false;的特判，进一步降低复杂度。 Miller-Rabin算法： 该算法同样无法保证结果100%准确，慎用！ MB算法实质上是对费马素性检验算法的效率和准确度优化。算法流程如下： 将n−1n-1n−1分解为2s+d2^s+d2s+d的形式，其中ddd为奇数 从[2,n−2][2,n-2][2,n−2]中选取整数aaa，称为“基数” 计算admod na^d \\mod nadmodn的值，若结果为111或n−1n-1n−1，则可能为质数，继续检验 若结果不等于111或n−1n-1n−1，计算a2dmod na^{2d} \\mod na2dmodn、a4dmod na^{4d} \\mod na4dmodn、a6dmod na^{6d} \\mod na6dmodn……a2s−1dmod na^{2^{s-1}d} \\mod na2s−1dmodn的值，若结果等于n−1n-1n−1，则可能为质数，继续检验 若都不等于111，则nnn一定是合数。称为强费马证据。 当然，它同样有特例，称为强伪质数，如2047（23）、3277（29）、4033（39）等（括号内为它的最小因子）。 Div2. 质数筛 常见的质数筛法有：试除法、埃氏筛、线性筛。 试除法：从质数定义出发，即存在一个正整数NNN，对于任意[2,N][2,\\sqrt N][2,N​]间的正整数MMM，总有Nmod M≠0N\\mod M \\neq 0NmodM​=0成立。代码实现只需枚举[2,N][2, \\sqrt N][2,N​]间所有正整数，并让NNN对其取余。若取模运算出现000则代表它不为质数，没有出现000则为质数。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(N)\\mathcal O( \\sqrt N )O(N​) 适用范围：普及T2及以下 这里所展示的试除法代码实际上经过一轮优化。若严格根据质数定义，第二行的循环上限应为n−1n-1n−1。考虑到如下性质：∀m∈[2,N]\\forall m\\in [2,\\sqrt N]∀m∈[2,N​]，若m∣Nm\\mid Nm∣N，则一定有Nm∣N\\frac{N}{m}\\mid NmN​∣N。因此可以将循环上限压缩至N\\sqrt NN​。 埃氏筛：全称叫埃拉托斯特尼筛法，老哥生活在2200年前的古希腊，不借助望远镜就计算出了地球的周长（与真实值偏差仅0.96%）、同时他也是第一位根据经纬线绘制出世界地图的人、也是最先提出将地球根据南北回归线分为“五带”的大人物。他提出的筛法核心思想如下： 第一步：列出从2开始的一列连续数字；第二步：选出第一个质数（本例中为2），将该质数标记，将数列中它的的所有倍数划去；第三步：若数列中的末项小于它前一项的平方，则质数已全部筛出；否则返回第二步。 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; &#125; for (int j = 2; i * j &lt;= n; j ++) vis[i * j] = true; &#125;&#125; 其中，prime数组存储质数，vis数组用于标记（即上文中“划去数字”），变量cnt则存储[2,N][2,N][2,N]中质数的个数。 复杂度：O(nln⁡n)\\mathcal O(n\\ln{n})O(nlnn) 适用范围：普及T2及以下 但是继续观察算法发现：我们其实无需将所有iii的倍数删去，只需删去前一步得出的质数的所有倍数即可。 这与前文介绍的埃氏法核心相符。因此将jjj循环迁移至条件判断中即可： 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) vis[j] = true; &#125; &#125;&#125; 优化复杂度：O(nlog⁡log⁡n)\\mathcal O(n\\log{\\log n})O(nloglogn) 适用范围：普及T3及以下 线性筛/欧拉筛：实质是埃氏筛的线性优化。因为在埃氏筛中，有些数字被重复筛了多次（例如30会被2、3、5筛到）。本着线性优化的原则，我们需要找到一个方法，使得每个合数仅被筛选一次。主要思想如下： 我们发现，线性筛和埃氏筛均使用了质数的nnn倍为合数的结论。我们只需要保证每一个数仅被它自身的最小质因数筛出即可。即对于数字mmm，m⋅pim\\cdot p_im⋅pi​是一个合数，且m⋅pim\\cdot p_im⋅pi​只会被pip_ipi​筛出。 123456789void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) &#123; vis[prime[j] * i] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及、提高 Part3. 因数 因数定义： 对于一个数nnn，若存在一个正整数mmm使得m∣nm\\mid nm∣n，则称mmm是nnn的因数。 Div1. 因数分解法 试除法：万能暴力解法。即遍历[2,n][2,\\sqrt n][2,n​]间的所有数mmm，若可以整除nnn，则mmm和nm\\frac{n}{m}mn​均为nnn的因数。特殊情况：n\\sqrt nn​为整数时，因数仅有n\\sqrt nn​本身，因此需特判。 123456789101112vector&lt;int&gt; get(int n) &#123; vector&lt;int&gt; ret; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret.push_back(i); ret.push_back(n / i); &#125; if (n % (i * i) == 0) ret.pop_back(); &#125; sort(ret.begin(), ret.end()); return ret;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及T1 Div2.最大公约数 辗转相除法： 又是我们大名鼎鼎的欧几里得老先生提出的一套公约数算法，整个算极其简洁：核心只有一行，即： 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数 可以写出： 123int gcd(int a, int b) &#123; return b ? gcd(a, a % b) : a; &#125; 但是为什么gcd(a,b)=gcd(a,amod b)gcd(a,b)=gcd(a,a\\mod b)gcd(a,b)=gcd(a,amodb)呢？我们可以通过以下方法证明： 假设如下关系：A=B⋅C+DA=B\\cdot C + DA=B⋅C+D。其中被除数AAA，除数BBB，商CCC，余数DDD。则Amod B=Amod C=DA\\mod B=A\\mod C=DAmodB=AmodC=D。 首先证明充分性：令A=a⋅kA=a\\cdot kA=a⋅k、B=b⋅kB=b\\cdot kB=b⋅k，即二者有相同因子kkk。 代入初始除法算式得：D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C)D=A-B\\cdot C\\rightarrow a\\cdot k-b\\cdot k\\cdot C\\rightarrow k(a-b\\cdot C)D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C) 接着由于加减乘法的封闭性，即一个整数进行加减乘运算得到的结果同样是一个整数。可以得出：D=k⋅N∣N∈N+D=k\\cdot N\\mid N\\in \\mathbb{N_+}D=k⋅N∣N∈N+​。即DDD（Amod BA\\mod BAmodB）与AAA有共同因子。 接下来证必要性。令B=b⋅qB=b\\cdot qB=b⋅q、D=d⋅qD=d\\cdot qD=d⋅q Stein算法： 上一个方法的明显缺点在于，它处理大质数的效率并不好（但总体来说是很好的），因为它使用了取余运算，这会减慢一些速度。可以理解，生在2000多年前——一个没有电脑和OI的古希腊社会，这个算法已经足够兼顾常规效率和手推难度了。但是步入21世纪，加快的生活节奏毒瘤数据使得人们对更快算法的需求空前高涨。Stein算法便应运而生。 算法流程如下： 任意给定两个正整数，先判断它们是否都是偶数，若是，则用2约简，若不是，则执行第二步。 若两数是一奇一偶，则偶数除以2，直至两数都成为奇数。再以较大的数减较小的数，接着取所得的差与较小的数，若两数一奇一偶，仍然偶数除以2，直至两数都成为奇数。再次以大数减小数。不断重复这个操作，直到所得的减数和差相等为止。 两数相等时，第一步中约掉的若干个2与第二步中最终的等数的乘积就是所求的最大公约数。 123456789101112131415161718192021222324int gcd(int a, int b) &#123; int p = 0, t; if (!(1 &amp; a) &amp;&amp; !(1 &amp; b)) &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; p++; &#125; while (!(1 &amp; a)) a &gt;&gt;= 1; while (!(1 &amp; b)) b &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (a = ((a - b) &gt;&gt; 1)) &#123; while (!(1 &amp; a)) a &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; &#125; return b &lt;&lt; p;&#125; 这个算法的优点在于：它大大优化了大质数的运算。但可惜的是，它的代码量膨胀了8倍，因此不太建议赛时使用。毕竟C++都给你内置了__gcd()函数嘛，干嘛不偷个懒？ Div3. 最小公倍数 我们可以简单概括成一句话： 两个数的最小公倍数等于这两个数的乘积与这两个数最大公约数的商 即：lca(a,b)=a⋅bgcd(a,b)lca(a,b)=\\frac{a\\cdot b}{gcd(a,b)}lca(a,b)=gcd(a,b)a⋅b​ 凭啥呀？ 我们假设两个数AAA和BBB有最大公约数xxx，则A=a⋅xA=a\\cdot xA=a⋅x，且B=b⋅xB=b\\cdot xB=b⋅x。并且aaa和bbb一定互质（若不互质，AAA和BBB的最大公约数就不会是xxx，而是一个比xxx大的值）。 由乘法交换律，可知：A⋅B=B⋅A→A⋅b⋅x=B⋅a⋅xA\\cdot B = B\\cdot A\\rightarrow A\\cdot b \\cdot x=B\\cdot a\\cdot xA⋅B=B⋅A→A⋅b⋅x=B⋅a⋅x 消去xxx得：A⋅b=B⋅aA\\cdot b=B\\cdot aA⋅b=B⋅a。因为aaa、bbb互质，所以A⋅bA\\cdot bA⋅b或者B⋅aB\\cdot aB⋅a即为两个数的最小公倍数。得证。 Part4. 欧拉函数相关 Div1. 欧拉函数推导 问：论牧师欧拉有多么的高产 答：平均每年800页数学论文你说高不高产嘛 欧拉函数，记作φ(n)\\varphi(n)φ(n)。表示[1,n)[1,n)[1,n)中与nnn互质的数的个数，即∀m∈[1,n)\\forall m\\in [1,n)∀m∈[1,n)，满足gcd(n,m)=1gcd(n,m)=1gcd(n,m)=1的mmm的总个数即为φ(n)\\varphi(n)φ(n)的值。举个例子，φ(3)=2\\varphi(3)=2φ(3)=2，因为在[1,3)[1,3)[1,3)中，111和222均与333互质。特殊地，φ(1)=1\\varphi(1)=1φ(1)=1。 欧拉函数有如下计算公式：若nnn可被表示为n=∏i=1kpiαin=\\prod\\limits_{i=1}^{k}p_i^{\\alpha_i}n=i=1∏k​piαi​​（算术基本定理分解式）的形式，则φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk)=n∗∏i=1k(1−1pi)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})=n*\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk​1​)=n∗i=1∏k​(1−pi​1​)。 推导思想即为用nnn减去所有[1,n)[1,n)[1,n)中所有与nnn不互质的数。在计算机上实现，首先需要分解质因数。思路如下：首先抛出第一个质因数p1p_1p1​，那么将[1,n][1,n][1,n]中所有的p1p_1p1​的倍数删去，因而可以保证筛出的数一定是nnn的质因子，否则他们将存在最大公约数p1p_1p1​。那么能被p1p_1p1​整除的数的个数（也就是nnn以内p1p_1p1​的倍数个数）为[np1][\\frac{n}{p_1}][p1​n​]——其中的中括号代表整除。 因此我们离解出欧拉函数就进了一步了，我们的过渡式子就是TS1(n)=n−[np1]−[np2]−⋯−[npk−1]−[npk]TS_1(n)=n-[\\frac{n}{p_1}]-[\\frac{n}{p_2}]-\\dots-[\\frac{n}{p_{k-1}}]-[\\frac{n}{p_k}]TS1​(n)=n−[p1​n​]−[p2​n​]−⋯−[pk−1​n​]−[pk​n​]。 好耶 别急着好耶，我们可以发现一个小小的推导谬误（可能并不是很容易发现）。当我们用p2p_2p2​去筛数时，使用的算式仍然是[np2][\\frac{n}{p_2}][p2​n​]。对于形如p1np2mp_1^np_2^mp1n​p2m​的数，会被重复筛去多次，导致多减，最终结果会小于φ(n)\\varphi(n)φ(n)。有些抽象，我们来看这张图： 易知[1,30][1,30][1,30]中可被222整除的数字共有30÷2=1530\\div 2=1530÷2=15个，能被555整除的数字共有30÷5=630\\div 5=630÷5=6个。但是如果说能被222和555整除的数字共有15+6=2115+6=2115+6=21个，显然不合常理，因为101010、202020、303030都既能被222整除，也能被555整除，如果不加排除，他们将会被减去2次。因此需要补偿损失，正确的计算方法是（仅计算能被222和555整除的数的总个数）： 能被222整除的：30÷2=1530\\div 2=1530÷2=15个 能被555整除的：30÷5=630\\div 5=630÷5=6个 同时被222和555整除的：30÷lca(2,5)=30÷10=330\\div lca(2,5)=30 \\div 10=330÷lca(2,5)=30÷10=3个 总个数：15+6−(2−1)×3=1815+6-(2-1)\\times 3=1815+6−(2−1)×3=18个（就是被绿圈和橙圈捆住的的数的个数） 那么对于222、333、555整除问题，中间的303030被重复加了3次，需减去两次平衡收支。此即容斥原理的简单思想表示。 回到欧拉函数推导上来：过渡公式TS1TS_1TS1​中的容斥问题可以解决一部分了。对于可同时被两个不同质数整除的数（例如6=2×36=2\\times36=2×3、15=3×515=3\\times515=3×5），我们加上它的总个数。 得到TS2=TS1+[np1p2]+[np1p3]+⋯+[np1pk]+[np2p3]+[np2p4]+⋯+[npk−1pk]TS_2=TS_1+[\\frac{n}{p_1p_2}]+[\\frac{n}{p_1p_3}]+\\dots+[\\frac{n}{p_1p_k}]+[\\frac{n}{p_2p_3}]+[\\frac{n}{p_2p_4}]+\\dots+[\\frac{n}{p_{k-1}p_k}]TS2​=TS1​+[p1​p2​n​]+[p1​p3​n​]+⋯+[p1​pk​n​]+[p2​p3​n​]+[p2​p4​n​]+⋯+[pk−1​pk​n​]。 当然这又有一个小问题没完没了了是不是？：对于p1 p2 p3p_1\\;p_2\\;p_3p1​p2​p3​的公倍数，会被先减去3次，然后被上一步的操作加上3次，总体不加不减。还是回到上图：中间的303030会被每个颜色的圈先减去一次、共3次，上一步的补偿操作，可以看作又被橙绿圈（橙圈和绿圈的交集）、蓝绿圈、蓝橙圈一共加上了3次。减3次加3次相当于没动，为了让它被算上，我们需要加上它，对于φ(n)\\varphi(n)φ(n)则是全部减去（因为括号外有减号需要变号，不要忘记φ(n)\\varphi(n)φ(n)是由一系列不合规的数字个数相减得来的）。得到我们的过渡态3：TS3=TS2−[np1p2p3]−[np1p2p4]−[np1p2p5]−⋯−[npk−2pk−1pk]TS_3=TS_2-[\\frac{n}{p_1p_2p_3}]-[\\frac{n}{p_1p_2p_4}]-[\\frac{n}{p_1p_2p_5}]-\\dots-[\\frac{n}{p_{k-2}p_{k-1}p_{k}}]TS3​=TS2​−[p1​p2​p3​n​]−[p1​p2​p4​n​]−[p1​p2​p5​n​]−⋯−[pk−2​pk−1​pk​n​] 又是如上的容斥判断，这里我们省去讨论。将最终的产物合并得到：φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)！（我不会合并，但是你可以把φ(n)\\varphi(n)φ(n)括号拆开看看是不是上述形式。总之，欧拉牛逼！） QEDQEDQED，好耶！终于可以好耶了…… Div2. 欧拉函数代码实现 主要是如果压成一个Div会非常的长，因此这里新开一个Div2 我们明确了欧拉函数的推导，接下来就是整理思路写代码的时间了！我们也只需跟着原始思路走就可以了。再次回忆一下：首先我们需要筛出质因数，除去它的所有倍数，再用公式φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)代入pip_ipi​就可以了。 1234567891011int eular(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; res = res * (n - 1) / n; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125; 时间复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：All Clear","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"一命已出，前来还愿","slug":"thanks","date":"2023-11-12T01:42:41.000Z","updated":"2023-11-12T01:45:04.509Z","comments":true,"path":"2023/11/12/thanks/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/thanks/","excerpt":"","text":"","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"}]},{"title":"Latex常用符号大全","slug":"latex-symbols","date":"2023-11-12T01:23:35.000Z","updated":"2023-11-26T00:56:36.729Z","comments":true,"path":"2023/11/12/latex-symbols/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/latex-symbols/","excerpt":"","text":"Part1. 运算符 Div1. 基本运算 加号：+++，键盘上有 减号：−-−，键盘上有 乘号（叉乘）: $ \\times $ \\times 乘号（数量积/点乘）：⋅\\cdot⋅ \\cdot 除号：÷\\div÷ \\div 开方/N次方根：ABCN\\sqrt[N]{ABC}NABC​ \\sqrt[N]&#123;ABC&#125; 乘方/N次幂：ANA^NAN A^N 下标：ANA_NAN​ A_N 分数：AB\\frac{A}{B}BA​ \\frac&#123;A&#125;&#123;B&#125; 等于号：===，键盘上有 约等号：≈\\approx≈ \\approx 加粗 ≈\\thickapprox≈ \\thickapprox 不等号：≠\\neq​= \\neq 恒等号/定义为：≡\\equiv≡ \\equiv 大于号：&gt;\\gt&gt; \\gt 小于号：&lt;\\lt&lt; \\lt 大于等于：≥\\geq≥ \\geq 小于等于：≤\\leq≤ \\leq 远大于：≫\\gg≫ \\gg 远小于：≪\\ll≪ \\ll 正负：±\\pm± \\pm 负正：∓\\mp∓ \\mp Div.2 几何表示 垂直：⊥\\perp⊥ \\perp 平行：∥\\parallel∥ \\parallel 角/无标记角：∠\\angle∠ \\angle 角/标记角：∡\\measuredangle∡ \\measuredangle 一般全等：≅\\cong≅ \\cong 相似：∼\\sim∼ \\sim，加粗 ∼\\thicksim∼ \\thicksim 三角形：△\\triangle△ \\triangle 正方形：□\\square□ \\square 圆：⊙\\odot⊙ \\odot 向量：AB⃗\\vec{AB}AB \\vec_&#123;AB&#125; 或 AB→\\overrightarrow{AB}AB \\overrightarrow&#123;AB&#125; Div.3 集合 属于：∈\\in∈ \\in 不属于：∉\\notin∈/​ \\notin 子集：⫅\\subseteqq⫅ \\subseteqq 真子集：⫋\\varsubsetneqq \\varsubseteqq 或 ⫋\\subsetneqq⫋ \\subsetneqq 真子集/直线在平面上：⊂\\subset⊂ \\subset 正整数集：N∗N^*N∗ N^* 或 N+N_+N+​ N_+ 并集：∪\\cup∪ \\cup 交集：∩\\cap∩ \\cap 补集：∁UA\\complement{_U^A}∁UA​ \\complement&#123;_U^A&#125; Div.4 逻辑符号 因为：∵\\because∵ 所以：∴\\therefore∴ 存在：∃\\exists∃ \\exists 不存在：∄\\nexists∄ \\nexists 任意/对于所有：∀\\forall∀ \\forall 空集：∅\\varnothing∅ \\varnothing 逻辑或：∪\\cup∪ \\cup 或 ∨\\lor∨ \\lor 逻辑与：∩\\cap∩ \\cap 或 ∧\\land∧ \\land 逻辑非：¬\\lnot¬ \\lnot 充分条件/右双箭头：⇒\\Rightarrow⇒ \\Rightarrow 大小写敏感 必要条件/左双箭头：⇐\\Leftarrow⇐ \\Leftarrow 大小写敏感 充要条件/双向双箭头：⇔\\Leftrightarrow⇔ \\Leftrightarrow 大小写敏感 Div.5 高级数学 成正比：∝\\propto∝ \\propto 定积分：∫ab\\int_{a}^{b}∫ab​ \\int_&#123;a&#125;^&#123;b&#125; 多重积分：∬ab\\iint_{a}^{b}∬ab​ \\iint_&#123;a&#125;^&#123;b&#125; 及 ∭ab\\iiint_{a}^{b}∭ab​ \\iiint_&#123;a&#125;^&#123;b&#125; 导函数/上撇号：′\\prime′ \\prime 求和：∑i=1n\\sum_{i=1}^{n}∑i=1n​ \\sum_&#123;i=1&#125;^&#123;n&#125; 求积：∏i=1n\\prod_{i=1}^{n}∏i=1n​ \\prod_&#123;i=1&#125;^&#123;n&#125; 字母数位/平均数：ABCD‾\\overline{ABCD}ABCD \\overline&#123;ABCD&#125; 整除符号：∣\\mid∣ \\mid 新定义运算符：⊕\\oplus⊕ \\oplus 及 ⊗\\otimes⊗ \\otimes 及 ⊖\\ominus⊖ \\ominus 扰动值：K~\\tilde{K}K~ \\tilde&#123;K&#125; 高德纳箭头/上箭头：3↑↑23\\uparrow \\uparrow 23↑↑2 3\\uparrow \\uparrow 2 Div.6 常数 无穷大/无限：∞\\infty∞ \\infty 圆周率：π\\piπ \\pi 普朗克常数：ℏ\\hbarℏ \\hbar 或 ℏ\\hslashℏ \\hslash Div.7 注音 一声：eˉ\\bar{e}eˉ \\bar&#123;e&#125; 二声/法语闭音符：eˊ\\acute{e}eˊ \\acute&#123;e&#125; 三声：eˇ\\check{e}eˇ \\check&#123;e&#125; 四声/法语重音符：eˋ\\grave{e}eˋ \\grave&#123;e&#125; 字母双点/德语特殊字母/特殊拼音：u¨\\ddot{u}u¨ \\ddot&#123;u&#125; 特殊发音符：a~\\tilde{a}a~ \\tilde&#123;a&#125; 抑扬符：a^\\hat{a}a^ \\hat&#123;a&#125; Div.8 希腊/希伯来字母 小写希腊字母 α\\alphaα \\alpha β\\;\\;\\;\\;\\betaβ \\beta χ\\;\\;\\;\\;\\chiχ \\chi δ\\;\\;\\;\\;\\deltaδ \\delta ϵ\\;\\;\\;\\;\\epsilonϵ \\epsilon η\\;\\;\\;\\;\\etaη \\eta γ\\gammaγ \\gamma ι\\;\\;\\;\\;\\iotaι \\iota κ\\;\\;\\;\\;\\kappaκ \\kappa λ\\;\\;\\;\\;\\lambdaλ \\lambda μ\\;\\;\\;\\;\\muμ \\mu ν\\;\\;\\;\\;\\nuν \\nu ooo o ω\\;\\;\\;\\;\\omegaω \\omega ϕ\\;\\;\\;\\;\\phiϕ \\phi π\\;\\;\\;\\;\\piπ \\pi ψ\\;\\;\\;\\;\\psiψ \\psi ρ\\;\\;\\;\\;\\rhoρ \\rho σ\\sigmaσ \\sigma τ\\;\\;\\;\\;\\tauτ \\tau θ\\;\\;\\;\\;\\thetaθ \\theta υ\\;\\;\\;\\;\\upsilonυ \\upsilon ξ\\;\\;\\;\\;\\xiξ \\xi ζ\\;\\;\\;\\;\\zetaζ \\zeta 变量希腊字母 ϝ\\digammaϝ \\digamma ε\\;\\;\\;\\;\\varepsilonε \\varepsilon ϰ\\;\\;\\;\\;\\varkappaϰ \\varkappa φ\\;\\;\\;\\;\\varphiφ \\varphi ϖ\\;\\;\\;\\;\\varpiϖ \\varpi ϱ\\;\\;\\;\\;\\varrhoϱ \\varrho ς\\varsigmaς \\varsigma ϑ\\;\\;\\;\\;\\varthetaϑ \\vartheta 大写希腊字母（仅展示大小写字母样式有差别者） Δ\\DeltaΔ \\Delta Γ\\;\\;\\;\\;\\GammaΓ \\Gamma Λ\\;\\;\\;\\;\\LambdaΛ \\Lambda Ω\\;\\;\\;\\;\\OmegaΩ \\Omega Φ\\;\\;\\;\\;\\PhiΦ \\Phi Π\\;\\;\\;\\;\\PiΠ \\Pi Ψ\\PsiΨ \\Psi Σ\\;\\;\\;\\;\\SigmaΣ \\Sigma Θ\\;\\;\\;\\;\\ThetaΘ \\Theta Υ\\;\\;\\;\\;\\UpsilonΥ \\Upsilon Ξ\\;\\;\\;\\;\\XiΞ \\Xi 希伯来文字母 ℵ\\alephℵ \\aleph ℶ\\;\\;\\;\\;\\bethℶ \\beth ℸ\\;\\;\\;\\;\\dalethℸ \\daleth ℷ\\;\\;\\;\\;\\gimelℷ \\gimel","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"}]},{"title":"DC Doujin 2023 EP1 先行预告","slug":"dcd2023ep1-trailer","date":"2023-11-05T04:32:52.000Z","updated":"2023-11-05T05:25:44.130Z","comments":true,"path":"2023/11/05/dcd2023ep1-trailer/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/dcd2023ep1-trailer/","excerpt":"","text":"DC Doujin 2023，点击访问。 DC Doujin将在11月带来他的第一部视频作品“一触即发 A Cusp Before It Rings”。这个视频，对日常学校干饭的情景进行真实再现。其中由木稿比你铁饰演的受伤学生受到热烈关注，其原型是初中部的一位学生，我们将其镜头化，力求最真实地表现出其强烈的反差感。 禁止用于商业用途，转载请注明出处 DC Doujin。 Copyright © 2023 DC Doujin, JustPureH2O. All Rights Reserved.","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"《原神》枫丹语言考究","slug":"fontainish-research","date":"2023-11-05T02:59:02.000Z","updated":"2023-11-05T04:30:50.613Z","comments":true,"path":"2023/11/05/fontainish-research/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/fontainish-research/","excerpt":"","text":"起因 这天月假，当我正为即将到来的水神池子疯狂做任务屯原石时，在列表里看到了一个悬赏整整30原石的世界任务。本着不放过任何一个给原石的任务的宗旨，我来到了秋分山西侧，白淞镇东北方向的海边房屋处。只见一位男子全身掩埋在海沙之下、动弹不得，面前摆放着一只散发香味的甜甜花酿鸡。我看他精神失常，满嘴都是“新型美容方式”的胡话又哭又闹，呜呜呜呜，好可怜呀。于是我决定帮他一把……找出了幕后黑手，此时他举起一个木牌，只见上面用老米祖传的架空文字写了一些东西，随着剧情推进，我们得知这是“抗议”（protest）。枫丹作为两个月前才开放的新国家，其文学文化充满乐子的xxs神明固然吸引了我。于是我决定用手头上有限的图片资料，整理出一份类似于枫丹语言图鉴的资料来。以便后期深入探究枫丹的风土人情。 初探 这是在上一部分中提到的，写有“抗议”（protest）的木牌，其中各个字母的对应关系已经标注出来了（相信不用标注也看得出来）。不难发现，最后一个字母与倒数第四个字母是相同的，恰巧对应上protest中字母t的位置。某种方面上证明了这一猜测的正确性，但是鉴于这抽象到与原英文字母完全不搭边的枫丹字体~~（很水体）~~实在是太过亮眼，我的内心还是有一点怀疑和否定的。那么我们将这七个字母挨个抽取出来，放到别的语境中去转译，不就可以验证它的准确性了吗？ 其实也无需这么麻烦，读完前面的大佬对提瓦特通用语的解析。我们惊奇地发现，这很水体居然与提瓦特通用语的字母如出一辙： 图片来源于：哔哩哔哩，语颂源，【原神考据】提瓦特通用文 当然也有一些变化，比如哪里可能突然多出来一横、又或者是将圆弧形的笔画变得棱角分明。图中的S和E就是两个典型例子。考虑到可能是手写体带来的美化、钝化等，我接下来去到了枫丹的主城区中，分别在蒸汽鸟报社、卡郎代沙龙前拍下了这几张图片~~（因为他们离锚点非常的近，不需要跑图）~~。 我们根据已经解译出来的提瓦特通用语字母进行对拍，发现蒸汽鸟报社的招牌上写着：LOISEAU DE VAPEUR。明显是法语，但是其中的VAPEUR和英语的VAPOR（蒸气）非常相似，因此对拍基本无误。但是由于我本人不懂法语，解释不了第一个词，只能求助于度娘。度娘也是给我甩了一个解释：鸟。并纠正了一个小错误：LOISEAU应为L’OISEAU。完美契合蒸汽鸟报社的招牌。 同理，卡郎代沙龙的门牌上写着：CARITAT。推测其原型是18世纪的姓氏德·卡里塔，孔多塞侯爵（Nicolas de Caritat）的妻子便是18世纪的一位著名沙龙主人。 最后放出蒸汽鸟报社门前牌子上的翻译： Exploring the manufacture of security machinery 探秘发条机关（守卫机器）的制造流程 Joyous tour through the aquatic workshop 水下工坊快乐一日游游记 Exclusive compilation of the past top duellists 旧时顶级决斗代理人的独家专访合集 Interview with the deboard restaurant artists 采访德波饭店的艺术家们 Iridescene tour and the new trend of music 虹彩巡游之旅，以及新派音乐","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"}]},{"title":"常用算法模板","slug":"common-algo-templates","date":"2023-10-28T06:11:51.000Z","updated":"2023-11-05T02:33:44.995Z","comments":true,"path":"2023/10/28/common-algo-templates/","link":"","permalink":"https://justpureh2o.github.io/2023/10/28/common-algo-templates/","excerpt":"","text":"1. Trie树（字典树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int son[N][70], idx = 0, cnt[N];int map(char c) &#123; // 字符映射到对应数字 if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return c - &#x27;0&#x27;; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 11; if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 37;&#125;void insert(char s[]) &#123; // 插入一个字符串 int len = strlen(s); int p = 0; // 指针 for (int i = 0; i &lt; len; i++) &#123; // 遍历字符串中每一个字符 int u = map(s[i]); // 映射到数字 if (!son[p][u]) son[p][u] = ++idx; p = son[p][u] // 更新指针，指向下一个节点 &#125; cnt[p]++;&#125;bool query(char s[]) &#123; // 查询一个字符串 int len = strlen(s); int p = 0; for (int i = 0; i &lt; len; i++) &#123; // 遍历+查找 int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return false; &#125; return cnt[p];&#125;int count(char s[]) &#123; // 对指定字符串计数 int len = strlen(s); int p = 0; // 可以用 if (query(s)) 代替下边的遍历查找 for (int i = 0; i &lt; len; i++) &#123; int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return 0; &#125; return cnt[p];&#125; 并查集 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int p[N];int find(int x) &#123; // 查找父节点+路径压缩 if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;void merge(int a, int b) &#123; // 合并两个集合 p[find(a)] = find(b);&#125;bool query(int a, int b) &#123; // 查询两个节点是否在同一个集合中 return find(a) == find(b);&#125; 单调队列 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];deque&lt;Node&gt; q;void peak(int k) &#123; // 查找区间最值，n为数组大小，k为区间大小，即区间中有k个元素 for (int i = 1; i &lt;= N; i++) &#123; // while (!q.empty() &amp;&amp; nodes[i].val &lt;= q.back().val) q.pop_back(); // 查找区间最小值，将大于号改为小于号 while (!q.empty() &amp;&amp; nodes[i].val &gt;= q.back().val) q.pop_back(); // 当新进元素大于队尾元素，删除队尾直到队尾大于新元素，或者直到队列为空 q.push_back(nodes[i]); // 将新进元素压入队尾 if (i - q.front().idx == k) q.pop_front(); // 滑出队头元素所在区间，弹出队头 if (i &gt;= k) cout&lt;&lt;q.front().val&lt;&lt;endl; &#125; &#125; 单调栈 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];stack&lt;Node&gt; stk;int ans[N];void NGE(int k) &#123; // 查找下一个更大的元素，即NGE问题 for (int i = 1; i &lt;= N; i++) &#123; // while (!stk.empty() &amp;&amp; nodes[i].val &lt; stk.back().val) // NSE问题，下一个更小的元素，仅改变大于小于号 while (!stk.empty() &amp;&amp; nodes[i].val &gt; stk.top().val) stk.pop(); // 将栈顶比当前更小的元素弹出 if (stk.empty()) ans[i] = 0; // 查无 else ans[i] = s.top(); // 顶为最大 stk.push(nodes[i]); // 压入当前 &#125; &#125; 单源最短路径 朴素Dijkstra 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稠密图，使用邻接矩阵存图int g[N][N], dist[N];bool st[N];int n; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 dist[1] = 0; // 起点最短路径就是0 for (int i = 1; i &lt;= n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; // 循环所有未确定距离的点，找出最小值 &#125; st[t] = true; // 标记访问 for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); // 间接的路径：从起点经t再连接到j点 &#125; &#125;&#125; 单源最短路径 堆优化Dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稀疏图，使用接表存图int head[N], e[N], w[N], ne[N];int idx = 0;void add(int a, int b, int x) &#123; idx++; e[idx] = b; w[idx] = x; ne[idx] = head[a]; head[a] = idx;&#125;int dist[N];bool st[N];int n;typedef pair&lt;int, int&gt; PIR; // 二元组存储点序号-距离 priority_queue&lt;PIR, vector&lt;PIR&gt;, greater&lt;PIR&gt; &gt; heap; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 heap.push((PIR) &#123;1, 0&#125;); // 初始点入队，序号为1距离为0 while (!heap.empty()) &#123; // 堆不空时 PIR t = heap.top(); // 优先队列，队头元素总为未确定点中最近的一个 int id = t.first, dis = t.second; if (st[id]) continue; for (int i = head[id]; ~i; i = ne[idx]) &#123; int j = e[i]; // 边终点 if (dist[j] &gt; dis + w[i]) &#123; dist[j] = dis + w[i]; // 更新最短距离 heap.push((PIR) &#123;j, dist[j]&#125;); // 更新的点压入优先队列 &#125; &#125; &#125;&#125; 背包类动态规划 01背包 想象你在一个绝版手办售卖会上。这里的每种手办由于需要保证它的稀有程度，活动主办方提前向卖家商议了一个计策：即保证每种老婆 手办有且只能有一个。这样他们就可以开出天价 （但要保证在物价局划定的价格上限内） （爆long long也没问题！）。那么作为一个资深 御宅 手办收藏家的你，自然不会错过这次难得的机会，你出门时偷偷拿走了麻麻の钱包，发现里面有NNN元现金（假定你不知道麻麻の银行卡密码），那么你可以买到手办的最大价值是多少？ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = c; j &gt;= v[i]; j--) &#123; // 倒着循环，c为容量上限，防止做减法时减为负数内存异常 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 但是最后还是被麻麻发现力（悲 背包类动态规划 完全背包 这种问题类似于西方魔幻小说里的情节：一位勇士无意间闯进了古代君王的藏宝阁，受金钱和权力的蛊惑。看着地上不尽的金币与皇冠，他拿出了一个麻袋。他想要在麻袋规定的最大容量内装尽可能最大价值的物品，超出规定容量，这个袋子很可能破掉，导致财宝落入山谷、沼泽等任何危险的地方。这位勇士十分谨慎，他不希望总重量超过额定重量，那么他能装的最大物品价值是多少？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; // 完全背包，即每个物品数量有无限个，可以自由装配 for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = v[i]; j &lt;= c; j++) &#123; // 正着循环，与01背包相反，c为容量上限 // 由于计算当前状态需用到dp[j-v[i]]状态，若升序循环，这个状态总会在前几步被算出 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 // dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) // 若不选择当前物品，最大价值为dp[i-1][j]，即前一个/i-1个物品，容量上限为j (j&lt;=c)时的最大价值 // 若选择当前物品，最大价值为dp[i][j-v[i]]+w[i]，因为每种物品可以放入无限个，放入第i个物品后仍然可以继续放入相同物品直到超出容量上限j &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 然而我们的勇士痴迷于装入财宝，忽视了高悬在他头顶的致命机关，随着绳子断裂，我们的勇士就此葬身于这个隐蔽的藏宝阁中，带不走任何一枚金币。因此我们的最大价值应该是000 因此我们应该拒绝这种来历不明的诱惑，青少年反诈，从我做起！ 背包类动态规划 多重背包 《竞赛班传奇》 第一部，第一幕 人物：“和蔼可亲滴”福建籍物理竞赛教练 茂华；“偷奸耍滑的”山东老家OIer 国祯；“热心尽职喜欢让同学们多多预习物理知识的”物理课代表曹牧 茂华上场，开玩笑的语气说 茂华： 电荷量滴单位是~库 仑，符号C（写下一个大C），艹！ 全班哄笑，国祯猥琐的笑，茂华眉头一蹙，表情严肃，严肃语气 茂华： 国祯！还在那里笑，曹牧，检查一下国祯有没有记笔记！ 曹牧起身走向国祯，其他人目光盯着曹牧，国祯将物理书翻开，指着笔记处，曹牧低头查看，然后抬头 曹牧： 他写了，但是…… 严肃的，急速的，愤怒之极的，气震寰宇的，振聋发聩的，势如破竹的，响彻云霄的，如雷贯耳的，不共戴天的，耳机党爆炸的，外放党社死的 茂华： 站起来！没写笔记！ 国祯吓一跳，乖乖站起，曹牧缓缓退回，众人起哄国祯，茂华声音略小 茂华： 在这里偷奸耍滑是会被刷出去滴。到时候你竞赛搞不好，高考也考滴西撇，看你到时候怎么办！ 国祯： （解释的语气）我没有偷奸耍滑！ 茂华语气有所缓和 茂华： 那你把这道题解出来，你就可以坐下了 题面： 给定NNN个物品，背包最大容量CCC。对于第iii种物品，给定每个iii种物品的大小ViV_iVi​，价值WiW_iWi​，以及个数SiS_iSi​，试求出背包可以装下物品的最大价值AAA。 国祯小嘴一撇，这还不简单？他立马拿起了一支0.5mm的黑色签字笔在草稿纸上飞速演算。得益于他积累了一坤年的OI知识，2分钟后，在众人惊异的目光中，国祯自信满满地拿出了写有正确答案的草稿纸。他将右手伸得十分用力，好像要把草稿纸怼到茂华脸上一样，他的嘴角浮现出一抹byd笑容。 只见茂华呆立原地，嘴巴微张，如同按下了暂停键。3秒钟的寂静过后，下课铃如同国祯的战鼓一般敲响，宣告这次对决以国祯的大比分取胜而落下帷幕。茂华直立的双腿尴尬的向门口转去，颤抖的双唇之间轻飘飘冒出了两个字：“下课”。随后咬紧嘴唇，一步一步踱向门外。 国祯如获新生。在众人崇拜和惊诧的目光中，他迷失了自我，他快步走向一体机，熟练地打开希沃白板，好像已经练习过成千上万遍似的，将一句话加粗写在了白板上： 通常情况下，多重背包的思路是将一堆A物品拆分成n个A物品，每个物品只能使用一次，便可转化为01背包问题 他不管大家是否了解01背包的含义，他此刻只想在众人面前分享打败茂华的喜悦感，以及打败茂华所需要的知识，这又何尝不是一种爱屋及乌的思想呢？ 第二天，当上午的物理课准时来到，茂华却没有准时跨进教室的门。通常情况下，他每次课前都会提前2分钟来到教室里对同学进行题目过关。 1分钟后，茂华挟着几本不合身份的普及组信息竞赛导论及考纲，昂首阔步地走进了一班教室。他大声说着：“通常情况下。这是国祯同学昨天下课后给你们上的课里的一句原话！” 原来茂华前一天下课后并没有跑回办公室又哭又闹大发牢骚，而是现场网购了信息竞赛教程，准备在第二天的物理课上给国祯单独上节课：学生是永远无法击败老师滴！ 他打开了浏览器，输入一行神秘的IP地址，按下回车，一个界面清爽的网站跳了出来。顶端用紫色的大写字母写着MHOI四个大字。 “牛逼吧，这是我连夜赶工自创的网站，”他笑着打开了题目列表中的第一道题，标题： 国祯接招 。国祯轻蔑地瞥了一眼，题干还是昨天那样，一模一样，“看好了国祯，”他指向下排的一行小字，“数据范围：n≤10000n \\leq 10000n≤10000！看你那吃了食的小脑袋还能不能算出这道题目。” 显然，茂华是有备而来，国祯倒吸一口冷气。手工计算绝对是行不通了，但是对于竞赛班的高思娃国祯，绝对是有两把刷子的，毕竟正如茂华所说：“偷奸耍滑耍小聪明早就被刷下去了”。 面对如此巨大的物品总数，一些牛逼娃想到了用二进制拆分表示物品个数的方法。尽管换汤不换药，本质还是一个01背包问题，但是经过祖先们灵魂的注入，茂华是肯定不敢把你踢出竞赛班滴。 ForExampleFor ExampleForExample 假设原有10个价值为2的物品，将10分为1+2+4+3，等同于有4个不同的01物品，价值分别为12=2，22=4，42=8，32=6，即2，4，8，6 国祯很快在VSCode上写出了一段教科书式的、注释易懂的模板代码，这次就算是物竞数竞化竞生竞的人也可以轻易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int idx = 0;// 记录数组下标 int main() &#123; int n, c; cin&gt;&gt;n&gt;&gt;c; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; // v w n // 即体积，价值，个数 cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k = 1; // 记录2的幂，初始值为2的0次幂，即1 //if (s == 0) s = INF; // 当题目中说数量0时默认为无限次时可以使用，这其实已经属于混合背包（多重+完全）的范畴 while (k &lt;= s) &#123; // 个数可以继续被分解 s -= k; // 更新个数 idx++; // 新的下标 v[idx] = a * k; // 分解后该物品的大小 w[idx] = b * k; // 分解后该物品的价值 k *= 2; // k更新为2的下一个幂 &#125; if (s) &#123; // 若无法被完全分解，剩下一部分 idx++; // 记录新的下标 v[idx] = a * s; // 大小 w[idx] = b * s; // 价值 &#125; &#125; // 01背包模板 for (int i = 1; i &lt;= n; i++) &#123; for (int j = c; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 国祯长舒一口气，这次他又获得了胜利。评测点加载了几秒。国祯定住了，#10号点出现一个大大的WrongAnswerWrong AnswerWrongAnswer。国祯感觉堕入了万丈深渊，只见茂华狂笑了起来，带动全班其他同学的笑容，一班霎时被笑声吞没。国祯盯着评测信息，783ms783ms783ms的运行时间让他更为疑惑，莫非茂华手动写了一个错误答案？ 国祯尴尬的转向各位同学，其他同学瞬间停止了笑容。先前还在交头接耳的同学们如同机器一般齐刷刷的转向国祯，给人一种惊悚透骨的感觉。他们异口同声张开了嘴，在茂华扭曲的笑容下，说出了让国祯后悔了一辈子的话来： “三年OI一场空，不开long long见祖宗！” OVER\\mathcal {OVER} OVER 背包类动态规划 混合背包 混合背包，顾名思义。它混合了多种背包，实际应用中这一类问题比较有现实意义。主要思路是，将分属于各个类型背包的物品用几个条件判断语句写出来，然后分别套用各类背包的解决方案进行求解。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (A) &#123; // 01背包物品，写01背包模板 &#125; if (B) &#123; // 完全背包物品，写完全背包模板 &#125; if (C) &#123; // 其他…… &#125; &#125; return 0; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"}]},{"title":"国祯文集","slug":"gz-articles","date":"2023-10-26T09:29:45.000Z","updated":"2023-11-04T08:27:07.535Z","comments":true,"path":"2023/10/26/gz-articles/","link":"","permalink":"https://justpureh2o.github.io/2023/10/26/gz-articles/","excerpt":"","text":"曾茂华到底有多六 ——By 国祯 曾茂华是中国当代著名的科学家和教育家，他以“慈父”、“良师”、“学者”等称号闻名于世。 1：曾茂华的蠢行为 曾茂华的蠢行为: 他在大学期间参加了一个乐队，并担任主唱。然而，不幸的是，由于自己的疏忽，他犯下了一件愚蠢的事情——用刀砍掉了对方的手指头。这件事让他成了学校里的头号人物之一。从那以后，他再也不敢做任何愚蠢的事情了。这是因为他害怕自己会被开除出乐队或者成为众矢之的的对象。如果他继续做出这些错误的举动，那么他会失去自己的乐队成员资格，甚至还会遭到开除。所以，为了避免发生这样的悲剧，他必须要记住：永远不要犯错！ 2：为什么他会做出这种愚蠢的事情? 曾茂华的蠢行为发生在他身上，是因为他自己没有意识到他自己的愚蠢。他不知道怎么做才能让事情变得更好，他只想走捷径，而不是去努力做好事情。这种心态会导致他做出错误的决定，因为他会忽略一些重要的信息，或者选择性地记住某些信息。当我们看到一个人犯了下述三种类型的罪时，我们通常就能预测到这个人会再犯同样的问题：1. 根本不会思考问题2. 一味追求便利3. 盲目模仿别人 3: 该如何面对这个问题? 要想解决问题,首先要认识到自己的行为是愚蠢的。只有当你明白自己做了什么蠢事时,才能够改变你的行为来避免这种错误。其次，不要让别人知道你所犯下的错误。这并不是因为你不想坦白自己所犯错误,而是因为这样会给别人带来困扰。最后,如果你真的想要解决这个问题,可以尝试通过一些有趣的方式来实现它。例如,你可以去找一位专业人士帮助你分析一下这件事情,或者试着去找到一个愿意与你分享观点和建议的人。总之,如果你认为自己的行为很蠢,那么就要大胆地承认出来。只有敢于直面自己的无知,才能真正地改善自己的生活。 曾茂华先生不仅对科学领域做出了巨大贡献，而且为国家培养出一批优秀的人才。这些人中不乏有牛顿这样伟大的人物，也有王选这样杰出的人物。","categories":[],"tags":[{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"CSP-J 2023 游记","slug":"journey-to-the-cspj2023","date":"2023-10-24T08:21:36.000Z","updated":"2023-11-05T00:22:51.337Z","comments":true,"path":"2023/10/24/journey-to-the-cspj2023/","link":"","permalink":"https://justpureh2o.github.io/2023/10/24/journey-to-the-cspj2023/","excerpt":"","text":"又名：《第一次考就被小学生薄纱的一集》 本次考场：绵阳东辰国际学校 第一节 赛前准备 插一句：CSP-J 2023没有设置赛前试机环节（包括CSP-S，成都绵阳都这样），个人推测可能是由于开放自选Windows和Linux系统带来的结果。如果你听见诸如：不要操作电脑，违者将作作弊处理 的话时，请将你按捺不住的双手安稳的放在双腿上，避免出现意料之外的事来。 然而赛前试机仍然是必要的一环（但是如果考场纪律有要求那就算了），因为这样可以让选手对机器有一个初步的了解。因为我本人习惯使用Win+E打开文件系统管理器，用Win+V记录剪切板数据，可是这些功能在考场电脑上都无法使用，进行赛前试机不仅可以避免因赛时临时发现无法使用某些功能而带来的苦恼~~（心态爆炸点+1）~~，而且还可以将IDE环境调整到个人喜欢的状态（例如缺省源代码，相当于每次新建代码不用重新打头文件）。选手可以不占用正式比赛时间完成一些个性化操作，方便赛时操作，其重要性不言而喻。 当然，开赛前乱猜试题PDF密码是极其无意义且几乎不可能成功的一件事，更不要使用暴力破解密码工具破解文件（相信守规矩的你也不会将这种工具带进考场里来），这么做不仅会被当做作弊者处理，而且造成的数据丢失也只能由你自己负责。 第二节 开赛之初 **考场下发的PDF文件带有密码保护，输入时请务必瞪大眼睛区分大小写字母O、o与数字0；小写字母l、大写字母I与数字1，并且将其中的特殊字符认真核对一遍。**本次考试，我有幸将密码中的数字0写成了小写字母o，于是浪费了宝贵的2分钟时间改正密码（真实情况是监考老师在黑板上书写密码时字迹不规范导致的混淆）。因此需要认真看好你的密码。 就我认为：在一开始就仔细写好文件重定向输入输出是极其重要的，因为随着考试时间的推进，你的思考重点将从细节性问题变为如何拿到更多的分数上~~（骗分）~~。你就会忽略重新写上两行重定向IO的代码，因而可能Au-&gt;Cu，光荣AFO。为了引起你的注意，使用极长的注释双斜线是可行的，我本人习惯打上断点。例如： 12//////////////////////////////////////////////// freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//////////////////////////////////////////////// freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 将比 12//freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 显眼得多——尤其是当你喜欢为每行代码写上包含心血的易懂注释时。事后你可以通过长按Ctrl+逗号（Dev-C++）的方式快速且安全的删除这些斜线。 不仅如此，看好输入输出文件名也是一个非常重要的细节，建议直接复制粘贴。对于标准样例，直接选中PDF文字再复制一般都不是一个明智的做法，手动输入也是可行的，但是对拍有时会比较繁琐（例如普及组T3的样例）。这边传授一个方便的做法：选中代码左侧序号，在WPS中直接右键菜单点击消除文字即可（本次考试我就是使用的这个方便技巧快捷复制样例数据）。最好找张纸记下来，后面会讲到原因。 顺利解锁了PDF文件，你要做的第一件事就是将四道题全部读熟。对整场比赛的题目有大致的规划，有可能你先前做题时做过与T4极其相似的题目，那么放弃显然是一个很不划算的决策。将题目读熟，大概判断一下算法实现，评估自己哪些题能做好，哪些题要放一放/完全放弃。知己知彼方能百战百胜。 赛初的状态基本上决定了你整场比赛的表现，因此在赛初就做好一切细节方面的完全准备，对你的信心增长是非常重要的！ 第三节 赛中时期 那么你现在拿到了第一题（信心题）。一般来说，CSP的复赛，算法很少裸露地出现在题目之中，前两题近似看作数学题。保证你的数学思维在线，因为第一题的思路可能千奇百怪，如果你一段时间没有思路（对于第一题大概是5~15分钟），可以考虑先做其他题目。刷新一下思维定势，有可能T1的灵感就乍现于其他题目之中。 在符合时间规划的前提下尽可能多去造hack数据，写出一段代码（尤其是T3放大模拟时）后，千万保证没有任何逻辑问题。当然，不是所有人都能只看代码就能检查的出其中的逻辑漏洞。因此你需要多造hack数据。hack数据多数情况下包括这几个要素：方程的特殊解、极端值/边界值、大数据（int越界）。在规划好的时间内想尽办法为你的代码多挑几根刺出来，你的代码才能更加趋近于满分解。 **千万不要看你旁边的人！！！**除非S组巨佬闯进了J组蒟蒻区，否则千万不要在比赛中途去看任何人的任何行为。一方面，你的行为可能被视作交谈作弊~~（喜提CCF全国通报、禁赛3年大礼包）~~；另一方面，如果你抱着嘲笑别人的心态去观察别人，那么你的脸很可能就会被你自己打烂。我在考试时因为瞧不起隔壁的一位小学生，当他开始疯狂敲代码时，我自己的心态就爆炸了——把所有人，不分男女、年龄高低，都当作你的敌人，轻视则死。同时这也给你带来一部分紧张感，会使你的发挥更佳。 给自己适当的放松与勉励，要相信，上天不是无故给你这个周末不用冒着风雨大太阳上补习班的珍贵机会（对于高中生，则是周六不用坐在教室里上正课的机会）。当你完全确认你的代码已经完美无瑕时，告诉自己：*同学们都还在悲催的上着课，我却在外边快乐的敲着代码。*如此一来可以起到调整心态的作用。 别激动到顺手关了PDF文件。如果你还记得或者是在草稿纸上写了密码，那无所谓；但是如果你没写，你的处境就非常尴尬，这时你可以举手找老师再要，但这绝对对你的心态是一个不小的打击。 第四节 赛末时期 经历三个半小时的不懈奋斗，比赛终于迎来最后的半小时。**无论你的完成情况如何，一定要用这最后的时间好好检查一下你的代码。**瞄一眼你是否有与下面类似的代码： 12freopen(&quot;uqe2.in&quot;, &quot;r&quot;, stdin); // 危freopen(&quot;uqe2.out&quot;, &quot;w&quot;, stdout); // 爆零警告 这段代码的主人是个懒人无疑了，如果你把CCF提供的附加样例复制了出来。切记最后把文件名里的序号删除，否则你就可以AFO了。 或者以下的代码： 1234#include &lt;Windows.h&gt;//其他的代码if (system(&quot;fc uqe.out uqe.ans&quot;)) cout&lt;&lt;&quot;WA&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;AC&quot;&lt;&lt;endl; 这位同学也是个Windows爱好者受害者无疑了，CCF明文规定了测试用系统为NOI Linux。因此不存在Windows.h这个头文件，如果你忘记删除了，那一定是个大大滴CE。正式比赛时，用bits/stdc++.h万能头即可(Windows和Linux通用）。我有一个考S组的朋友，因为忘记删除这个对拍头文件而喜提一个0分，直接亏大发。 不要忘记将你的重定向取消注释。你连读入输出都没有了，属实是可以AFO了。最后三分钟，请将你的蹄子挪开键盘鼠标。否则可能会越改越慌，不妨好好回想一下这周老师留了什么作业，你缺了哪些课需要去补，总之不要再动你的鼠标键盘了！如果实在是不放心编译问题，按一下F11，通过即可。保证你的工作目录下只留.cpp文件，所以将你复制的样例文件和编译的exe文件全部删除。 第五节 考试结束 **请你千万保持冷静，不要习惯性地把机器关机了。**CCF明文规定：*由关机造成的数据损失，责任由考生自负。*只需要把你的IDE关闭就好。 回家后，把周一要交的作业补好。别再谈考试的事情了，让你自己有个好心情。毕竟不管你的表现怎么样，它都过去了不是吗？","categories":[],"tags":[{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}],"categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}