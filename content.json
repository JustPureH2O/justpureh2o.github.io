{"meta":{"title":"JustPureH2O的博客","subtitle":"深水摸大鱼","description":"JustPureH2O的小窝","author":"JustPureH2O","url":"https://justpureh2o.github.io","root":"/"},"pages":[{"title":"","date":"2024-01-06T08:32:47.655Z","updated":"2024-01-06T08:32:47.655Z","comments":true,"path":"404.html","permalink":"https://justpureh2o.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 回到主页"},{"title":"","date":"2023-10-26T08:03:52.000Z","updated":"2023-10-26T08:55:42.018Z","comments":true,"path":"about/index.html","permalink":"https://justpureh2o.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-11-04T03:04:22.866Z","updated":"2023-10-26T08:58:13.786Z","comments":true,"path":"categories/index.html","permalink":"https://justpureh2o.github.io/categories/index.html","excerpt":"","text":""},{"title":"DC Doujin 同人创作","date":"2023-11-04T08:33:40.000Z","updated":"2023-12-03T05:33:52.933Z","comments":true,"path":"dcdoujin/index.html","permalink":"https://justpureh2o.github.io/dcdoujin/index.html","excerpt":"","text":"DC Doujin 简介 DC Doujin 同人创作（以下简称DCD），由JustPureH2O于2023年11月5日创建。主要发布一些幽默视频，以及对应的幕后纪实。旨在用最真实最还原的镜头记录学校生活的点点滴滴。目前该频道的拍摄、剪辑、发布均由JustPureH2O一人承担，主要演员有木稿比你铁、狂三唯吾所爱 新闻 DC Doujin 2023 EP1 先行预告 DC Doujin 2023 EP1 一触即发 正式发布 演员 1. 木稿比你铁 DC Doujin 2023 EP1 拍摄前 2. 狂三唯吾所爱 （左侧）DC Doujin 2023 EP1 拍摄时"},{"title":"友情链接","date":"2023-11-04T03:04:22.867Z","updated":"2023-10-26T09:06:37.321Z","comments":true,"path":"friends/index.html","permalink":"https://justpureh2o.github.io/friends/index.html","excerpt":"","text":""},{"title":"高2023级一班热梗总结","date":"2023-11-04T08:33:30.000Z","updated":"2024-01-07T03:51:18.574Z","comments":true,"path":"memes/index.html","permalink":"https://justpureh2o.github.io/memes/index.html","excerpt":"","text":"2023.9 1. 吃饱啦 九月初的某节语文课，当语文老师问及苏轼的个人形象时，国祯和小又肥同时说出了“优雅”二字，国祯更是以一个屁总结了自己的观点。此后不久，国祯和冰正在激烈地讨论老八秘制小汉堡的事情，正当所有人因为思考语文老师提出的问题而陷入短暂沉寂时，冰向后一靠，把手垫在脑后，说了一句：“吃饱啦！”。便如此得名。 2. 电饭煲 国祯表示历史老师长得很像电饭煲，于是得名 3. 干饭 9月4日，一班真正意义上进行了一次以教室为起点的干饭行动，基本上一分钟内能够到达食堂。 4. Global Reading 张伟水课的新型套路——不讲正课天天喊我们拿出Global Reading来看，久而久之成为英语课和扣分的代名词。 5. 手套月饼 9月28日周四晚，东辰组织制作月饼，有人在月饼里放狠料咖啡粉、硬币、长尾夹（后被取出）。事后国祯将此事传开，被茂华得知，被张伟处分。 6. 巨人熊猫，孔子牙膏（富兰克林，酱香瑞幸） 张伟最爱罚背的几篇Global Reading上的文章，国庆放假前被总结为这句口头禅 2023.10 7. 奖励 张伟扣分前的口头禅，后演变为罚背的代名词"},{"title":"机房管理助手 v9.x已成功破解","date":"2023-12-24T00:45:33.000Z","updated":"2024-01-06T06:51:10.844Z","comments":true,"path":"misc/index.html","permalink":"https://justpureh2o.github.io/misc/index.html","excerpt":"","text":"任务管理器已解禁，您也可以自由使用注册表和组策略进行其他操作"},{"title":"所有标签","date":"2023-10-26T08:56:08.000Z","updated":"2023-10-26T08:57:03.066Z","comments":true,"path":"tags/index.html","permalink":"https://justpureh2o.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2023年度总结——机房管理软件的破解经验","slug":"new-year-crack","date":"2023-12-31T12:22:54.000Z","updated":"2024-01-07T01:34:10.794Z","comments":true,"path":"2023/12/31/new-year-crack/","link":"","permalink":"https://justpureh2o.github.io/2023/12/31/new-year-crack/","excerpt":"","text":"文中提到的核心程序代码及食用方法在文章末尾处，或者访问我的云剪贴板来复制代码 极域——世界上最弱小最单纯的机房软件 注意，极域由C/C++语言开发。对于极域的反编译工作可以基本认定为徒劳且耗费大量时间的。 开始的开始，我的脱控方式还仅限于最原始的taskkill和ntsd。这种做法不仅有时会失效，而且一旦老师发现你的机子的监控屏幕是纯黑一片、且无法控制，他就会气急败坏地冲向你对你进行一顿输出，结果自然是被班主任教训一顿、这学期的信息课停上。 令人欣慰的是：这种低级脱控方式已经在学子之间渐渐隐没不见，取而代之的是层出不穷的脱控软件，例如JYTrainer、还有本人开发的ClassX（doge）等等…… 因为本人不会那些所谓的网络IP、频道更改之类的高科技东西，另一方面实现如上的功能多半需要辅助程序（容易被反脱软件检测到进程名）。本着精简实现、不易查封的原则，我从非exe层面出发，编写了一套脱控程序供大家伙们免费使用，毕竟人生苦短，及时行乐嘛（doge）。 板块一 TD到底是啥的缩写？ 你知道明明U盘里装着几个G的学习资料却无法在计算机课上给周边的同学炫耀是怎么样一种感觉吗？你知道明明想要打开小破站观看最爱的coser投稿的新擦边视频却被提示“该网站已被禁止”是什么样的感觉吗？ 出于以上两种痛苦的经历，我立志要写出能够禁止极域牛马功能的脚本。就先从U盘解禁和网络解禁两个方面入手！ Windows服务概述：打开任务管理器，选项卡里不仅有经典的“进程”选项、也有装机大佬们引以为傲的“性能”选项，可是我们今天的主角：“服务”选项却几乎无人问津。 类似于cmd的打开方式，服务管理器则需要在Win+R后输入services.msc来使用；你也可以通过任务管理器“服务”选项卡进入。那么什么是服务呢？ Windows服务是指系统自动完成的，不需要和用户交互的过程，可长时间运行的可执行应用程序。这些服务可以在计算机启动时自动启动，可以暂停和重新启动而且不显示任何用户界面。一个词概括就是：“幕后黑手”。开头立的flag就需要通过这种方式巧妙解决。 定位到极域安装目录：会发现下面有好多TD打头的文件，而当你在服务里面搜索时，你会发现一个惊人的巧合：TDNetFilter和TDFileFilter早已在你的机器上悄然运行了很久。看到它的名字，容易知道前者禁掉了你的网络、后者ban掉了你的U盘。如何终止服务呢？这也非常的简单： 在Windows系统中，与服务有关的命令是sc。要想停止某个服务，只需安装如下模式输入指令：sc stop [NAME]（NAME是服务名称）。于是我在ClassX的开头加入了如下的指令： 12sc stop tdnetfiltersc stop tdfilefilter 这样就结束了吗？然而并没有…… 板块二 可疑的程序 上一节里遗留了一个小问题：停止了服务后他就真的解禁了吗？事实并非如此：没过几秒，你的网络又会恢复到先前的状态、U盘再次被封杀。一切的一切都是因为两个不起眼的可疑程序…… ProcHelper64.exe和MasterHelper.exe——《我们俩》 有人问我当时是怎么发现的。首先需要知道，每个版本的Windows系统几乎都有一套特别的图标主题（图标存放在Shell32.dll中），现如今大部分机房电脑使用的是Win10系统，然而上述两个进程使用的是WinXP风格的图标，直接一眼丁真掏出taskkill秒了。真是实力坑队友。 因此ClassX里面还有这一段代码： 12345:ataskkill /f /t /im ProcHelper64.exetaskkill /f /t /im MasterHelper.exegoto a :a定义了一个函数a，中间是函数体，最后一行的goto a则是调用这个函数，注意goto a写在了a函数内部，起到了while (true) &#123;...&#125;的死循环作用。你也可以在空行出添加一段TIMEOUT /T 1，即延时一秒，因为这两个程序的复活时间大概在1秒左右（终止后一秒就会重启）。 板块三 拒绝访问什么鬼？ 第一种情况：钩子程序 如果你是Win7及以下的系统，且直接使用任务管理器结束进程，那么很有可能会出现像标题这样的提示。这是因为极域启动了一个系统钩子（四川人莫笑，Hook翻译过来的确是钩子的意思）。 Windows钩子概述：类似于游戏（以及Scratch）的消息机制，Windows中存在一种事件系统，Win+R弹出运行、输入eventvwr.exe/eventvwr.msc打开事件管理器，你会看到本机所有事件的发生时间及概况。把Windows系统的事件系统比作一条河流，最上游是系统，负责抛出事件，事件信息顺流而下；把应用程序比作渔夫，它们在河岸两侧用网捞特定类型的事件，大多数情况下自行处理后再放回到河中。 对于极域来说，它在一个名叫NtTerminateProcess的系统函数上下钩，检测这个函数的传入信息，即终止对象的进程名，是否是StudentMain.exe（极域主程序），若是，就返回false，也就是失败。因而导致开头所说拒绝访问的情况，而把钩子钩在此处的，就是我们的TD圈大佬LibTDProcHook.dll。因为本人使用Win10系统，这个钩子对于Win7以后的系统都会失效，因此Win8/10/11用户可以直接用任务管理器。对于Win7系统用户，在这里使用WinAPI终止这个TD模块。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;processthreadsapi.h&gt;using namespace std;DWORD GetPID(const char* proc) &#123; PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(snapshot, &amp;entry) == TRUE) &#123; while (Process32Next(snapshot, &amp;entry) == TRUE) &#123; if (stricmp(entry.szExeFile, proc) == 0) &#123; HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, entry.th32ProcessID); DWORD pid = GetProcessId(hProc); CloseHandle(hProc); return pid; &#125; &#125; &#125;&#125;int main() &#123; HMODULE hook = GetModuleHandle(&quot;LibTDProcHook64.dll&quot;); FreeModule(hook); HANDLE handle = OpenProcess(PROCESS_TERMINATE, FALSE, GetPID(&quot;StudentMain.exe&quot;)); TerminateProcess(handle, 0); return 0;&#125; 第二种情况：时代变了 自从学校机房的极域从2014版更新到了2020版，上述朴素解决方案已经不见效了。我也不知道从哪一年的版本开始，它给自己的服务加了一层防护，普通地运行bat脚本还木有用。但是它解决起来也简单，右键文件“以管理员模式运行”即可。 除此之外，你还可以在脚本开头加入： 1234567891011&gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit) 来实现UAC自动提权管理员！ 板块四 挂起进程 有一天我的同学给我推荐了这个方法，说是用一个命令行程序Suspend来命令层面挂起极域进程实现随意脱控，亲测有效。如果使用性能监视器也可以达到相同效果。 挂起为何物？ 大家可能有过这样的经历：当你用WPS做PPT或者正在用WPS演示PPT时，有时它会莫名其妙地卡掉，尤其是你画了太多墨迹注释时，看着永不停歇转动的“繁忙”鼠标图标，你也许会耐不住性子直接任务管理器结束进程，并发誓要下载一个破解版的微软Office全家桶来用。像这样，程序的卡死就是挂起的一个形式，当然，当CPU面临有限的内存分配问题时，它会优先分配运存给那些需要内存的重要程序而把不那么重要的进程挂起，表现为对用户操作无响应等。 那么你可能已经猜到了这一方法的逻辑了：我们挂起极域主进程。这样当教师端发送指令（黑屏安静、全屏广播等）时，你这边的极域接收端（学生端）就无法对指令作出响应，自然也就不会被控制。桌面监控同理，也会被影响，不同的是，教师端的监控小窗只会定格在你挂起极域前传输过来的最后一帧画面，总之瞒天过海是基本上没问题的了…… 根据上述原理，我们有两种方式来挂起一个进程（其实本来还有Win32API这种方法，留给读者自行研究）： 第一种 性能监视器 你可以打开任务管理器，在“性能”一栏的左下角可以看到“性能监视器”选项（Win10），对于Win11用户，则需点击“性能”栏右上角三个点，然后选中“性能监视器”；也可以Win+R输入perfmon.exe /res直接打开（万能）。还有几种方法见百度百科。 在性能监视器中，我们在最上面“进程”列表中找到StudentMain.exe（一般来说有两个同样的进程），接着挨个右键点击“暂停进程（S）”即可。 但是这样的话，你在教师端那边的小窗口上就会显示出一个性能监视器的窗口，感觉不太完美，怎么能优化一下呢？ 第二种 Suspend命令行 这里可以下载 下载后的压缩文件里面有一个.cmd文件，用记事本打开： 12345chcp 65001@set suspend_targets=osu!.exe DDLC.exe@suspend.exe %suspend_targets%pause@suspend.exe -r %suspend_targets% 其实我们真正需要修改的内容是第二行：它使用bat批处理脚本设置变量suspend_targets，传入需要挂起进程的进程名称话说DDLC是真的生草……。这里我们修改参数值为StudentMain.exe： 12345chcp 65001@set suspend_targets=StudentMain.exe@suspend.exe %suspend_targets%pause@suspend.exe -r %suspend_targets% pause之后的那一行是解除挂起的代码，因为bat执行到pause语句后会等待用户输入任意字符后才继续进行，因此如果遇到紧急情况需要解除挂起，只需在命令行窗口点击任意键即可。 需要注意的是，一定要把下载好的压缩包里面的所有文件放到同一个目录下，否则缺失任何文件这个工具都是无法正常运行的。 板块五 留给2024的一个小问题 那天我在思考如何一劳永逸的结束极域进程，我打开了服务列表，在里面看到两个纯大写拼成的服务名GATESRV和STUDSRV。可惜的是那天放学，我没能来得及探究清楚这两个服务与极域的关系，目前已知的信息就是它们绝对是极域自己启动的两个服务。 这个问题就留给2024的我解决吧 // TODO 红蜘蛛软件——可曾听闻我绿蜘蛛脚本的厉害？ 在本人印象中，红蜘蛛似乎就仅仅只是一个吉祥物，只有在开机后那么几秒，它拖着上世纪复古风的“高清”启动界面在我的眼前一闪而过，然后静静地躲在任务栏的小图标里，践行它大隐隐于市的人生信条…… 说实话要不是同学提醒我还真忘了机房里还有这位叫红蜘蛛的朋友，于是我着手开始破解它。红蜘蛛：我吃柠檬 1. 这玩意怎么跟2345一个德行？ 知道2345全家桶的同学们肯定对它恨之入骨，尤其是那些下载了2345的同学们。2345号称天朝第一大流氓软件，在无数人的电脑中如同鬼魂一般挥之不去。捆绑安装、弹窗广告、强制修改系统文件、浏览器劫持……无奇不有，关键是它的公司甚至推出极其出生的“推广包”机制来诱惑不良商户分发2345毒瘤软件。这篇文章介绍了清除2345的一种方案。 回到本节主题上来，为什么会取这样一种怨气十足的标题呢？是因为它和2345伪装成系统文件类似，红蜘蛛属于是反向利用了系统文件来给自己加上一层保护网。 打开任务管理器，除了霸占后台程序第一行的红蜘蛛本体，下面还有两个附属程序，名叫“3000soft通用组件”，如果直接终止进程，它很快会再次冒出来。将它们展开后发现叫做checkrs.exe和rscheck.exe的程序。那么运用上边经常用到的服务搜查法，我们发现了两个命名规则极其相似的服务：appcheck2和checkapp2。 然而我事后才发现红蜘蛛官网早已自报家门了……血亏！ 常规思想：我们使用sc命令结束这两个服务，然而…… // TODO 显示无法停止，那怎么办呢？ 考虑到这两个进程是红蜘蛛死掉后无限重启的命根，并且这两个进程也跟红蜘蛛主程序一样杀了就会重启……很明显，根本原因就是那两个服务，但是sc命令不管用了，咋办呢？（抠头） 这时我们就需要绕道而行，既然命令不行，我们转战注册表！打开注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services文件夹，它有很多个子文件夹，在下面定位到appcheck2和checkapp2，它的文件结构类似于这样（这里用别的服务替代一下）： （注意，这个并不是红蜘蛛的服务，是我临时找别的替代的，它们的文件名相同，只是数据不同而已） 容易发现：ImagePath项指向了服务的根文件地址，也就是俗称的万恶之源，既然每次终止组件后它会自动重启服务，那我们为何不破坏这个ImagePath，让它指向一个不存在的地址，这样它就启动不了任何东西了。在我的绿蜘蛛inf文件里如此写到： 123456789101112[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 然后你就可以用任务管理器终止两个通用组件，紧接着就可以终止红蜘蛛了！ 由于本人目前对红蜘蛛知之甚少，可以看这篇文章了解更多！ 学生机房管理助手——闻着臭吃着香 1. 不用逆向，能得到什么结论？ 其实一开始我以为它和极域一样是基于C++/C开发的因此无法反编译，直到回家之后我自己下载了一个。杀毒软件报毒删除了set.exe，打开main.exe主入口程序时它突然弹出了一条C#式的通知框提示set.exe未找到。于是果断打开dnSpy开启后面的破解，反编译破解的内容将在后面涉及到。 首先看到他的文件目录↓ 其中zy文件夹中存放的是各种浏览器的exe可执行文件，猜测是覆盖现有的高版本浏览器，以便它操作注册表禁止各种功能。 有一定经验的同学想必会一眼看到可疑的yl.reg注册表文件，但是先别急着合并注册表。首先，你的机器可能已经被禁用了注册表和任务管理器；第二，这个文件里也不是你心心念念的破解注册表（虽然后面我们会利用它破解机房管理助手）。对于未知的事物，最好还是保持谨慎勿近的态度为好…… 除此之外，一个名叫jfglzs.exe的程序吸引了我，根据我多年混迹于首拼梗圈的我一秒钟就反应过来，知道它就是“机房管理助手”的首拼。我们之后的破解也围绕着这个东西进行。 第一问 任务管理器、注册表、组策略咋解 本人Win11系统，正常情况下任务栏设置上端会有一个任务管理器选项。 如果你稍微懂一点高级知识，你也许会使用Win+R，并输入taskmgr试图使用任务管理器。然而这不可能奏效，因为你会接到一则提示： 输入regedit（注册表）和gpedit.msc（组策略管理器）也是一样的道理。很少很少的高材生会使用mmc试图加载组策略，但是这样也不可能奏效。搜索资料发现，修改注册表的某些键值可以实现禁用组策略、注册表、任务管理器的功能。深度分析yl.reg时就会发现这些东西： 第一行翻译过来就是：“禁用任务管理器”，它的值被设置成了1，也就是true。这一块还有禁止更改密码、禁止切换用户的设置等等。对于组策略，它的两个值则是存放在注册表：HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC中的RestrictToPermittedSnapins；和它的子目录HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;中的Restrict_Run。如果不出意外，它们的值都是非零的，意味着组策略被禁用了。要想破解，我们就需要用一个不直接调用注册表的方式来添加/更改注册表值，这也就是下面将要提出的inf安装文件法。 INF安装文件的机制 提起绿色版软件，大家应该不会陌生，它省去了冗杂的dll等库文件，仅仅一个exe文件驱动整个程序。在绿色版软件安装时，有时就是用的inf文件安装法。一个可运行的inf文件包含几个项： 123[Version]Signature=&quot;$CHICAGO$&quot;Provider=somebody Version段包含inf文件的基本信息，其中Signature指定了文件的适用系统，常见的值有MS、WindowsNT等，这里我们使用CHICAGO获得最广泛的支持（注意美元符号和引号的书写）。 123[DefaultInstall]DelReg=DeleteAddReg=Add 这一段声明了安装时所需的函数，DelReg负责删除注册表，AddReg负责创建/修改注册表。基本语法如下： DelReg：[ROOT] [PATH] [NAME]，ROOT就是注册表中HKEY开头的那些，你可以写全称，也可以写缩写形式（HK+后两个单词的首字母，HKEY_LOCAL_MACHINE=HKLM）；PATH是包含指定键值的文件夹路径；NAME就是键值的名字。 AddReg：[ROOT] [PATH] [NAME] [TYPE] [VALUE]，TYPE指定了注册表值的类型（0相当于缺省，默认字符串；1为DWORD值，设置十六进制值时只需两个数字一组，中间逗号分隔开，一定保证输入的十六进制为8位，一定记得写前导0！）；VALUE即为键值，值为字符串时需要在前后打上半角双引号。 等号右侧的值相当于C++中的typedef，用来重命名函数，因此，在后续的安装代码中，我们的字段标识符都要与等号右侧的值相符才可，在我们的inf中，它表现为这样（inf文件的注释用分号表示）： 12345678910111213[Delete]HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableCMD&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot; 在记事本里编辑即可，记得保存为.inf文件，而后右键“安装”，或者在cmd里运行：InfDefaultInstall + inf文件地址（前提是你的cmd没被禁止）。 除此之外，我们发现了一些好玩的东西：yl.reg的最后几十行，将常用浏览器的起始界面通过注册表的方式修改成了它的官网，学有余力的娃们可以通过刚才介绍的AddReg函数把它的值改成你想要的值，在这里我换成了我精心制作的嘲讽页面： 1234567891011[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; yl.reg——队友坑害全队的典型例子。 当一切完成之后，你就可以自由使用任务管理器了，被锁定了cmd的同学们也可以尽情使用taskkill了！诶等等，事情好像有点不对劲…… 第二问 我的taskkill去哪了 可是我的taskkill还好好地躺在System32文件夹里啊 机房管理助手一启动，所有使用taskkill的脚本/程序都会失效，属于是老阴B了。如果不逆向破解，我还真不清楚这是怎么做到的。总之你可以在网站上下载一个taskkill（对上网下载一个下来），或者顶住巨大的学习难度学习WinAPI（TerminateProcess函数）写出一个拔山盖世的C++程序来。这一节就不多赘述其他内容了…… 第三问 yl.reg到底写了啥 其实最扎眼的就是它里面写的宣（补）战（贴）名单各种脱控工具箱，说实话那些工具箱软件我基本上一个都没见过…… 这些注册表项有一个很普遍的特征，它们无一例外指向了注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Hashes下很多以GUID形式命名的文件夹，那么这些文件夹具体起什么作用呢？ 这其实是组策略管理器的黑名单，具体见此，没错，组策略可以限制指定软件的运行。但是很遗憾，这些配置全部存放在上述的注册表里面。你可以把注册表看做系统的配置文件，操作系统几乎所有配置信息、甚至包括大部分软件程序的配置都存放在注册表中。这么看来除了BIOS没别的安全地方了 如果想要禁用这些项，并不需要挨个将每个文件删去，而是看到他的其中一个父文件夹codeidentifiers。它里面有一个二进制值authenticodeenabled，它指定组策略黑名单的ID标识符，也就是codeidentifier文件夹下以数字命名的文件夹，只有当子文件夹的名称与ID标识符相同时才会启用该文件夹下的配置。因此我们釜底抽薪，直接更改authenticodeenabled的值： 12[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14 假如我掏出逆向工具，阁下又该如何应对？ 正如开头所说，学生机房管理助手由C#开发，因此可以用dnSpy反编译它的可执行文件，得到源码。那么我们就开始吧！ 第一框 密码是啥 将set.exe拖入dnSpy中反编译，我们会得到一大坨屎山代码，它看起来是这样的： （节选） 它充斥着大量的case判断，以及意义不明的变量名和数学操作。我自然是看得晕头转向，但是想到自己的主业——高贵的OIer，怎么能被这么小的挫折打倒呢？借助部分大佬的传世思路，我们于是发现这长达2600+行的屎山函数可以被写成这样的形式（完全等价）： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Security.Cryptography;using System.Text;using System.IO;public class Program&#123; public static void Main() &#123; // 更改这里的内容 string string_3 = &quot;12345678&quot;; // Class6.smethod_0() string value = &quot;C:\\\\WINDOWS&quot;; string s = value.Substring(0, 8); string s2 = value.Substring(1, 8); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); descryptoServiceProvider.Key = Encoding.UTF8.GetBytes(s); descryptoServiceProvider.IV = Encoding.UTF8.GetBytes(s2); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write); StreamWriter streamWriter = new StreamWriter(cryptoStream); streamWriter.Write(string_3); streamWriter.Flush(); cryptoStream.FlushFinalBlock(); memoryStream.Flush(); string string_4 = Convert.ToBase64String(memoryStream.GetBuffer(), 0, checked((int)memoryStream.Length)); // Class6.smethod_3() StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; string_4.Length; i++) stringBuilder.Append((char)(string_4[i] - 10)); string_3 = stringBuilder.ToString(); // Class6.smethod_2() MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider(); byte[] array2 = md5CryptoServiceProvider.ComputeHash(Encoding.Default.GetBytes(string_3)); stringBuilder.Clear(); for (int i = 0; i &lt; array2.Length; i++) stringBuilder.Append(array2[i].ToString(&quot;x2&quot;)); string str = stringBuilder.ToString().Substring(10); Console.WriteLine(str); &#125;&#125; 现在有点明白程序员的痛了 同时，机房管理助手的密码MD5文件存放在注册表HKEY_CURRENT_USER\\Software下的字符串值n里面。更改即生效！ 代码环节 ClassX 使用方法：另存为.bat文件直接运行 12345678910111213141516171819202122232425262728293031@echo off &gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit)sc stop tdnetfiltersc delete tdnetfiltersc stop tdfilefiltersc delete tdfilefiltersc stop GATESRVsc delete GATESRVsc stop STUDSRVsc delete STUDSRVregedit /c /s usb_reg.regecho Unhook through Regedit:ataskkill /f /t /im MasterHelper.exetaskkill /f /t /im ProcHelper64.exeTIMEOUT /T 1goto a 绿蜘蛛 使用方法：另存为.inf文件→右键安装；任务管理器先结束进程3000soft通用组件，再结束红蜘蛛软件 1234567891011[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 学生机房管理助手通用破解 使用方法：另存为.inf文件→右键安装 123456789101112131415161718192021222324252627282930313233343536373839404142[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=Add[Delete] ; 大坏蛋，放开那个组策略管理器！HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete] ; 注册表和任务管理器我来接手，你可以卷铺盖走人了！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot; HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableCMD&quot;[Delete] ; 我就要切换用户！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot;[Delete] ; 如果把我桌面搞乱了张伟会清理掉我的文件滴HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer&quot;,&quot;DesktopProcess&quot;[Add] ; 加点料才香~HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoConfigPage&quot;,1,00,00,00,01HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoDevMgrPage&quot;,1,00,00,00,01[Add] ; 嘲讽一波这sb管理助手，关键你就算换成自己的网页学校的破网也加载不出来（笑）HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;; TODO 再给你多附赠几个浏览器hhHKCU,&quot;Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Storage\\microsoft.microsoftedgedevtoolsclient_8wekyb3d8bbwe\\MicrosoftEdgeMain&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; ; Edge 浏览器主页","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"DC Doujin 2023 EP1 一触即发正式发布","slug":"dcdep1-release","date":"2023-12-03T05:02:42.000Z","updated":"2023-12-03T05:32:34.969Z","comments":true,"path":"2023/12/03/dcdep1-release/","link":"","permalink":"https://justpureh2o.github.io/2023/12/03/dcdep1-release/","excerpt":"","text":"","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"信竞初等数论导论","slug":"number-theory-junior","date":"2023-11-26T01:37:52.000Z","updated":"2024-01-06T07:12:26.780Z","comments":true,"path":"2023/11/26/number-theory-junior/","link":"","permalink":"https://justpureh2o.github.io/2023/11/26/number-theory-junior/","excerpt":"","text":"引入 如果说数论是数学体系中专门用来研究数字性质的一个分支，那么初等数论则是对整数的性质进行系统性的探讨与研究。千万不要因为其中的“初等”二字小瞧这初等数论尽管名称和学习难度上都没有高等数论那么有逼格，就像初等数学之于高数，数论的所有内容均筑基于此。其中欧几里得证明的算数基本定理（一切合数都可被分解为有限个质数的乘积）在质数筛、GCD（以及LCA)计算、无理数证明等问题上均有用武之地。可以说高等数论奠基于初等数论。它同时也是初学者接触数论的必经之路。 Part1. 前置知识 Div1. 数论有关定理 算术基本定理：每一个合数都可以被分解为有限个质数的乘积。即对于任意合数nnn，都存在： n=p1c1p2c2p3c3...pkckn=p_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}n=p1c1​​p2c2​​p3c3​​...pkck​​，其中ppp为质数。 推论一：正整数nnn的正因数集合为： {n=p1b1p2b2p3b3...pibi∣1≤bi≤ci,1≤i≤k}\\{n=p_{1}^{b_1}p_{2}^{b_2}p_{3}^{b_3}...p_{i}^{b_i} \\mid 1 \\leq b_i \\leq c_i, 1 \\leq i \\leq k\\}{n=p1b1​​p2b2​​p3b3​​...pibi​​∣1≤bi​≤ci​,1≤i≤k} 推论二：正整数nnn的正因数个数为：τ(n)=(c1+1)⋅(c2+1)⋅(c3+1)...(ck+1)=∏i=1k(ci+1)\\tau (n)= (c_1+1) \\cdot(c_2+1) \\cdot (c_3+1) ... (c_k+1) =\\prod_{i=1}^{k}\\left( c_i+1\\right) \\\\τ(n)=(c1​+1)⋅(c2​+1)⋅(c3​+1)...(ck​+1)=∏i=1k​(ci​+1) 推论三：正整数nnn的所有正因数之和为 σ(n)=(p1+p12+...+p1c1+1)×(p2+p22+...+p2c2+1)×...×(pk+pk2+...+pkck+1)=∏i=1kpkck+1pk−1\\sigma(n)=(p_1+p_1^2+...+p_1^{c_1}+1)\\times (p_2+p_2^2+...+p_2^{c_2}+1)\\times...\\times (p_k+p_k^2+...+p_k^{c_k}+1)=\\prod_{i=1}^{k}\\frac{p_k^{c_k+1}}{p_k-1}σ(n)=(p1​+p12​+...+p1c1​​+1)×(p2​+p22​+...+p2c2​​+1)×...×(pk​+pk2​+...+pkck​​+1)=∏i=1k​pk​−1pkck​+1​​ 质数分布定理：区间[1,N][1,N][1,N]中，当N→∞N\\to \\inftyN→∞时，质数个数π(x)≈nln⁡n\\pi (x)\\approx \\frac{n}{\\ln n}π(x)≈lnnn​。 费马小定理： 若ppp是一个质数，则ap≡a mod pa^p\\equiv a\\bmod pap≡amodp（≡\\equiv≡为同余符号）。 欧拉定理（费马小定理扩展）： 若a⊥na\\perp na⊥n（aaa与nnn互质），则有aφ(n)≡1 mod na^{\\varphi{(n)}} \\equiv 1 \\bmod naφ(n)≡1modn，其中φ(n)\\varphi(n)φ(n)为欧拉函数。 Div2. 同余 同余，顾名思义，两个数分别除以一个正整数mmm后得到相同的余数。即a mod m=b mod ma\\bmod m=b\\bmod mamodm=bmodm。但是它的定义给出了这样一句话：“对于正整数aaa和bbb，若(a−b)∣m(a-b)\\mid m(a−b)∣m（a−ba-ba−b能被mmm整除），则称aaa和bbb对模mmm同余，记作a≡b(modm)a\\equiv b\\pmod ma≡b(modm)”。当然以上两种说法是等价的。 同余具有以下三种基本性质： 反身性：对于任何正整数aaa，a≡a(modm)a\\equiv a\\pmod ma≡a(modm) 对称性：即对于a≡b ( mod m)a\\equiv b\\;(\\bmod m)a≡b(modm)，有b≡a(modm)b\\equiv a\\pmod mb≡a(modm) 传递性：若a≡b(modm)a\\equiv b\\pmod ma≡b(modm)，且b≡c(modm)b\\equiv c\\pmod mb≡c(modm)，有a≡c(modm)a\\equiv c\\pmod ma≡c(modm) 当然，它可以延申到计算机的模运算（毕竟出现了 mod \\bmodmod）。模运算有三种基本运算： 加运算：(a+b)%m=(a%m+b%m)%m(a+b)\\% m=(a\\% m+b\\% m)\\% m(a+b)%m=(a%m+b%m)%m 减运算：(a−b)%m=(a%m−b%m)%m(a-b)\\%m=(a\\%m-b\\%m)\\%m(a−b)%m=(a%m−b%m)%m 乘运算：(a⋅b)%m=((a%m)∗(b%m))%m(a\\cdot b)\\%m=((a\\%m)*(b\\%m))\\%m(a⋅b)%m=((a%m)∗(b%m))%m 还有两个推论： 幂运算：ab%p=((a%p)b)%pa^b\\%p=((a\\%p)^b)\\%pab%p=((a%p)b)%p 求和运算：(∑x=1nx)%p=(∑x=1nx%p)%p(\\sum\\limits_{x=1}^{n}x)\\%p=(\\sum\\limits_{x=1}^{n}x\\%p)\\%p(x=1∑n​x)%p=(x=1∑n​x%p)%p 同余消去原则： 若同余号两端的项相等，且都与模nnn互质，则可以同时消去 举例：a⋅c≡b⋅c mod na\\cdot c\\equiv b\\cdot c \\bmod na⋅c≡b⋅cmodn，如果gcd(c,n)=1gcd(c,n)=1gcd(c,n)=1，则a⋅c≡b⋅c⇒a≡b mod na\\cdot c\\equiv b\\cdot c\\Rightarrow a\\equiv b \\bmod na⋅c≡b⋅c⇒a≡bmodn。 Part2. 质数 质数的判断：除了它自身PPP以及111以外，不存在其他正整数NNN使得N∣PN\\mid PN∣P。 Div1. 质数判断 试除法： 这是三种方法中，唯一一种能做到100%正确的质数判断方法。对于给定数nnn，遍历所有[2,n][2,\\sqrt n][2,n​]间的正整数mmm，若出现m∣nm\\mid nm∣n则证明它不是质数，因为质数只能被1以及它本身整除。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及、提高 试除法の大胜利！ 费马素性检验： 是上述费马小定理的实际运用，它与常规算法思想有所不同：它主张在[2,n−1][2,n-1][2,n−1]中随机选取一个数aaa。若出现与费马小定理不符的情况，那么nnn一定为合数；若每次均符合定理，称为 费马伪素数 ，因为它很大概率是一个质数。 1234567891011bool isPrime(int n) &#123; if (n &lt;= 2) return false; int k = 10; while (k--) &#123; srand(time(0)); int a = rand() % (n - 2) + 2; if (__gcd(a, n) != 1) return false; if (qpow(a, n - 1, n) != 1) return false; &#125; return true;&#125; 复杂度：O(klog⁡n)\\mathcal O(k\\log n)O(klogn)，其中kkk为随机数检验次数，log⁡n\\log nlogn是因为使用了快速幂算法。 适用范围：提高T2及以下（慎用） 为什么用该方法判断的质数 大概率 是个质数呢？不妨测试一下561（3）、1105（5）、1729（7）（括号内为它的最小因子），你会发现函数的返回值均为true，即都为质数。可见这个算法不是100%正确的，这些“漏网之鱼”被称为“Carmichael数”。它们极其罕见，一亿范围内仅255个。也因如此，你可以通过打表特判的方式抠掉这些特例（你保证记得住就行）。2016年中国物流工人余建春给出了一个Carmichael数的判断准则，这个标准目前在国际上得到了广泛认同。 对于优化，你可以在函数起始点加入类似于if (n % 2 == 0 || n % 3 == 0) return false;的特判，进一步降低复杂度。 Miller-Rabin算法： 该算法同样无法保证结果100%准确，慎用！ MB算法实质上是对费马素性检验算法的效率和准确度优化。算法流程如下： 将n−1n-1n−1分解为2s+d2^s+d2s+d的形式，其中ddd为奇数 从[2,n−2][2,n-2][2,n−2]中选取整数aaa，称为“基数” 计算ad mod na^d \\bmod nadmodn的值，若结果为111或n−1n-1n−1，则可能为质数，继续检验 若结果不等于111或n−1n-1n−1，计算a2d mod na^{2d} \\bmod na2dmodn、a4d mod na^{4d} \\bmod na4dmodn、a6d mod na^{6d} \\bmod na6dmodn……a2s−1d mod na^{2^{s-1}d} \\bmod na2s−1dmodn的值，若结果等于n−1n-1n−1，则可能为质数，继续检验 若都不等于111，则nnn一定是合数。称为强费马证据。 当然，它同样有特例，称为强伪质数，如2047（23）、3277（29）、4033（39）等（括号内为它的最小因子）。 Div2. 质数筛 常见的质数筛法有：试除法、埃氏筛、线性筛。 试除法：从质数定义出发，即存在一个正整数NNN，对于任意[2,N][2,\\sqrt N][2,N​]间的正整数MMM，总有N mod M≠0N\\bmod M \\neq 0NmodM​=0成立。代码实现只需枚举[2,N][2, \\sqrt N][2,N​]间所有正整数，并让NNN对其取余。若取模运算出现000则代表它不为质数，没有出现000则为质数。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(N)\\mathcal O( \\sqrt N )O(N​) 适用范围：普及T2及以下 这里所展示的试除法代码实际上经过一轮优化。若严格根据质数定义，第二行的循环上限应为n−1n-1n−1。考虑到如下性质：∀m∈[2,N]\\forall m\\in [2,\\sqrt N]∀m∈[2,N​]，若m∣Nm\\mid Nm∣N，则一定有Nm∣N\\frac{N}{m}\\mid NmN​∣N。因此可以将循环上限压缩至N\\sqrt NN​。 埃氏筛：全称叫埃拉托斯特尼筛法，老哥生活在2200年前的古希腊，不借助望远镜就计算出了地球的周长（与真实值偏差仅0.96%）、同时他也是第一位根据经纬线绘制出世界地图的人、也是最先提出将地球根据南北回归线分为“五带”的大人物。他提出的筛法核心思想如下： 第一步：列出从2开始的一列连续数字；第二步：选出第一个质数（本例中为2），将该质数标记，将数列中它的的所有倍数划去；第三步：若数列中的末项小于它前一项的平方，则质数已全部筛出；否则返回第二步。 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; &#125; for (int j = 2; i * j &lt;= n; j ++) vis[i * j] = true; &#125;&#125; 其中，prime数组存储质数，vis数组用于标记（即上文中“划去数字”），变量cnt则存储[2,N][2,N][2,N]中质数的个数。 复杂度：O(nln⁡n)\\mathcal O(n\\ln{n})O(nlnn) 适用范围：普及T2及以下 但是继续观察算法发现：我们其实无需将所有iii的倍数删去，只需删去前一步得出的质数的所有倍数即可。 这与前文介绍的埃氏法核心相符。因此将jjj循环迁移至条件判断中即可： 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) vis[j] = true; &#125; &#125;&#125; 优化复杂度：O(nlog⁡log⁡n)\\mathcal O(n\\log{\\log n})O(nloglogn) 适用范围：普及T3及以下 线性筛/欧拉筛：实质是埃氏筛的线性优化。因为在埃氏筛中，有些数字被重复筛了多次（例如30会被2、3、5筛到）。本着线性优化的原则，我们需要找到一个方法，使得每个合数仅被筛选一次。主要思想如下： 我们发现，线性筛和埃氏筛均使用了质数的nnn倍为合数的结论。我们只需要保证每一个数仅被它自身的最小质因数筛出即可。即对于数字mmm，m⋅pim\\cdot p_im⋅pi​是一个合数，且m⋅pim\\cdot p_im⋅pi​只会被pip_ipi​筛出。 123456789void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) &#123; vis[prime[j] * i] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及、提高 例题： P5736 【深基7.例2】质数筛 P5723 【深基4.例13】质数口袋 Part3. 因数 因数定义： 对于一个数nnn，若存在一个正整数mmm使得m∣nm\\mid nm∣n，则称mmm是nnn的因数。 Div1. 因数分解法 试除法：万能暴力解法。即遍历[2,n][2,\\sqrt n][2,n​]间的所有数mmm，若可以整除nnn，则mmm和nm\\frac{n}{m}mn​均为nnn的因数。特殊情况：n\\sqrt nn​为整数时，因数仅有n\\sqrt nn​本身，因此需特判。 123456789101112vector&lt;int&gt; get(int n) &#123; vector&lt;int&gt; ret; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret.push_back(i); ret.push_back(n / i); &#125; if (n % (i * i) == 0) ret.pop_back(); &#125; sort(ret.begin(), ret.end()); return ret;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及T1 Div2.最大公约数 辗转相除法： 又是我们大名鼎鼎的欧几里得老先生提出的一套公约数算法，整个算极其简洁：核心只有一行，即： 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数 可以写出： 123int gcd(int a, int b) &#123; return b ? gcd(a, a % b) : a; &#125; 但是为什么gcd(a,b)=gcd(a,a mod b)gcd(a,b)=gcd(a,a\\bmod b)gcd(a,b)=gcd(a,amodb)呢？我们可以通过以下方法证明： 假设如下关系：A=B⋅C+DA=B\\cdot C + DA=B⋅C+D。其中被除数AAA，除数BBB，商CCC，余数DDD。则A mod B=A mod C=DA\\bmod B=A\\bmod C=DAmodB=AmodC=D。 首先证明充分性：令A=a⋅kA=a\\cdot kA=a⋅k、B=b⋅kB=b\\cdot kB=b⋅k，即二者有相同因子kkk。 代入初始除法算式得：D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C)D=A-B\\cdot C\\rightarrow a\\cdot k-b\\cdot k\\cdot C\\rightarrow k(a-b\\cdot C)D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C) 接着由于加减乘法的封闭性，即一个整数进行加减乘运算得到的结果同样是一个整数。可以得出：D=k⋅N∣N∈N+D=k\\cdot N\\mid N\\in \\mathbb{N_+}D=k⋅N∣N∈N+​。即DDD（A mod BA\\bmod BAmodB）与AAA有共同因子。 接下来证必要性。令B=b⋅qB=b\\cdot qB=b⋅q、D=d⋅qD=d\\cdot qD=d⋅q Stein算法： 上一个方法的明显缺点在于，它处理大质数的效率并不好（但总体来说是很好的），因为它使用了取余运算，这会减慢一些速度。可以理解，生在2000多年前——一个没有电脑和OI的古希腊社会，这个算法已经足够兼顾常规效率和手推难度了。但是步入21世纪，加快的生活节奏毒瘤数据使得人们对更快算法的需求空前高涨。Stein算法便应运而生。 算法流程如下： 任意给定两个正整数，先判断它们是否都是偶数，若是，则用2约简，若不是，则执行第二步。 若两数是一奇一偶，则偶数除以2，直至两数都成为奇数。再以较大的数减较小的数，接着取所得的差与较小的数，若两数一奇一偶，仍然偶数除以2，直至两数都成为奇数。再次以大数减小数。不断重复这个操作，直到所得的减数和差相等为止。 两数相等时，第一步中约掉的若干个2与第二步中最终的等数的乘积就是所求的最大公约数。 123456789101112131415161718192021222324int gcd(int a, int b) &#123; int p = 0, t; if (!(1 &amp; a) &amp;&amp; !(1 &amp; b)) &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; p++; &#125; while (!(1 &amp; a)) a &gt;&gt;= 1; while (!(1 &amp; b)) b &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (a = ((a - b) &gt;&gt; 1)) &#123; while (!(1 &amp; a)) a &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; &#125; return b &lt;&lt; p;&#125; 这个算法的优点在于：它大大优化了大质数的运算。但可惜的是，它的代码量膨胀了8倍，因此不太建议赛时使用。毕竟C++都给你内置了__gcd()函数嘛，干嘛不偷个懒？ Div3. 最小公倍数 我们可以简单概括成一句话： 两个数的最小公倍数等于这两个数的乘积与这两个数最大公约数的商 即：lca(a,b)=a⋅bgcd(a,b)lca(a,b)=\\frac{a\\cdot b}{gcd(a,b)}lca(a,b)=gcd(a,b)a⋅b​ 凭啥呀？ 我们假设两个数AAA和BBB有最大公约数xxx，则A=a⋅xA=a\\cdot xA=a⋅x，且B=b⋅xB=b\\cdot xB=b⋅x。并且aaa和bbb一定互质（若不互质，AAA和BBB的最大公约数就不会是xxx，而是一个比xxx大的值）。 由乘法交换律，可知：A⋅B=B⋅A→A⋅b⋅x=B⋅a⋅xA\\cdot B = B\\cdot A\\rightarrow A\\cdot b \\cdot x=B\\cdot a\\cdot xA⋅B=B⋅A→A⋅b⋅x=B⋅a⋅x 消去xxx得：A⋅b=B⋅aA\\cdot b=B\\cdot aA⋅b=B⋅a。因为aaa、bbb互质，所以A⋅bA\\cdot bA⋅b或者B⋅aB\\cdot aB⋅a即为两个数的最小公倍数。得证。 例题： P1075 [NOIP2012 普及组] 质因数分解 P2424 约数和 （需要逆向思维） Part4. 欧拉函数相关 Div1. 欧拉函数推导 问：论牧师欧拉有多么的高产 答：平均每年800页数学论文你说高不高产嘛 欧拉函数，记作φ(n)\\varphi(n)φ(n)。表示[1,n)[1,n)[1,n)中与nnn互质的数的个数，即∀m∈[1,n)\\forall m\\in [1,n)∀m∈[1,n)，满足gcd(n,m)=1gcd(n,m)=1gcd(n,m)=1的mmm的总个数即为φ(n)\\varphi(n)φ(n)的值。举个例子，φ(3)=2\\varphi(3)=2φ(3)=2，因为在[1,3)[1,3)[1,3)中，111和222均与333互质。特殊地，φ(1)=1\\varphi(1)=1φ(1)=1。 欧拉函数有如下计算公式：若nnn可被表示为n=∏i=1kpiαin=\\prod\\limits_{i=1}^{k}p_i^{\\alpha_i}n=i=1∏k​piαi​​（算术基本定理分解式）的形式，则φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk)=n∗∏i=1k(1−1pi)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})=n*\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk​1​)=n∗i=1∏k​(1−pi​1​)。 推导思想即为用nnn减去所有[1,n)[1,n)[1,n)中所有与nnn不互质的数。在计算机上实现，首先需要分解质因数。思路如下：首先抛出第一个质因数p1p_1p1​，那么将[1,n][1,n][1,n]中所有的p1p_1p1​的倍数删去，因而可以保证筛出的数一定是nnn的质因子，否则他们将存在最大公约数p1p_1p1​。那么能被p1p_1p1​整除的数的个数（也就是nnn以内p1p_1p1​的倍数个数）为[np1][\\frac{n}{p_1}][p1​n​]——其中的中括号代表整除。 因此我们离解出欧拉函数就进了一步了，我们的过渡式子就是TS1(n)=n−[np1]−[np2]−⋯−[npk−1]−[npk]TS_1(n)=n-[\\frac{n}{p_1}]-[\\frac{n}{p_2}]-\\dots-[\\frac{n}{p_{k-1}}]-[\\frac{n}{p_k}]TS1​(n)=n−[p1​n​]−[p2​n​]−⋯−[pk−1​n​]−[pk​n​]。 好耶 别急着好耶，我们可以发现一个小小的推导谬误（可能并不是很容易发现）。当我们用p2p_2p2​去筛数时，使用的算式仍然是[np2][\\frac{n}{p_2}][p2​n​]。对于形如p1np2mp_1^np_2^mp1n​p2m​的数，会被重复筛去多次，导致多减，最终结果会小于φ(n)\\varphi(n)φ(n)。有些抽象，我们来看这张图： 易知[1,30][1,30][1,30]中可被222整除的数字共有30÷2=1530\\div 2=1530÷2=15个，能被555整除的数字共有30÷5=630\\div 5=630÷5=6个。但是如果说能被222和555整除的数字共有15+6=2115+6=2115+6=21个，显然不合常理，因为101010、202020、303030都既能被222整除，也能被555整除，如果不加排除，他们将会被减去2次。因此需要补偿损失，正确的计算方法是（仅计算能被222和555整除的数的总个数）： 能被222整除的：30÷2=1530\\div 2=1530÷2=15个 能被555整除的：30÷5=630\\div 5=630÷5=6个 同时被222和555整除的：30÷lca(2,5)=30÷10=330\\div lca(2,5)=30 \\div 10=330÷lca(2,5)=30÷10=3个 总个数：15+6−(2−1)×3=1815+6-(2-1)\\times 3=1815+6−(2−1)×3=18个（就是被绿圈和橙圈捆住的的数的个数） 那么对于222、333、555整除问题，中间的303030被重复加了3次，需减去两次平衡收支。此即容斥原理的简单思想表示。 回到欧拉函数推导上来：过渡公式TS1TS_1TS1​中的容斥问题可以解决一部分了。对于可同时被两个不同质数整除的数（例如6=2×36=2\\times36=2×3、15=3×515=3\\times515=3×5），我们加上它的总个数。 得到TS2=TS1+[np1p2]+[np1p3]+⋯+[np1pk]+[np2p3]+[np2p4]+⋯+[npk−1pk]TS_2=TS_1+[\\frac{n}{p_1p_2}]+[\\frac{n}{p_1p_3}]+\\dots+[\\frac{n}{p_1p_k}]+[\\frac{n}{p_2p_3}]+[\\frac{n}{p_2p_4}]+\\dots+[\\frac{n}{p_{k-1}p_k}]TS2​=TS1​+[p1​p2​n​]+[p1​p3​n​]+⋯+[p1​pk​n​]+[p2​p3​n​]+[p2​p4​n​]+⋯+[pk−1​pk​n​]。 当然这又有一个小问题没完没了了是不是？：对于p1 p2 p3p_1\\;p_2\\;p_3p1​p2​p3​的公倍数，会被先减去3次，然后被上一步的操作加上3次，总体不加不减。还是回到上图：中间的303030会被每个颜色的圈先减去一次、共3次，上一步的补偿操作，可以看作又被橙绿圈（橙圈和绿圈的交集）、蓝绿圈、蓝橙圈一共加上了3次。减3次加3次相当于没动，为了让它被算上，我们需要加上它，对于φ(n)\\varphi(n)φ(n)则是全部减去（因为括号外有减号需要变号，不要忘记φ(n)\\varphi(n)φ(n)是由一系列不合规的数字个数相减得来的）。得到我们的过渡态3：TS3=TS2−[np1p2p3]−[np1p2p4]−[np1p2p5]−⋯−[npk−2pk−1pk]TS_3=TS_2-[\\frac{n}{p_1p_2p_3}]-[\\frac{n}{p_1p_2p_4}]-[\\frac{n}{p_1p_2p_5}]-\\dots-[\\frac{n}{p_{k-2}p_{k-1}p_{k}}]TS3​=TS2​−[p1​p2​p3​n​]−[p1​p2​p4​n​]−[p1​p2​p5​n​]−⋯−[pk−2​pk−1​pk​n​] 又是如上的容斥判断，这里我们省去讨论。将最终的产物合并得到：φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)！（我不会合并，但是你可以把φ(n)\\varphi(n)φ(n)括号拆开看看是不是上述形式。总之，欧拉牛逼！） QEDQEDQED，好耶！终于可以好耶了…… Div2. 欧拉函数代码实现 主要是如果压成一个Div会非常的长，因此这里新开一个Div2 我们明确了欧拉函数的推导，接下来就是整理思路写代码的时间了！我们也只需跟着原始思路走就可以了。再次回忆一下：首先我们需要筛出质因数，除去它的所有倍数，再用公式φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)代入pip_ipi​就可以了。 1234567891011long long eular(int n) &#123; long long res = n; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; res = res * (i - 1) / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125; 时间复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：All Clear Div3. 欧拉函数推论 若ppp为质数，则φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 让我们回到欧拉函数的定义上去：φ(i)\\varphi(i)φ(i)是[1,i][1,i][1,i]中与iii互质的数的个数（特殊地，φ(1)=1\\varphi(1)=1φ(1)=1）。那么对于ppp这个质数，有多少数与它互质呢？ 很显然，答案是p−1p-1p−1个！因为ppp的质因子只有ppp本身，若不止ppp一个质因子，很显然它不是一个质数。因此φ(p)=p(1−1p)=p−1\\varphi(p)=p(1-\\frac{1}{p})=p-1φ(p)=p(1−p1​)=p−1。 假设pkp_kpk​是一个质数，pk∣ip_k\\mid ipk​∣i（或i mod pk=0i\\bmod p_k=0imodpk​=0），且φ(i)\\varphi(i)φ(i)的值已知，那么φ(pk∗i)=pk⋅φ(i)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)φ(pk​∗i)=pk​⋅φ(i) 凭啥呀？ 因为pkp_kpk​已经是一个质数，换句话说：在这个条件下pkp_kpk​是pk∗ip_k*ipk​∗i的一个质因子。在计算φ(i)\\varphi(i)φ(i)时，pkp_kpk​就已经作为一个质因子以(1−1pk)(1-\\frac{1}{p_k})(1−pk​1​)的形式乘进去了。此时φ(i)\\varphi(i)φ(i)可以写作 φ(i)=i(1−1p1)(1−1p2)…(1−1pk)…(1−1pn)……(1)\\varphi(i)=i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})\\dots (1-\\frac{1}{p_n})\\dots \\dots(1)φ(i)=i(1−p1​1​)(1−p2​1​)…(1−pk​1​)…(1−pn​1​)……(1) 那么函数值多乘了一个pkp_kpk​ φ(pk∗i)=pk⋅i(1−1p1)(1−1p2)…(1−1pk)…(1−1pn)……(2)\\varphi(p_k*i)=p_k\\cdot i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})\\dots (1-\\frac{1}{p_n})\\dots\\dots(2)φ(pk​∗i)=pk​⋅i(1−p1​1​)(1−p2​1​)…(1−pk​1​)…(1−pn​1​)……(2) 我们发现：(2)式中包含了(1)式，只是头上乘以了pkp_kpk​。因而得到φ(pk∗i)=φ(i)⋅pk\\varphi(p_k*i)=\\varphi(i)\\cdot p_kφ(pk​∗i)=φ(i)⋅pk​ 假设pkp_kpk​是一个质数，pk∤ip_k\\nmid ipk​∤i（或i mod pk≠0i\\bmod p_k\\neq0imodpk​​=0），且φ(i)\\varphi(i)φ(i)的值已知，那么φ(pk∗i)=pk⋅φ(i)⋅(1−1pk)=φ(i)⋅(pk−1)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)\\cdot(1-\\frac{1}{p_k})= \\varphi(i)\\cdot(p_k-1)φ(pk​∗i)=pk​⋅φ(i)⋅(1−pk​1​)=φ(i)⋅(pk​−1) 这东西长得和性质2很相似，唯一不同的是pkp_kpk​不再是iii的一个质因子了。但是pkp_kpk​变成了pk∗ip_k*ipk​∗i的质因子。因此我们计算φ(pk∗i)\\varphi(p_k*i)φ(pk​∗i)的值时，不仅需要在头部乘上pkp_kpk​，而且还需要将(1−1pk)(1-\\frac{1}{p_k})(1−pk​1​)乘进去： φ(pk∗i)=pk⋅i⋅(1−1p1)…(1−1pn)(1−1pk)\\varphi(p_k*i)=p_k\\cdot i\\cdot (1-\\frac{1}{p_1})\\dots(1-\\frac{1}{p_n})(1-\\frac{1}{p_k})φ(pk​∗i)=pk​⋅i⋅(1−p1​1​)…(1−pn​1​)(1−pk​1​) 因为pk⋅(1−1pk)=pk−1p_k\\cdot (1-\\frac{1}{p_k})=p_k-1pk​⋅(1−pk​1​)=pk​−1，所以得到性质3，即φ(pk∗i)=pk⋅φ(i)⋅(1−1pk)=φ(i)⋅(pk−1)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)\\cdot(1-\\frac{1}{p_k})= \\varphi(i)\\cdot(p_k-1)φ(pk​∗i)=pk​⋅φ(i)⋅(1−pk​1​)=φ(i)⋅(pk​−1)。 这三个性质将作为重点性质出现在欧拉函数筛法中。 Div4. 欧拉函数线性筛 我们已经接触了简单的欧拉函数计算方法，那么又该如何解决形如：“给定一个正整数i∈[x,y]i\\in [x,y]i∈[x,y]，求∑i=xyφ(i)\\sum\\limits_{i=x}^{y}\\varphi(i)i=x∑y​φ(i)的值”的问题呢？ 考虑继续使用上面的朴素算法，时间复杂度将会是nnn\\sqrt nnn​。明显无法满足需求，更何况，每个数与每个数之间的φ\\varphiφ值之间有一种推导关系，使得我们无需每次重新计算φ\\varphiφ值，而是用已经求出的φ(n)\\varphi(n)φ(n)来线性推出φ(i)\\varphi(i)φ(i)的值。 欧拉函数涉及到质因子的拆分，我们又需要在线性时间内求各种质数。自然而然想到了先前所学的线性筛： 12345678910111213int primes[N];bool st[N];int cnt = 0;void sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[++cnt] = i; for (int j = 1; primes[j] * i &lt;= n; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125; 我们运用这段代码可以得出[1,n][1,n][1,n]范围内所有的质数，用st[N]数组可以筛出所有的合数。也就是说对于筛出的合数，我们能够得知组成它的质因子是什么，比如st[primes[j]*i]=true;这一行代码。接着套用上述三种性质，我们可以得出φ\\varphiφ值。 此时我们就需要新建一个phi[N]数组来存储每个数的φ\\varphiφ值，并且在代码中三个地方加入对于三种性质的公式： 1234567891011121314151617181920212223typedef long long ll;ll primes[N];bool st[N];int cnt = 0;ll phi[N];void phi_sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; primes[j] * i &lt;= n; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) &#123; phi[primes[j] * i] = phi[i] * primes[j]; break; &#125; phi[primes[j] * i] = phi[i] * (primes[j] - 1); &#125; &#125;&#125; 没错我开了long long防止爆int 时间复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及&amp;提高 对于开头提出的求和问题，遍历phi[1]到phi[n]的所有值求和即可。 Div5. 欧拉定理 若正整数aaa与nnn互质，则有aφ(n)≡1(modn)a^{\\varphi(n)}\\equiv1\\pmod naφ(n)≡1(modn) 对于它的证明，百度百科中如此写到： 取mmm的缩系a1,a2,…,aφ(m)a_1,a_2,\\dots,a_{\\varphi(m)}a1​,a2​,…,aφ(m)​，故aa1,aa2,…,aaφ(m)aa_1,aa_2,\\dots,aa_{\\varphi(m)}aa1​,aa2​,…,aaφ(m)​也为mmm的缩系。有∏i=1φ(m)ai≡∏i=1φ(m)aai≡aφ(m)∏i=1φ(m)ai(modm)\\prod\\limits_{i=1}^{\\varphi(m)}a_i\\equiv\\prod\\limits_{i=1}^{\\varphi(m)}aa_i\\equiv a_{\\varphi(m)}\\prod\\limits_{i=1}^{\\varphi(m)}a_i\\pmod mi=1∏φ(m)​ai​≡i=1∏φ(m)​aai​≡aφ(m)​i=1∏φ(m)​ai​(modm) 通俗来讲就是这样： 在[1,n][1,n][1,n]中取所有与nnn互质的数a1,a2…,aφ(n)a_1,a_2\\dots,a_{\\varphi(n)}a1​,a2​…,aφ(n)​，很容易知道这样的aaa共有φ(n)\\varphi(n)φ(n)个（根据欧拉函数定义得来）。它们都与nnn互质。 给这列数同时乘上aaa，得到aa1,aa2,…,aaφ(n)aa_1,aa_2,\\dots,aa_{\\varphi(n)}aa1​,aa2​,…,aaφ(n)​。它们也都和nnn互质，并且各不相同。 提出括号里乘了φ(n)\\varphi(n)φ(n)次的aaa，得到以下关系式：aφ(n)[a1a2…aφ(n)]≡a1a2…aφ(n)(modn)a^{\\varphi(n)}[a_1a_2\\dots a_{\\varphi(n)}]\\equiv a_1a_2\\dots a_{\\varphi(n)}\\pmod naφ(n)[a1​a2​…aφ(n)​]≡a1​a2​…aφ(n)​(modn) 那么根据同余号两端的消去原则（左右两端两个项相同且与模nnn互质），可以消去a1a2…aφ(n)a_1a_2\\dots a_{\\varphi(n)}a1​a2​…aφ(n)​。得到aφ(n)≡1(modn)a^{\\varphi(n)}\\equiv1\\pmod naφ(n)≡1(modn)，欧拉定理得证。 特殊地，如果ppp是一个质数，有aφ(p)≡1(modp)⇒ap−1≡1(modp)a^{\\varphi(p)}\\equiv1\\pmod p\\Rightarrow a^{p-1}\\equiv1\\pmod paφ(p)≡1(modp)⇒ap−1≡1(modp)。这被称作费马小定理（先前的费马素性检验就是基于这个原理编写的）。 真不知道明明可以写得通俗点为什么非得省那点空间写看起来那么高深莫测的专业术语，真的是只写给自己看的。 Div6. 降幂算法 尤其对于绿题以上的题目，题面中可能出现“答案可能很大，请对大质数ppp取余”的字样。这意味着题目可能涉及到大规模的幂运算，需要我们用简便的方法计算幂。对于一般的题目，我们使用快速幂。 快速幂：快速幂思想如下： ab={ab2×ab2,b mod 2=0a×ab−12×ab−12,b mod 2=1a^b= \\begin{cases}a^{ \\frac{b}{2}}\\times a^{ \\frac{b}{2}},&amp; b\\bmod 2=0\\\\a\\times a^{ \\frac{b-1}{2}}\\times a^{ \\frac{b-1}{2}},&amp;b\\bmod2=1 \\end{cases}ab={a2b​×a2b​,a×a2b−1​×a2b−1​,​bmod2=0bmod2=1​ 我们将指数bbb分解为若干2n2^n2n的和（二进制表示），例如：a11=a20⋅a21⋅a23a^{11}=a^{2^0}\\cdot a^{2^1}\\cdot a^{2^3}a11=a20⋅a21⋅a23，因为(11)10=(1011)2(11)_{10}=(1011)_2(11)10​=(1011)2​。因而不必将aaa连续乘11次，效率大幅提升。 1234567891011typedef long long ll;int qpow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; &#125; return res;&#125; 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 适用范围：基本All Clear 欧拉降幂：上面方法一个缺点在于无法处理过大的指数，在处理类似于a2na^{2^n}a2n的计算时将会疯狂掉san。接下来介绍一种使用上面讲到的欧拉定理来解决大指数幂运算的方法。 欧拉降幂核心公式：ak mod p=ak mod φ(p)+φ(p) mod pa^k\\bmod p=a^{k\\bmod\\varphi(p)+\\varphi(p)}\\bmod pakmodp=akmodφ(p)+φ(p)modp（又称 扩展欧拉定理 ） 也就是说：我们只需要算出q=k mod φ(p)+φ(p)q=k\\bmod\\varphi(p)+\\varphi(p)q=kmodφ(p)+φ(p)的值，再用快速幂算法，将qqq作为新指数带入计算即可。当然，这里的kkk可能会爆long long，因此可以选择使用字符串进行高精度计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef long long ll;ll primes[N];bool st[N];int cnt = 0;int qpow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; &#125; return res;&#125;ll eular(int n) &#123; ll res = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[++cnt] = i; res = res * (i - 1) / i; while (n % i == 0) n /= i; &#125; for (int j = 1; i * primes[j] &lt;= n; j++) &#123; st[i * primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125;int edp(int a, string k, int p) &#123; ll phi = eular(p); int drop = 0; for (int i = 0; i &lt; k.length(); i++) &#123; drop *= 10; drop += k[i] % phi; &#125; drop += phi; return qpow(a, drop, p);&#125; 其中eular(int n)函数用于计算欧拉函数的值、edp(int a, string k, int p)用于计算降幂后的指数、qpow(int a, int k, int p)是快速幂算法。 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 适用范围：所有 扩展欧拉定理可谓是欧拉定理的一般形式，它的定义如下：对于任意正整数aaa、kkk、ppp，满足： $ak\\equiv\\begin{cases}ak&amp;(\\bmod;p ),gcd(a,p)\\neq1,k&lt;\\varphi§\\a{k\\bmod\\varphi§+\\varphi§}&amp;(\\bmod;p),gcd(a,p)\\neq1,k\\geq\\varphi§\\a{k\\bmod\\varphi§}&amp;(\\bmod;p),gcd(a,p)=1\\end{cases} $ 其中第二个式子就是欧拉降幂的核心公式。 扩展欧拉定理的证明见这里。因为太复杂了我不会证 例题： P2158 [SDOI2008] 仪仗队 （欧拉函数板子） P1447 [NOI2010] 能量采集（上一个问题的变式） P1226 [模板] 快速幂 P5091 [模板] 扩展欧拉定理 （欧拉降幂） P4139 上帝与集合的正确用法 （欧拉降幂+递归） Part5. 同余方程的解法 这里会涉及到一元线性同余方程，一元线性同余方程组和高次同余方程的算法解法。 Div.1 裴蜀定理 很多人会把他读成裴除（chú）（比如我的某位好友），这个名词正确的读法是裴蜀（shǔ）。或者可以直接改称作“贝祖定理”，它的提出者艾蒂安·裴蜀估计怎么也没想到后人居然连他的名字都读不对（想想如果这种事情发生到你身上会怎么样）。你也可以读他名字的法语发音BeˊzoutB\\acute ezoutBeˊzout（显得你很优雅且有文化）。 切入正题，裴蜀定理表述为：对于任意正整数aaa，bbb，总有整数xxx、yyy，使得ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)，其中(a,b)(a,b)(a,b)等价于gcd(a,b)gcd(a,b)gcd(a,b)，是数论中最大公约数的表述方式。 首先可以知道at+bn=d (n,t∈Z n,t≠0)at+bn=d\\;\\;\\;(n,t\\in\\mathbb Z\\;\\;\\;n,t\\neq0)at+bn=d(n,t∈Zn,t​=0)且(a,b)∣d(a,b)\\mid d(a,b)∣d，因为aaa和bbb都具有约数(a,b)(a,b)(a,b)，让他们分别乘上另两个数ttt和nnn并不会改变(a,b)(a,b)(a,b)这一约数。所以假设d=k⋅(a,b),k∈Zd=k\\cdot(a,b),k\\in\\mathbb Zd=k⋅(a,b),k∈Z，有atk+bnk=(a,b)a\\frac{t}{k}+b\\frac{n}{k}=(a,b)akt​+bkn​=(a,b)。在这里，x=tk y=nkx=\\frac{t}{k}\\;\\;y=\\frac{n}{k}x=kt​y=kn​。 Div2. 扩展欧几里得（EXGCD） 加了“扩展”二字是不是感觉逼格上来了？ 扩展欧几里得算法用于求出线性同余方程的解。线性同余方程，即形如ax≡b(modp)ax\\equiv b\\pmod pax≡b(modp)的方程，我们需要求出xxx的值。 回忆一下欧几里得算法的核心思路：(a,b)={(a,a mod b)a mod b≠0aa mod b=0(a,b)=\\begin{cases}(a,a\\bmod b)&amp;a\\bmod b\\neq0\\\\a&amp;a\\bmod b=0\\end{cases}(a,b)={(a,amodb)a​amodb​=0amodb=0​。 再看看刚刚讲到的裴蜀定理，发现(a mod b)x+by=k⋅(a,a mod b)=k⋅(a,b)=d(a\\bmod b)x+by=k\\cdot(a,a\\bmod b)=k\\cdot(a,b)=d(amodb)x+by=k⋅(a,amodb)=k⋅(a,b)=d。根据余数的定义，有：(a−⌊ab⌋⋅b)x+by=d(a-\\lfloor\\frac{a}{b}\\rfloor\\cdot b)x+by=d(a−⌊ba​⌋⋅b)x+by=d。 那么我们的任务就是求出这里的xxx和yyy值，因此拆开括号，整理出aaa和bbb的系数：ax+b(y−⌊ab⌋x)=dax+b(y-\\lfloor\\frac{a}{b}\\rfloor x)=dax+b(y−⌊ba​⌋x)=d。观察裴蜀定理的形式：ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)，我们得出的式子中，yyy变成了y−⌊ab⌋xy-\\lfloor\\frac{a}{b}\\rfloor xy−⌊ba​⌋x。因此每次递归时需要将yyy的值减去⌊ab⌋x\\lfloor\\frac{a}{b}\\rfloor x⌊ba​⌋x。 既然我们设计的是一个递归算法，我们就必须明确它的递归出口。根据欧几里得算法，当a mod b=0a\\bmod b=0amodb=0时，(a,b)=a(a,b)=a(a,b)=a。我们把aaa和a mod ba\\bmod bamodb代入发现：ax+(a mod b)y=(a,b)=aax+(a\\bmod b)y=(a,b)=aax+(amodb)y=(a,b)=a，得到ax+0y=aax+0y=aax+0y=a，此时yyy可取任意整数值，x=1x=1x=1。这里我所取的解是{x=1y=0\\begin{cases}x=1\\\\y=0\\end{cases}{x=1y=0​。 最后，因为这本质上还是一个欧几里得算法，所以返回(a,b)(a,b)(a,b)是有必要的（事实上exgcd算法返回的(a,b)(a,b)(a,b)将作为推导式中的ddd参与运算）。我们可以写出如下函数。 12345678910int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125; 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 但是，题目中一般不会给出裴蜀定理那样的形式，而是形如ax≡b(modm)ax\\equiv b\\pmod max≡b(modm)的形式，让你求出xxx的值，并且上述方法仅求出了一元线性同余方程的一组特解，如果题目中让你求出最小正整数解呢？接下来就是解决上述问题的方法： 1. 同余—等式互转（自己起的名字）： 在上面的介绍中，我们遇到了一个问题：如何将ax≡b(modm)ax\\equiv b\\pmod max≡b(modm)这样的同余式变为ax+by=cax+by=cax+by=c这样的二元一次不定方程的裴蜀定理形式呢？ 考虑到同余方程的定义（或者你可以把以下关系死记住），得到ax mod m=bax\\bmod m=baxmodm=b。接着由余数定义，得到ax=by+m,y∈Zax=by+m,y\\in\\mathbb Zax=by+m,y∈Z，移项得到：ax−by=max-by=max−by=m。提出负号，令b′=−bb^\\prime=-bb′=−b，则ax+b′y=max+b^\\prime y=max+b′y=m。它有解的充要条件是m∣(a,b)m\\mid(a, b)m∣(a,b)。经过如上变换后就变成了裴蜀定理的形式，可以直接用exgcd求解xxx和yyy。 2. 最值解问题： 二元一次不定方程通解的证明 Div3. 中国剩余定理（CRT） 又称孙子定理（但我认为还是中国剩余定理听起来更有实力一些），最早见于《孙子算经》中“物不知数”问题，首次提出了有关一元线性同余方程的问题与解法。 对于一元线性同余方程：S→{x≡a1(modp1)x≡a2(modp2)⋮x≡ak(modpk)S\\rightarrow\\begin{cases}x\\equiv a_1\\pmod{p_1}\\\\x\\equiv a_2\\pmod{p_2}\\\\\\vdots\\\\x\\equiv a_k\\pmod{p_k}\\end{cases}S→⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​(modp1​)x≡a2​(modp2​)⋮x≡ak​(modpk​)​，可以构造以下方法求出通解。 首先，令M=p1⋅p2⋅p3…pk=∏i=1kpiM=p_1\\cdot p_2\\cdot p_3\\dots p_k=\\prod\\limits_{i=1}^{k}p_iM=p1​⋅p2​⋅p3​…pk​=i=1∏k​pi​。 然后，令Mi=Mpi (1≤i≤k)M_i=\\frac{M}{p_i}\\;(1\\leq i\\leq k)Mi​=pi​M​(1≤i≤k)，即除了pip_ipi​外所有ppp的乘积。 接着，令tit_iti​为MiM_iMi​在模pip_ipi​意义下的逆元，即ti⋅Mi≡1(modpi)t_i\\cdot M_i\\equiv1\\pmod{p_i}ti​⋅Mi​≡1(modpi​)。 所以，SSS的通解为：x=a1t1M1+a2t2M2+⋯+aktkMk+kM=kM+∑i=1kaipiMix=a_1t_1M_1+a_2t_2M_2+\\dots+a_kt_kM_k+kM=kM+\\sum\\limits_{i=1}^{k}a_ip_iM_ix=a1​t1​M1​+a2​t2​M2​+⋯+ak​tk​Mk​+kM=kM+i=1∑k​ai​pi​Mi​。 Div4. Baby Step Giant Step算法（BSGS） 这个算法用于解决一元高次同余方程问题，模意义下的对数也可以求。又称“北上广深算法”（想出这种名字的人真是人才）。 高次同余方程长成这个样子： ax≡b(modm)a^x\\equiv b\\pmod max≡b(modm) 发现xxx跑到了指数上边真是变态呢。这种问题显然没公式解，于是苦恼的人们只得选择一条略显暴力的求解道路，即搜索。严格来说，BSGS所使用的是双搜索，其中的一个变量的搜索步长会长于另一个变量的搜索步长，因而得名“大步小步算法”。或者叫北上广深/拔山盖世算法！ 朴素BSGS（aaa与mmm互质）：不妨令x=At−Bx=At-Bx=At−B，原式为aAt−B≡b(modm)a^{At-B}\\equiv b\\pmod maAt−B≡b(modm)。根据消去原则，两边同乘aBa^BaB得aAt≡baB(modm)a^{At}\\equiv ba^B\\pmod maAt≡baB(modm)。 接下来我们对同余号右侧的部分求值，再任命一个固定的ttt值，使得左侧模mmm的值等于右侧模mmm的值。为了快速比对左右侧的值，我们选择将右侧预先计算出来的值存入一个哈希表中，让baB mod m→Bba^B\\bmod m\\rightarrow BbaBmodm→B（键为baBba^BbaB，对应值为BBB）。接着就是选择ttt值，计算aAt mod ma^{At}\\bmod maAtmodm并比对了。 关于哈希表冲突，我们希望找到x,x=At−Bx,x=At-Bx,x=At−B的最小值，因而BBB需要尽可能大。每次冲突即代表一个更大的BBB值被发现了。因此无需处理冲突问题。 对于ttt的选择。可以发现BBB有φ(m) mod t\\varphi(m)\\bmod tφ(m)modt个可能的取值，AAA有⌊φ(m)/t⌋\\lfloor\\varphi(m)/t\\rfloor⌊φ(m)/t⌋个。ttt取⌈φ(m)⌉\\lceil\\sqrt{\\varphi(m)}\\rceil⌈φ(m)​⌉时最佳。因此代码就可以写出来了。 123456789101112131415161718ll bsgs(ll a, ll b, ll m) &#123; unordered_map&lt;ll, ll&gt; hash; ll bs = 1; int t = sqrt(m) + 1; for (int B = 1; B &lt;= t; B++) &#123; bs *= a; bs %= m; hash[b * bs % m] = B; &#125; ll gs = bs; for (int A = 1; A &lt;= t; A++) &#123; auto iter = hash.find(gs); if (iter != hash.end()) return A * t - it-&gt;second; gs *= bs; gs %= m; &#125; return -1;&#125; 时间复杂度：O(m)\\mathcal O(\\sqrt m)O(m​) 扩展BSGS（aaa和mmm不互质）： 例题： P1082 [NOIP2012 提高组] 同余方程 (exgcd) P5656 [模板] 二元一次不定方程 (exgcd) P1495 [模板] 中国剩余定理（CRT）/ 曹冲养猪 P1516 青蛙的约会 （CRT+exgcd） P3846 [TJOI2007] 可爱的质数/ [模板] BSGS P2485 [SDOI2011] 计算器 （欧拉降幂+乘法逆元+BSGS） P3306 [SDOI2013] 随机数生成器 （等比数列推导+BSGS） P4195 [模板] 扩展 BSGS/exBSGS Part6. 乘法逆元 乘法逆元定义如下（注意和矩阵求逆不是一个东西）： 若a⋅x≡1( mod b)a\\cdot x\\equiv1(\\bmod\\;b)a⋅x≡1(modb)，且aaa与bbb互质，则xxx是aaa在模bbb条件下的乘法逆元，记作a−1a^{-1}a−1 简单来说乘法逆元xxx就是模bbb意义下的aaa的倒数。 费马小定理求逆元：大部分题目会给出一个质数模数，因而互质是可以保证的。此时我们的乘法逆元就是使式子a⋅x≡1( mod p)a\\cdot x\\equiv1(\\bmod\\;p)a⋅x≡1(modp)成立的xxx值，考虑到模数ppp为质数，可以带回开头所说的费马小定理中。 得到ap−1≡1( mod p)a^{p-1}\\equiv1(\\bmod\\;p)ap−1≡1(modp)，由于aaa与ppp互质，消去得：a⋅ap−2≡1( mod p)a\\cdot a^{p-2}\\equiv1(\\bmod\\;p)a⋅ap−2≡1(modp)，所以乘法逆元为ap−2 mod pa^{p-2}\\bmod\\;pap−2modp。 123int inv(int a, int p) &#123; return qpow(a, p - 2, p);&#125; 扩展欧几里得求逆元：这是万能的方法，对任意模数均成立。它不像上面费马小定理那样限制模数必须是质数，因而只要时间充裕，都建议使用这种求逆元的方式。 因为ax≡1(modb)ax\\equiv 1\\pmod bax≡1(modb)，运用同余-等式互转可以得到ax−1=by→ax+by′=1(modb),y′=−yax-1=by\\rightarrow ax+by^\\prime=1\\pmod b,y^\\prime=-yax−1=by→ax+by′=1(modb),y′=−y。符合exgcd的形式。 12345678910111213141516int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int a, int m) &#123; int x, y; exgcd(a, m, x, y); return (x + m) % m;&#125; 递推求逆元： 例题： P3811 [模板] 模意义下的乘法逆元 （递推求逆元） 来张弔图 Part7. 矩阵相关 矩阵，是一个按照长方排列的实数或复数集合。它最早用来表示方程组中的系数和常数，简单理解就是它将nnn元一次方程组中的系数，按照未知数的顺序依次挑出它们的系数组合为矩阵的某一行。nnn元一次方程的矩阵有nnn列，而行数则取决于方程组中方程的个数。 Div1. 初等行变换 考虑这个方程组： {2x+3y=−1…1x−2z=6…2x+2y−4z=−2…3\\begin{cases}2x+3y=-1&amp;\\dots1\\\\x-2z=6&amp;\\dots2\\\\x+2y-4z=-2&amp;\\dots3\\end{cases}⎩⎪⎨⎪⎧​2x+3y=−1x−2z=6x+2y−4z=−2​…1…2…3​ 按照如上所述，将它转换为系数矩阵（只有x,y,zx,y,zx,y,z的系数）就是： (2301−2012−4)\\begin{pmatrix}2&amp;3&amp;0\\\\1&amp;-2&amp;0\\\\1&amp;2&amp;-4\\end{pmatrix}⎝⎛​211​3−22​00−4​⎠⎞​ 你也可以写成增广矩阵（与系数矩阵相比多了一列常数，即等号右边的常数，这里用竖线隔开）的形式： (230−11−20612−4−2)\\left(\\begin{array}{ccc|c}2&amp;3&amp;0&amp;-1\\\\1&amp;-2&amp;0&amp;6\\\\1&amp;2&amp;-4&amp;-2\\end{array}\\right)⎝⎛​211​3−22​00−4​−16−2​⎠⎞​ 不难看出第一列代表了xxx的系数，第二列和第三列是yyy和zzz的系数。那么如果需要求解这个矩阵（得到方程组的解），我们应该通过初等行变换将它变成方便我们求解的模式。初等行变换内容如下（最好用方程组消元的思想简化理解）： 交换某两行 把矩阵的某一行同乘以一个非零的数 把某行的若干倍加和到另一行 假设我们有一个nnn元线性方程组，如何设计算法使计算机能够快速求出它的解呢。我们需要引入三角矩阵的概念： 顾名思义，系数排列看起来像一个三角形的矩阵，叫做三角矩阵。分为上三角矩阵和下三角矩阵。前者的非零系数均分布在对角线的右上方、后者都在左下方，例如矩阵：U→(522170−249−10076400028)U\\rightarrow\\begin{pmatrix}5&amp;2&amp;2&amp;1&amp;7\\\\0&amp;-2&amp;4&amp;9&amp;-1\\\\0&amp;0&amp;7&amp;6&amp;4\\\\0&amp;0&amp;0&amp;2&amp;8\\end{pmatrix}U→⎝⎜⎜⎛​5000​2−200​2470​1962​7−148​⎠⎟⎟⎞​就是一个上三角矩阵（这里是增广矩阵）。通常用字母UUU表示，求解线性方程组时经常化为这种形式方便求解：本例中当最后一个未知数（见最后一行）已知时，可以通过向上代入求解每一行中待求的未知数值。 那么如何将一个一般矩阵转换为上三角矩阵呢？答案是前面介绍过的初等行变换！步骤如下： 枚举每一列ccc，选出无序组中第ccc列系数绝对值最大的一行ppp，并移到无序组的最上边。 ppp行通过自乘，将第ccc列的系数变成111，并标记ppp为有序。 通过加减有序组中某一行的非零倍，将之后所有行的第ccc列系数化为000。 文字还是太抽象，我们来举个例子： 令矩阵A→(2−11141−151110)A\\rightarrow\\left(\\begin{array}{ccc|c}2&amp;-1&amp;1&amp;1\\\\4&amp;1&amp;-1&amp;5\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)A→⎝⎛​241​−111​1−11​150​⎠⎞​（有序组用绿色表示） 枚举第一列，c=1c=1c=1。开始时，所有行均无序。选出绝对值最大的那一项，本例中为第二行，进行移动，原矩阵变为： (41−152−1111110)\\left(\\begin{array}{ccc|c}4&amp;1&amp;-1&amp;5\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​421​1−11​−111​510​⎠⎞​ 第二步，自乘并标记有序，因此第一行除以444，原矩阵就变成了： (10.25−0.251.252−1111110)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​121​0.25−11​−0.2511​1.2510​⎠⎞​ 第三步，将无序组的第ccc列消成000。本例中，我们让第二行减去二倍第一行；第三行直接减去第一行，得到： (10.25−0.251.250−1.51.5−1.500.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\0&amp;-1.5&amp;1.5&amp;-1.5\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.25−1.50.75​−0.251.51.25​1.25−1.5−1.25​⎠⎞​ 枚举第二列，此时c=2c=2c=2。第一步，选出第二列系数绝对值最大的那一行，移到无序组最上端。本例中无需移动，自乘−23-\\frac{2}{3}−32​，标记有序，原矩阵为： (10.25−0.251.2501−1100.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\\\textcolor{green}{0}&amp;\\textcolor{green}{1}&amp;\\textcolor{green}{-1}&amp;\\textcolor{green}{1}\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.2510.75​−0.25−11.25​1.251−1.25​⎠⎞​ 最终的最终，第三行减0.750.750.75倍第二行，得到我们心心念念的上三角矩阵： U→(10.25−0.251.2501−11002−2)U\\rightarrow\\left(\\begin{array}{ccc|c}1&amp;0.25&amp;-0.25&amp;1.25\\\\0&amp;1&amp;-1&amp;1\\\\0&amp;0&amp;2&amp;-2\\end{array}\\right)U→⎝⎛​100​0.2510​−0.25−12​1.251−2​⎠⎞​ 我们假设从左到右，分别为xxx、yyy、zzz的系数，竖线右侧为常数。矩阵可以改写成方程组的形式： {x+0.25y−0.25z=1.25y−z=12z=−2\\begin{cases}x+0.25y-0.25z=1.25\\\\y-z=1\\\\2z=-2\\end{cases}⎩⎪⎨⎪⎧​x+0.25y−0.25z=1.25y−z=12z=−2​ 根据最后一行，显然z=−1z=-1z=−1。将zzz代入2式，解得y=0y=0y=0，以此类推，由下向上代入解出的值即可，本例的唯一解是：{x=1y=0z=−1\\begin{cases}x=1\\\\y=0\\\\z=-1\\end{cases}⎩⎪⎨⎪⎧​x=1y=0z=−1​。 然而心细的你估计发现了疏漏之处：“求一元二次方程时都要先检验根是否存在（Δ\\DeltaΔ判别式法）再来作答，你这里怎么没有讨论根的分布情况呢？” 事实上，矩阵的解的分布确实不止一种情况，这里是矩阵有唯一解的情况。类比高中立体几何求平面法向量的情景，我们通常都要令某个坐标为111或者是其他方便于计算的值，这里就是矩阵有无数组解的经典例子。要想系统分析矩阵方程解的数量情况，我们需要引入秩的概念。 Div2. 秩 在上一节中我们通过初等行变换求出了矩阵的解，然而并不是所有矩阵都能轻而易举求出唯一解，因为它可能无解、也有可能无唯一解（默认最高次数为一）。类比一元二次方程中的Δ\\DeltaΔ判别式法，矩阵是否也有判断根存在性的方法？ 答案是：有滴！在矩阵运算中，我们使用秩来描述矩阵的一些关于解的个数的关系。秩被定义为：将矩阵通过初等行变换后形成的梯形矩阵中非零行的个数。试看如下例子： 定义一个3×23\\times23×2的矩阵：(231693072)\\begin{pmatrix}2&amp;3&amp;1\\\\6&amp;9&amp;3\\\\0&amp;7&amp;2\\end{pmatrix}⎝⎛​260​397​132​⎠⎞​ 经过初等行变换后出现了这样的情况： (4−10000072)\\begin{pmatrix}4&amp;-1&amp;0\\\\0&amp;0&amp;0\\\\0&amp;7&amp;2\\end{pmatrix}⎝⎛​400​−107​002​⎠⎞​(第二行减去乘3的第一行，第一行乘2减去第三行) 第二行变成了纯000的一行，一、三行说什么都无法消成一个未知数的形式。如果写成方程组就是： {4x−y=a17y+2z=a2\\begin{cases}4x-y=a_1\\\\7y+2z=a_2\\end{cases}{4x−y=a1​7y+2z=a2​​ 它有无数组解，原因是：矩阵的秩与矩阵增广矩阵的秩相等且小于了它的阶。简单来说就是你用两个方程去求三个未知数的值（初一内容），当然是有无数多组解。 规定对于矩阵AAA，它的秩用R(A)R(A)R(A)表示（r(A)r(A)r(A)、rk(A)rk(A)rk(A)、rank(A)rank(A)rank(A)均可）。因此令方程组的nnn阶增广矩阵秩为R(A)R(A)R(A)，系数矩阵的秩为R(B)R(B)R(B)。矩阵有无数组解的条件就是R(B)&lt;nR(B)&lt;nR(B)&lt;n（严格来说：有无数组解的充要条件是R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n） 看第二个例子： 定义增广矩阵：A→(28313−2271)A\\rightarrow\\left(\\begin{array}{cc|c}2&amp;8&amp;3\\\\1&amp;3&amp;-2\\\\2&amp;7&amp;1\\end{array}\\right)A→⎝⎛​212​837​3−21​⎠⎞​；它的系数矩阵：B→(281327)B\\rightarrow\\begin{pmatrix}2&amp;8\\\\1&amp;3\\\\2&amp;7\\end{pmatrix}B→⎝⎛​212​837​⎠⎞​。 增广矩阵变换后：(01220−25003)\\left(\\begin{array}{cc|c}0&amp;1&amp;2\\\\2&amp;0&amp;-25\\\\0&amp;0&amp;3\\end{array}\\right)⎝⎛​020​100​2−253​⎠⎞​；系数矩阵：(012000)\\begin{pmatrix}0&amp;1\\\\2&amp;0\\\\0&amp;0\\end{pmatrix}⎝⎛​020​100​⎠⎞​ 根据定义，得到R(A)=3R(A)=3R(A)=3，R(B)=2R(B)=2R(B)=2，此时R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)。方程组无解。因而矩阵无解的充要条件是R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)。简单理解起来就是方程组中的两个方程起了冲突，矩阵AAA被省去的其中一步变换是：(01220−25015)\\left(\\begin{array}{cc|c}0&amp;1&amp;2\\\\2&amp;0&amp;-25\\\\0&amp;1&amp;5\\end{array}\\right)⎝⎛​020​101​2−255​⎠⎞​，第一行和第三行相当于要你求解如下的方程组：{y=2y=5\\begin{cases}y=2\\\\y=5\\end{cases}{y=2y=5​。显然矛盾，因此矩阵无解。 加上第一节里面的结论，我们总结出了矩阵解分布的三种情况（方程组的增广矩阵为AAA、系数矩阵为BBB，阶为nnn）： 当R(A)=R(B)=nR(A)=R(B)=nR(A)=R(B)=n时，矩阵有唯一解 当R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n时，矩阵有无数解 当R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)时，矩阵无解 因此就有了一套组合算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 110#define NO_SOLUTION -1#define INFINITE 0#define SOLVE_OK 1using namespace std;typedef long long ll;double mat[N][N];int n;double eps = 1e-6; int solve() &#123; int rank = 0; for (int c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; if (fabs(mat[i][c]) &gt; fabs(mat[t][c])) t = i; &#125; if (fabs(mat[t][c]) &lt; eps) continue; for (int i = c; i &lt;= n; i++) swap(mat[r][i], mat[t][i]); for (int i = n; i &gt;= c; i--) mat[r][i] /= mat[r][c]; for (int i = r + 1; i &lt; n; i++) &#123; if (fabs(mat[i][c]) &gt; eps) &#123; for (int j = n; j &gt;= c; j--) &#123; mat[i][j] -= (mat[r][j] * mat[i][c]); &#125; &#125; &#125; r++; rank = r; &#125; if (rank &lt; n) &#123; for (int i = rank; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; if (fabs(mat[i][j]) &gt; eps) return NO_SOLUTION; &#125; &#125; return INFINITE; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; mat[i][n] -= mat[i][j] * mat[j][n]; &#125; &#125; return SOLVE_OK;&#125; int main() &#123; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) cin&gt;&gt;mat[i][j]; &#125; int res = solve(); if (res != SOLVE_OK) cout&lt;&lt;res&lt;&lt;endl; else for (int i = 0; i &lt; n; i++) &#123; if (fabs(mat[i][n]) &lt; eps) mat[i][n] = fabs(mat[i][n]); printf(&quot;x%d=%.2lf\\n&quot;, i + 1, mat[i][n]); &#125; return 0;&#125; 时间复杂度：O(n3)\\mathcal O(n^3)O(n3) 以后上大学解高次线性方程就可以用这段程序秒了。 Div3. 矩阵基本运算 1. 加法： (238142)+(604335)=(2+63+08+41+34+32+5)=(8312477)\\begin{pmatrix}2&amp;3&amp;8\\\\1&amp;4&amp;2\\end{pmatrix}+\\begin{pmatrix}6&amp;0&amp;4\\\\3&amp;3&amp;5\\end{pmatrix}=\\begin{pmatrix}2+6&amp;3+0&amp;8+4\\\\1+3&amp;4+3&amp;2+5\\end{pmatrix}=\\begin{pmatrix}8&amp;3&amp;12\\\\4&amp;7&amp;7\\end{pmatrix}(21​34​82​)+(63​03​45​)=(2+61+3​3+04+3​8+42+5​)=(84​37​127​) 注意类比nnn元一次方程组的加减消元，两个矩阵相加意味着同一位置的元素相加。需要注意：只有同型的矩阵才有加法运算（同型即行数列数相等）。 可以知道，四则运算的加法交换律和结合律仍然适用于矩阵加法。 2. 减法： (238142)−(604335)=(2−63−08−41−34−32−5)=(−434−21−3)\\begin{pmatrix}2&amp;3&amp;8\\\\1&amp;4&amp;2\\end{pmatrix}-\\begin{pmatrix}6&amp;0&amp;4\\\\3&amp;3&amp;5\\end{pmatrix}=\\begin{pmatrix}2-6&amp;3-0&amp;8-4\\\\1-3&amp;4-3&amp;2-5\\end{pmatrix}=\\begin{pmatrix}-4&amp;3&amp;4\\\\-2&amp;1&amp;-3\\end{pmatrix}(21​34​82​)−(63​03​45​)=(2−61−3​3−04−3​8−42−5​)=(−4−2​31​4−3​) 加法的逆运算，让矩阵同一位置的元素相减即可。也是仅限于同型矩阵之间才可做减法。 3. 数乘： 4⋅(142615360)=(1×44×42×46×41×45×43×46×40×4)=(41682442012240)4\\cdot\\begin{pmatrix}1&amp;4&amp;2\\\\6&amp;1&amp;5\\\\3&amp;6&amp;0\\end{pmatrix}=\\begin{pmatrix}1\\times4&amp;4\\times4&amp;2\\times4\\\\6\\times4&amp;1\\times4&amp;5\\times4\\\\3\\times4&amp;6\\times4&amp;0\\times4\\end{pmatrix}=\\begin{pmatrix}4&amp;16&amp;8\\\\24&amp;4&amp;20\\\\12&amp;24&amp;0\\end{pmatrix}4⋅⎝⎛​163​416​250​⎠⎞​=⎝⎛​1×46×43×4​4×41×46×4​2×45×40×4​⎠⎞​=⎝⎛​42412​16424​8200​⎠⎞​ 即矩阵中每个元素都跟数字相乘。符合乘法交换律和结合律 矩阵的加法、减法和数乘合称为矩阵的线性运算 4. 转置： 矩阵AAA的转置矩阵用ATA^TAT表示。 (142615)T=(164125)\\begin{pmatrix}1&amp;4&amp;2\\\\6&amp;1&amp;5\\end{pmatrix}^T=\\begin{pmatrix}1&amp;6\\\\4&amp;1\\\\2&amp;5\\end{pmatrix}(16​41​25​)T=⎝⎛​142​615​⎠⎞​ 直观来讲就是将原矩阵旋转一下（行和列互换）。满足如下性质： (AT)T=A(A^T)^T=A(AT)T=A (转置一次后再转置一次还是原来的矩阵) (λA)T=λAT(\\lambda A)^T=\\lambda A^T(λA)T=λAT （常数转置后就是它本身） (AB)T=ATBT(AB)^T=A^TB^T(AB)T=ATBT （上一条是它的特殊形式，类比两数乘积的幂） 5. 共轭： 矩阵AAA的共轭矩阵用A‾\\overline AA表示。 A=(2+i85−4i2i)A=\\begin{pmatrix}2+i&amp;8\\\\5-4i&amp;2i\\end{pmatrix}A=(2+i5−4i​82i​) A‾=(2−i85+4i−2i)\\overline A=\\begin{pmatrix}2-i&amp;8\\\\5+4i&amp;-2i\\end{pmatrix}A=(2−i5+4i​8−2i​) 类比共轭复数的定义：实部不变、虚部取相反数。矩阵共轭变换就是将矩阵中的所有复数变为其共轭形式。 6. 共轭转置： 矩阵AAA的共轭转置矩阵记作A∗A^*A∗、A‾T\\overline A^TAT、AT‾\\overline{A^T}AT或AHA^HAH。 A=(2+i85−4i2i1+i2−2i)A=\\begin{pmatrix}2+i&amp;8\\\\5-4i&amp;2i\\\\1+i&amp;2-2i\\end{pmatrix}A=⎝⎛​2+i5−4i1+i​82i2−2i​⎠⎞​ AH=(2−i5+4i1−i8−2i2+2i)A^H=\\begin{pmatrix}2-i&amp;5+4i&amp;1-i\\\\8&amp;-2i&amp;2+2i\\end{pmatrix}AH=(2−i8​5+4i−2i​1−i2+2i​) 字面意思，先取共轭，再转置。它具备转置矩阵的三条性质。 Div4. 矩阵乘法 只有一个矩阵的行数和另一个矩阵的列数相等时才可进行乘法运算。 例如一个n×pn\\times pn×p矩阵A→(142308)A\\rightarrow\\begin{pmatrix}1&amp;4&amp;2\\\\3&amp;0&amp;8\\end{pmatrix}A→(13​40​28​)和一个p×mp\\times mp×m矩阵B→(264138)B\\rightarrow\\begin{pmatrix}2&amp;6\\\\4&amp;1\\\\3&amp;8\\end{pmatrix}B→⎝⎛​243​618​⎠⎞​。记它们的乘积C=ABC=ABC=AB。则CCC中的某个元素ci,j=ai,1b1,j+ai,2b2,j+⋯+ai,pbp,j=∑k=1nai,kbk,jc_{i,j}=a_{i,1}b_{1,j}+a_{i,2}b_{2,j}+\\dots+a_{i,p}b_{p,j}=\\sum\\limits_{k=1}^{n}a_{i,k}b_{k,j}ci,j​=ai,1​b1,j​+ai,2​b2,j​+⋯+ai,p​bp,j​=k=1∑n​ai,k​bk,j​。并且CCC是一个n×mn\\times mn×m的矩阵。 因此AB=(1×2+4×4+2×31×6+4×1+2×83×2+0×4+8×33×6+0×1+8×8)=(24263082)AB=\\begin{pmatrix}1\\times2+4\\times4+2\\times3&amp;1\\times6+4\\times1+2\\times8\\\\3\\times2+0\\times4+8\\times3&amp;3\\times6+0\\times1+8\\times8\\end{pmatrix}=\\begin{pmatrix}24&amp;26\\\\30&amp;82\\end{pmatrix}AB=(1×2+4×4+2×33×2+0×4+8×3​1×6+4×1+2×83×6+0×1+8×8​)=(2430​2682​) 它满足结合律、分配律，但是大多数情况下不满足交换律。交换律不成立可以看到下面这个例子： 首先根据定义，CCC矩阵的行列数取决于做乘法的两个矩阵AAA和BBB的行列数，比如8×38\\times38×3矩阵和3×43\\times43×4矩阵相乘，得到一个8×48\\times48×4矩阵，但是将它颠倒顺序，让一个3×43\\times43×4矩阵与8×38\\times38×3矩阵相乘，结果将是一个4×84\\times84×8矩阵，和前者行列数相反。 对于结果是正方形矩阵的，可以自己随便设置两个矩阵进行计算。但是部分矩阵仍然可以进行交换律运算：矩阵乘一个单位矩阵/数量矩阵[AE=EAAE=EAAE=EA/A(kE)=(kE)AA(kE)=(kE)AA(kE)=(kE)A]、矩阵乘它的伴随矩阵（AA∗=A∗AAA^*=A^*AAA∗=A∗A）。 Div5. 其他常用类型的矩阵 1. 零矩阵：顾名思义，由000组成的矩阵称作零矩阵。零矩阵不可逆，且任何符合条件的矩阵与一个零矩阵的积均为零矩阵。 2. 单位矩阵：形如(100010001)\\begin{pmatrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\end{pmatrix}⎝⎛​100​010​001​⎠⎞​的矩阵被称作单位矩阵，通常用字母EEE或III表示。单位矩阵指仅对角线系数为111、且其他系数为000的矩阵。nnn阶矩阵与它的逆矩阵相乘得到的结果就是一个nnn阶单位矩阵，即AA−1=EAA^{-1}=EAA−1=E。 3. 数量矩阵：形如(k000k000k),k∈R\\begin{pmatrix}k&amp;0&amp;0\\\\0&amp;k&amp;0\\\\0&amp;0&amp;k\\end{pmatrix},k\\in\\mathbb R⎝⎛​k00​0k0​00k​⎠⎞​,k∈R的矩阵叫数量矩阵，可以看作实数kkk与单位矩阵EEE进行数乘运算后的结果，通常表示成kE,k∈RkE,k\\in\\mathbb RkE,k∈R。矩阵与一个数量矩阵的乘积满足乘法交换律。 4. 逆矩阵：如果存在一个矩阵BBB和单位矩阵EEE，使得AB=E=BAAB=E=BAAB=E=BA，则称矩阵AAA可逆，BBB是AAA的逆矩阵，也可记作A−1A^{-1}A−1。单位矩阵的逆矩阵是它本身；零矩阵不可逆。nnn阶矩阵可逆的充要条件是R(A)=nR(A)=nR(A)=n。 5. 对称矩阵：转置矩阵与自身相等的矩阵叫做对称矩阵，特征是所有元素关于对角线对称，例如：(035308580)\\begin{pmatrix}0&amp;3&amp;5\\\\3&amp;0&amp;8\\\\5&amp;8&amp;0\\end{pmatrix}⎝⎛​035​308​580​⎠⎞​。对称矩阵必为方形矩阵，反之不一定成立，对于一个方形矩阵AAA，A+ATA+A^TA+AT必定是对称矩阵。 Div6. 矩阵的几何表示 平面直角坐标系上，一个向量a⃗=(1,2)\\vec a=(1,2)a=(1,2)可以被表示成[12]\\begin{bmatrix}1\\\\2\\end{bmatrix}[12​]的形式，即[xy]\\begin{bmatrix}x\\\\y\\end{bmatrix}[xy​]。 计算机中，用两个不共线向量i⃗\\vec ii和j⃗\\vec jj​能够表示整个平面直角坐标系。运用一点高中数学的空间几何知识，这里的i⃗\\vec ii和j⃗\\vec jj​被称作基底（当然，如果需要描述三维空间坐标系，则需要三个不共线的基底向量）。于是我们使用矩阵[xixjyiyj]\\begin{bmatrix}\\textcolor{red}{x_i}&amp;\\textcolor{green}{x_j}\\\\\\textcolor{red}{y_i}&amp;\\textcolor{green}{y_j}\\end{bmatrix}[xi​yi​​xj​yj​​]来描述这个平面直角坐标系就是非常简洁明了且优雅的了。 假设我们常规想法中的平面直角坐标系是[1001]\\begin{bmatrix}\\textcolor{red}{1}&amp;\\textcolor{green}{0}\\\\\\textcolor{red}{0}&amp;\\textcolor{green}{1}\\end{bmatrix}[10​01​]，经过一轮线性变换后得到的新坐标系是：[231−2]\\begin{bmatrix}\\textcolor{red}{2}&amp;\\textcolor{green}{3}\\\\\\textcolor{red}{1}&amp;\\textcolor{green}{-2}\\end{bmatrix}[21​3−2​]。用一张图看一下变换后的坐标系： 如果在最开始的坐标系中有一个向量a⃗→[57]\\vec a\\rightarrow\\begin{bmatrix}5\\\\7\\end{bmatrix}a→[57​]，我们如何在新的坐标系中表示它呢？再根据我们高中数学所学，只需要算出5i⃗+7j⃗5\\vec i+7\\vec j5i+7j​的值即可。因为i⃗\\vec ii是xxx轴的基底，相当于xxx上的一个单位，我们求新向量时只需求出在新的参考系中的新xxx值和yyy值，因而直接用xxx方向的系数乘以一个单位即可，在这里就是5⋅[21]+7⋅[3−2]5\\cdot\\begin{bmatrix}\\textcolor{red}{2}\\\\\\textcolor{red}{1}\\end{bmatrix}+7\\cdot\\begin{bmatrix}\\textcolor{green}{3}\\\\\\textcolor{green}{-2}\\end{bmatrix}5⋅[21​]+7⋅[3−2​]，得到a⃗→[31−9]\\vec a\\rightarrow\\begin{bmatrix}31\\\\-9\\end{bmatrix}a→[31−9​]。 抽象之后变成： [abcd][xy]=x[ac]+y[ad]=[ax+bycx+dy]\\begin{bmatrix}\\textcolor{red}{a}&amp;\\textcolor{green}{b}\\\\\\textcolor{red}{c}&amp;\\textcolor{green}{d}\\end{bmatrix}\\begin{bmatrix}x\\\\y\\end{bmatrix}=x\\begin{bmatrix}\\textcolor{red}{a}\\\\\\textcolor{red}{c}\\end{bmatrix}+y\\begin{bmatrix}\\textcolor{green}{a}\\\\\\textcolor{green}{d}\\end{bmatrix}=\\begin{bmatrix}\\textcolor{red}{a}x+\\textcolor{green}{b}y\\\\\\textcolor{red}{c}x+\\textcolor{green}{d}y\\end{bmatrix}[ac​bd​][xy​]=x[ac​]+y[ad​]=[ax+bycx+dy​] TODOTODOTODO 例题： P3389 [模板] 高斯消元法 （上三角矩阵的转换） P2455 [SDOI2006] 线性方程组 （前一道题的升级版） Part8. 组合计数 StarterDiv1. 阶乘概述 阶乘，数学中用!!!表示，n!,n∈Nn!,n\\in\\mathbb Nn!,n∈N表示n×(n−1)×(n−2)⋯×2×1n\\times(n-1)\\times(n-2)\\dots\\times2\\times1n×(n−1)×(n−2)⋯×2×1的值，即∏i=0n−1(n−i)\\prod\\limits_{i=0}^{n-1}(n-i)i=0∏n−1​(n−i) 特殊地，0!=10!=10!=1。 StarterDiv2. 常用排列总结 1. 排列数：数学中用AnmA_{n}^{m}Anm​表示（ArrangementArrangementArrangement，老教材记作PnmP_{n}^{m}Pnm​，PermulationPermulationPermulation）。表示从mmm个数中选择nnn个进行排列，公式为：Anm=n(n−1)(n−2)…(n−m+1)=n!(n−m)!A_{n}^{m}=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}Anm​=n(n−1)(n−2)…(n−m+1)=(n−m)!n!​ 为啥呢？，有弔图为证↓ 2. 组合数：假设有mmm个物品，从中任选出nnn个排成一组，叫做组合；所有可能的选法总数叫做组合数。用CnmC_{n}^{m}Cnm​表示，计算公式为：Cnm=AnmAmm=n!m!(n−m)!C_{n}^{m}=\\frac{A_{n}^{m}}{A_{m}^{m}}=\\frac{n!}{m!(n-m)!}Cnm​=Amm​Anm​​=m!(n−m)!n!​。简记为：乌鸦坐飞机 弔图×2↓ GZ表示就凭这几张图他能速通整个组合数的内容 StarterDiv3. 二项式定理 学过初中的大家都知道：(x+y)2=x2+2xy+y2(x+y)^2=x^2+2xy+y^2(x+y)2=x2+2xy+y2，这是完全平方和公式。高中的一些牛逼娃还知道完全立方和公式，也就是：(x+y)3=(x+y)(x2+xy+y2)=x3+3y2x+3xy2+y3(x+y)^3=(x+y)(x^2+xy+y^2)=x^3+3y^2x+3xy^2+y^3(x+y)3=(x+y)(x2+xy+y2)=x3+3y2x+3xy2+y3。这些式子其实都是可以由二项式定理套出来的。 二项式定理定义式如下： (x+y)n=(n0)xny0+(n1)xn−1y1+(n2)xn−2y2+⋯+(nn−1)x1yn−1+(nn)x0yn=∑k=0n(nk)xn−kyk(x+y)^n=\\begin{pmatrix}n\\\\0\\end{pmatrix}x^ny^0+\\begin{pmatrix}n\\\\1\\end{pmatrix}x^{n-1}y^1+\\begin{pmatrix}n\\\\2\\end{pmatrix}x^{n-2}y^2+\\dots+\\begin{pmatrix}n\\\\n-1\\end{pmatrix}x^1y^{n-1}+\\begin{pmatrix}n\\\\n\\end{pmatrix}x^0y^n=\\sum\\limits_{k=0}^{n}\\begin{pmatrix}n\\\\k\\end{pmatrix}x^{n-k}y^k(x+y)n=(n0​)xny0+(n1​)xn−1y1+(n2​)xn−2y2+⋯+(nn−1​)x1yn−1+(nn​)x0yn=k=0∑n​(nk​)xn−kyk 这里出现的(nk)=n!k!(n−k)!\\begin{pmatrix}n\\\\k\\end{pmatrix}=\\frac{n!}{k!(n-k)!}(nk​)=k!(n−k)!n!​。是不是突然发现它和组合数公式的共同之处喽？但是这一章并不会用它，只是作补充知识的说…… 有这三条就够了，接下来进入组合计数的内容。 Div1. 高考娃狂喜——组合数计算 一个小栗子： 宇宙榜一大学阿福大学的榜一博士后导师黑虎阿福给你出了一道难题： 给你两个正整数aaa和bbb（a≥ba\\geq ba≥b），让你求出CbaC_{b}^{a}Cba​的值。 你：“这还不简单？” 阿福： “好的，我这里将aaa设为208509042085090420850904，bbb设为177209317720931772093，请你求解。” 你： “WTF？” 于是你决定用程序来代替人脑，阿福教授也做出了一定让步，让你求出Cba mod pC_{b}^{a}\\bmod pCba​modp的值。但是不幸的是，人类的计算机科学水平自从2024之后就被来自几光年外的八体星人文明发出的“侄子一号（NEPHEW 1）”探测僚机锁定了，因此你需要设计一个高效的计算方式，而不是妄想着用2077年的赛博机器运行暴力计算，来解决这个问题。 一旦你的运行时间超过一秒，阿福教授就会使用战技“乌鸦坐飞机”对你造成大量阶乘伤害。已经学习了阶乘的你想必已了解了它的威力，所以还是老老实实推导公式吧！ 递推版： 组合数递推公式：Cab=Ca−1b+Ca−1b−1C_{a}^{b}=C_{a-1}^{b}+C_{a-1}^{b-1}Cab​=Ca−1b​+Ca−1b−1​。 分析思路类似于动态规划问题：我们要从aaa个物品中挑选bbb个出来，求组合数。 上图中，若包含这个红色物体，那么我们只需再从剩下的a−1a-1a−1个物体里挑选，因为红色物体自身占据了bbb个位置中的其中一个，因此留给其他物体的总名额就只有b−1b-1b−1个，因此该情况下组合数：Ca−1b−1C_{a-1}^{b-1}Ca−1b−1​；同样地，若不包含红色物体，从剩下的a−1a-1a−1个物体中选出bbb个，因为在该情况下红色的物体不计入组合，因此剩余名额还是bbb个，组合数就是Ca−1bC_{a-1}^{b}Ca−1b​。最后，因为从aaa个物体里选，只有包含红色和不包含红色两种情况（就好像你的双亲，不是你的母亲就是你的父亲），因此可以做到不重不漏。所以总组合数就是Ca−1b−1+Ca−1bC_{a-1}^{b-1}+C_{a-1}^{b}Ca−1b−1​+Ca−1b​。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 2010using namespace std;int c[N][N];void Csieve(int p) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % p; &#125; &#125;&#125;int main() &#123; int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; Csieve(p); cout&lt;&lt;c[a][b]&lt;&lt;endl; return 0;&#125; 时间复杂度：O(N2)\\mathcal O(N^2)O(N2) 适用于a,b≤105a,b\\leq10^5a,b≤105的大部分情况。 预处理版： 但是众所周知，递归有两大痛点：对于主观思维来说，是边界问题；对于客观条件来说，是内存。递归过程中CPU里储存了大量的未运行或者待返回的函数实例，当aaa和bbb的值增大时，尽管它能在时间方面表现出色，但是内存就不那么理想了，反而会显得臃肿至极。当题目中给出a,b≥105a,b\\geq10^5a,b≥105时，建议用这种方法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;int fact[N], infact[N];int qpow(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int a, int p) &#123; return qpow(a, p - 2, p);&#125;int C(int a, int b, int p) &#123; return ((fact[a] % p) * (infact[b] % p)) % p * infact[a - b] % p; &#125;int main() &#123; int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; fact[0] = infact[0] = 1; for (int i = 1; i &lt;= N; i++) &#123; fact[i] = (ll) fact[i - 1] * i % p; infact[i] = (ll) infact[i - 1] * inv(i, p) % p; &#125; cout&lt;&lt;C(a, b, p)&lt;&lt;endl; return 0;&#125; 时间复杂度：O(Nlog⁡N)\\mathcal O(N\\log N)O(NlogN) 适用范围，a,b≥105a,b\\geq10^5a,b≥105且a,ba,ba,b均在int范围内的大部分情况。 Lucas定理优化版： LucasLucasLucas定理如下：Cab≡Ca mod pb mod p⋅Ca÷pb÷p(modp)C_{a}^{b}\\equiv C_{a\\bmod p}^{b\\bmod p}\\cdot C_{a\\div p}^{b\\div p}\\pmod pCab​≡Camodpbmodp​⋅Ca÷pb÷p​(modp)（ppp为质数）。证明在此（建议直接背结论）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef long long ll;int p;int qpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int a) &#123; return qpow(a, p - 2);&#125;int C(int a, int b) &#123; int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) &#123; res = (ll) res * j % p; res = (ll) res * inv(i) % p; &#125; return res;&#125;ll lucas(int a, int b) &#123; if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (ll) C(a % p, b % p) * lucas(a / p, b / p) % p;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; int n, m; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; cout&lt;&lt;lucas(n + m, n)&lt;&lt;endl; &#125; return 0;&#125; 时间复杂度：O(N)\\mathcal O(N)O(N) 其本质是套用LucasLucasLucas定理计算CabC_{a}^{b}Cab​，因为是模ppp意义下的除法，因而我们使用逆元来操作除法。 适用范围，a,ba,ba,b在long long范围内的大部分情况。 高精度版（选修）： 什么？你厌倦了组合数后面挂着的模ppp？不妨试试高精度版的组合数计算吧！它适用于作业上的题目求解！（虽然前面几种也可以，毕竟手算的题数据很小取不取模都一样）是不是心动了呢？ 常规思路来说，我们的组合数公式经过一轮分式化简可以得到：Cab=a×(a−1)×(a−2)×⋯×(a−b+1)b×(b−1)×(b−2)×⋯×2×1C_{a}^{b}=\\frac{a\\times(a-1)\\times(a-2)\\times\\dots\\times(a-b+1)}{b\\times(b-1)\\times(b-2)\\times\\dots\\times2\\times1}Cab​=b×(b−1)×(b−2)×⋯×2×1a×(a−1)×(a−2)×⋯×(a−b+1)​。因此我们可以实现高精度的乘除法来计算这个炒鸡长的算式，但是这样不仅效率低下，手写和调试的难度也会增加。我们急切地想知道如何简化成一种高精度算法。 我们看到了Part1里面讲的算术基本定理，将组合数转化为p1c1p2c2p3c3...pkckp_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}p1c1​​p2c2​​p3c3​​...pkck​​的质数乘积分解式，最后我们只需要解决质数头顶的指数即可。我们使用以下这个公式： α(n!)=⌊np⌋⋅⌊np2⌋⋅⋯⋅⌊npk⌋,pk≤n,n,k∈Z\\alpha(n!)=\\lfloor\\frac{n}{p}\\rfloor\\cdot\\lfloor\\frac{n}{p^2}\\rfloor\\cdot\\dots\\cdot\\lfloor\\frac{n}{p^k}\\rfloor,p^k\\leq n, n,k\\in\\mathbb Zα(n!)=⌊pn​⌋⋅⌊p2n​⌋⋅⋯⋅⌊pkn​⌋,pk≤n,n,k∈Z。 用它可以计算出n!n!n!中pip_ipi​的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;typedef long long ll;vector&lt;int&gt; num;ll primes[N], sum[N];bool st[N];int cnt = 0;void prime_sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[++cnt] = i; for (int j = 1; i * primes[j] &lt;= n; j++) &#123; st[i * primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;int get(int a, int p) &#123; int res = 0; while (a) &#123; res += a / p; a /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) &#123; vector&lt;int&gt; res; int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i] * b; res.push_back(t % 10); t /= 10; &#125; while (t) &#123; res.push_back(t % 10); t /= 10; &#125; return res;&#125;int main() &#123; int a, b; cin&gt;&gt;a&gt;&gt;b; prime_sieve(a); for (int i = 1; i &lt;= cnt; i++) sum[i] = get(a, primes[i]) - get(b, primes[i]) - get(a - b, primes[i]); vector&lt;int&gt; res; res.push_back(1); for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= sum[i]; j++) &#123; res = mul(res, primes[i]); &#125; &#125; for (int i = res.size() - 1; i &gt;= 0; i--) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0;&#125; 时间复杂度：O(NN)\\mathcal O(N\\sqrt N)O(NN​) 适用范围，a,ba,ba,b在int范围内。 有了这段代码，我们就可以完成开头阿福教授的原问题了（不模不限数据）！ Div2. 世界上最OI的IDE——Catalan数 当你翻开Catalan数的介绍文章，并大学特学了一番，感觉自己完全掌握了这神奇的数列，正当你兴致勃勃地打开题库搜索到一道Catalan数的题目正准备大展身手时，你会发现，面对这神奇的题干，不同于往常秒模板题的你，你甚至完全看不出来它和Catalan数有任何的关系，而且很有可能，你其实连Catalan数究竟是什么东西都不知道！ 苏子愀然，正襟危坐而问客曰：“何为其然也？” 其实还真不能让那些博客背上黑锅，这种现象与Catalan数本身的应用有很大的关系。 Catalan数，或者习惯叫卡特兰数、明安图数，是组合数学中常用的特殊数列。数列如下：“1,1,2,5,14,42,132,429,1430,4862,…1,1,2,5,14,42,132,429,1430,4862,\\dots1,1,2,5,14,42,132,429,1430,4862,…”，它是一个无穷数列，数与数之间看起来似乎也没什么太大联系……其实它和斐波那契数列有类似之处，它们不具有特定的数学意义（只是斐波那契的递推方法简单得多罢了），只是一个十分普遍的数学规律。所以学习时应该挂靠于例子本身而不是一味依赖于定义所写，那我们就开始吧： 用最经典的例子写出来就是： 给你一个u×vu\\times vu×v的网格，你将从原点(0,0)(0,0)(0,0)开始移动。对于每次移动，你只能向上/向右一格（yyy坐标/xxx坐标加一），但是需要保证你总向右走的次数不少于向上走的次数，问从原点到A(n,n)A(n,n)A(n,n)有多少种不同的合法路径？ 假设你某时刻走到了点M(s,t)M(s,t)M(s,t)，根据题目要求，意味着需要保证s≥ts\\geq ts≥t。我们拟合一条经过点MMM的正比例函数，不难看出它的斜率k≤1k\\leq1k≤1。对于这个u×vu\\times vu×v的网格，所有的点都在整数刻度上。我们接着画出直线y=x+1y=x+1y=x+1的图像，然后尽可能画几条不合法的路径出来比对一下，你会发现：不合法的路径与直线y=x+1y=x+1y=x+1至少有一个交点，合法路径一定与y=x+1y=x+1y=x+1没有交点。用一张图来直观体会一下： 终点A(5,5)A(5,5)A(5,5)，其中红线为不合法路径，蓝线为合法路径。不难发现，不合法的路径与绿线（y=x+1y=x+1y=x+1）都有至少一个交点，因为它们在某次移动后的端点与原点拟合而成的正比例函数的斜率k&gt;1k&gt;1k&gt;1，因此不是合法路径。 那么如何来计算合法和不合法路径的条数呢？直接求出合法路径不好求，规律不好找，因此我们计算出总路径数量，减去不合法数量即是合法路径数量。 可以看到，无论选择什么样的路径，在不左移、不下移的前提下，到达A(n,n)A(n,n)A(n,n)，你都只能移动2n2n2n次（小学内容，把横线和竖线平移到一块数格子），其中右移nnn次、上移nnn次。转化一下，就是在2n2n2n次移动中选出nnn次进行右移操作，总数就是C2nnC_{2n}^nC2nn​。 因为所有路径，包括合法的和不合法的路径都最终抵达了A(5,5)A(5,5)A(5,5)，难以将内鬼剔除出来。我们选择将不合法路径关于判定线y=x+1y=x+1y=x+1对称过去，它们的新终点将是A′(4,6)A^\\prime(4,6)A′(4,6)，也就是A′(n−1,n+1)A^\\prime(n-1,n+1)A′(n−1,n+1)。根据上面的推导方法，这里就是在2n2n2n轮移动中挑出n−1n-1n−1次右移操作，于是不合法路径的数量就是：C2nn−1C_{2n}^{n-1}C2nn−1​，合法路径数量是：f=C2nn−C2nn−1f=C_{2n}^{n}-C_{2n}^{n-1}f=C2nn​−C2nn−1​。 （至于为什么用右移次数而不是上移次数，是因为上移受到限制，这意味着你可以一直右移到x=5x=5x=5而无需担心条件限制；但是你就不能先一直上移到y=5y=5y=5，因为这不符合题目要求） 扩展：如果题干中指明向右走的次数不少于向上走的次数±t\\pm t±t，则只需将判定线上下平移为y=x+1±ty=x+1\\pm ty=x+1±t即可。 那这些又和宇宙第一IDE有什么关系呢 应用场景一：括号匹配 将向右走转化为左括号“（”，向上走转化为右括号“）”。对于每一次输入，检查一下左括号输入次数是否永不小于右括号输入次数。若是，当输入最后一个右括号，使左右括号数量相同时，即为匹配成功；若不是，且左括号个数大于右括号个数，则表明括号等待补全；若不是，且左括号个数小于右括号个数，即立即宣布失配。 应用场景二：合法进出栈序列计数问题 假设一个初始为空的栈，有2n2n2n次操作，nnn次进栈，nnn次出栈，请问合法进出栈序列总数（空栈不出）是多少？ 答案就是Catalan数，自行套公式计算。 应用场景三：圆的不相交弦计数问题 假设一个圆周上分布着偶数个点，对这些点两两连线，使相连的线不相交的所有方案数。其中一个合法解如下图： 聪明如你，答案还是Catalan数！那么如何转化为已知问题求解呢？ 我们将出发点标记为左括号“（”，从出发点引出去的线与其他线/点的所有交点标记为右括号“）”。当所有点两两连接完毕时，根据场景一的模型，一旦左右括号失配即代表不合法，否则合法。因此这个问题也就变成了：给定2n2n2n个左括号和右括号，求出使左右括号匹配的排列个数。在这里，如果问题无解，将会是这样： 例题： P3807 [模板] 卢卡斯定理/Lucas 定理 P5014 水の三角(修改版) （Catalan数公式变形推导）","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"一命已出，前来还愿","slug":"thanks","date":"2023-11-12T01:42:41.000Z","updated":"2023-11-12T01:45:04.509Z","comments":true,"path":"2023/11/12/thanks/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/thanks/","excerpt":"","text":"","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"}]},{"title":"Latex常用符号大全","slug":"latex-symbols","date":"2023-11-12T01:23:35.000Z","updated":"2023-11-26T00:56:36.729Z","comments":true,"path":"2023/11/12/latex-symbols/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/latex-symbols/","excerpt":"","text":"Part1. 运算符 Div1. 基本运算 加号：+++，键盘上有 减号：−-−，键盘上有 乘号（叉乘）: $ \\times $ \\times 乘号（数量积/点乘）：⋅\\cdot⋅ \\cdot 除号：÷\\div÷ \\div 开方/N次方根：ABCN\\sqrt[N]{ABC}NABC​ \\sqrt[N]&#123;ABC&#125; 乘方/N次幂：ANA^NAN A^N 下标：ANA_NAN​ A_N 分数：AB\\frac{A}{B}BA​ \\frac&#123;A&#125;&#123;B&#125; 等于号：===，键盘上有 约等号：≈\\approx≈ \\approx 加粗 ≈\\thickapprox≈ \\thickapprox 不等号：≠\\neq​= \\neq 恒等号/定义为：≡\\equiv≡ \\equiv 大于号：&gt;\\gt&gt; \\gt 小于号：&lt;\\lt&lt; \\lt 大于等于：≥\\geq≥ \\geq 小于等于：≤\\leq≤ \\leq 远大于：≫\\gg≫ \\gg 远小于：≪\\ll≪ \\ll 正负：±\\pm± \\pm 负正：∓\\mp∓ \\mp Div.2 几何表示 垂直：⊥\\perp⊥ \\perp 平行：∥\\parallel∥ \\parallel 角/无标记角：∠\\angle∠ \\angle 角/标记角：∡\\measuredangle∡ \\measuredangle 一般全等：≅\\cong≅ \\cong 相似：∼\\sim∼ \\sim，加粗 ∼\\thicksim∼ \\thicksim 三角形：△\\triangle△ \\triangle 正方形：□\\square□ \\square 圆：⊙\\odot⊙ \\odot 向量：AB⃗\\vec{AB}AB \\vec_&#123;AB&#125; 或 AB→\\overrightarrow{AB}AB \\overrightarrow&#123;AB&#125; Div.3 集合 属于：∈\\in∈ \\in 不属于：∉\\notin∈/​ \\notin 子集：⫅\\subseteqq⫅ \\subseteqq 真子集：⫋\\varsubsetneqq \\varsubseteqq 或 ⫋\\subsetneqq⫋ \\subsetneqq 真子集/直线在平面上：⊂\\subset⊂ \\subset 正整数集：N∗N^*N∗ N^* 或 N+N_+N+​ N_+ 并集：∪\\cup∪ \\cup 交集：∩\\cap∩ \\cap 补集：∁UA\\complement{_U^A}∁UA​ \\complement&#123;_U^A&#125; Div.4 逻辑符号 因为：∵\\because∵ 所以：∴\\therefore∴ 存在：∃\\exists∃ \\exists 不存在：∄\\nexists∄ \\nexists 任意/对于所有：∀\\forall∀ \\forall 空集：∅\\varnothing∅ \\varnothing 逻辑或：∪\\cup∪ \\cup 或 ∨\\lor∨ \\lor 逻辑与：∩\\cap∩ \\cap 或 ∧\\land∧ \\land 逻辑非：¬\\lnot¬ \\lnot 充分条件/右双箭头：⇒\\Rightarrow⇒ \\Rightarrow 大小写敏感 必要条件/左双箭头：⇐\\Leftarrow⇐ \\Leftarrow 大小写敏感 充要条件/双向双箭头：⇔\\Leftrightarrow⇔ \\Leftrightarrow 大小写敏感 Div.5 高级数学 成正比：∝\\propto∝ \\propto 定积分：∫ab\\int_{a}^{b}∫ab​ \\int_&#123;a&#125;^&#123;b&#125; 多重积分：∬ab\\iint_{a}^{b}∬ab​ \\iint_&#123;a&#125;^&#123;b&#125; 及 ∭ab\\iiint_{a}^{b}∭ab​ \\iiint_&#123;a&#125;^&#123;b&#125; 导函数/上撇号：′\\prime′ \\prime 求和：∑i=1n\\sum_{i=1}^{n}∑i=1n​ \\sum_&#123;i=1&#125;^&#123;n&#125; 求积：∏i=1n\\prod_{i=1}^{n}∏i=1n​ \\prod_&#123;i=1&#125;^&#123;n&#125; 字母数位/平均数：ABCD‾\\overline{ABCD}ABCD \\overline&#123;ABCD&#125; 整除符号：∣\\mid∣ \\mid 新定义运算符：⊕\\oplus⊕ \\oplus 及 ⊗\\otimes⊗ \\otimes 及 ⊖\\ominus⊖ \\ominus 扰动值：K~\\tilde{K}K~ \\tilde&#123;K&#125; 高德纳箭头/上箭头：3↑↑23\\uparrow \\uparrow 23↑↑2 3\\uparrow \\uparrow 2 Div.6 常数 无穷大/无限：∞\\infty∞ \\infty 圆周率：π\\piπ \\pi 普朗克常数：ℏ\\hbarℏ \\hbar 或 ℏ\\hslashℏ \\hslash Div.7 注音 一声：eˉ\\bar{e}eˉ \\bar&#123;e&#125; 二声/法语闭音符：eˊ\\acute{e}eˊ \\acute&#123;e&#125; 三声：eˇ\\check{e}eˇ \\check&#123;e&#125; 四声/法语重音符：eˋ\\grave{e}eˋ \\grave&#123;e&#125; 字母双点/德语特殊字母/特殊拼音：u¨\\ddot{u}u¨ \\ddot&#123;u&#125; 特殊发音符：a~\\tilde{a}a~ \\tilde&#123;a&#125; 抑扬符：a^\\hat{a}a^ \\hat&#123;a&#125; Div.8 希腊/希伯来字母 小写希腊字母 α\\alphaα \\alpha β\\;\\;\\;\\;\\betaβ \\beta χ\\;\\;\\;\\;\\chiχ \\chi δ\\;\\;\\;\\;\\deltaδ \\delta ϵ\\;\\;\\;\\;\\epsilonϵ \\epsilon η\\;\\;\\;\\;\\etaη \\eta γ\\gammaγ \\gamma ι\\;\\;\\;\\;\\iotaι \\iota κ\\;\\;\\;\\;\\kappaκ \\kappa λ\\;\\;\\;\\;\\lambdaλ \\lambda μ\\;\\;\\;\\;\\muμ \\mu ν\\;\\;\\;\\;\\nuν \\nu ooo o ω\\;\\;\\;\\;\\omegaω \\omega ϕ\\;\\;\\;\\;\\phiϕ \\phi π\\;\\;\\;\\;\\piπ \\pi ψ\\;\\;\\;\\;\\psiψ \\psi ρ\\;\\;\\;\\;\\rhoρ \\rho σ\\sigmaσ \\sigma τ\\;\\;\\;\\;\\tauτ \\tau θ\\;\\;\\;\\;\\thetaθ \\theta υ\\;\\;\\;\\;\\upsilonυ \\upsilon ξ\\;\\;\\;\\;\\xiξ \\xi ζ\\;\\;\\;\\;\\zetaζ \\zeta 变量希腊字母 ϝ\\digammaϝ \\digamma ε\\;\\;\\;\\;\\varepsilonε \\varepsilon ϰ\\;\\;\\;\\;\\varkappaϰ \\varkappa φ\\;\\;\\;\\;\\varphiφ \\varphi ϖ\\;\\;\\;\\;\\varpiϖ \\varpi ϱ\\;\\;\\;\\;\\varrhoϱ \\varrho ς\\varsigmaς \\varsigma ϑ\\;\\;\\;\\;\\varthetaϑ \\vartheta 大写希腊字母（仅展示大小写字母样式有差别者） Δ\\DeltaΔ \\Delta Γ\\;\\;\\;\\;\\GammaΓ \\Gamma Λ\\;\\;\\;\\;\\LambdaΛ \\Lambda Ω\\;\\;\\;\\;\\OmegaΩ \\Omega Φ\\;\\;\\;\\;\\PhiΦ \\Phi Π\\;\\;\\;\\;\\PiΠ \\Pi Ψ\\PsiΨ \\Psi Σ\\;\\;\\;\\;\\SigmaΣ \\Sigma Θ\\;\\;\\;\\;\\ThetaΘ \\Theta Υ\\;\\;\\;\\;\\UpsilonΥ \\Upsilon Ξ\\;\\;\\;\\;\\XiΞ \\Xi 希伯来文字母 ℵ\\alephℵ \\aleph ℶ\\;\\;\\;\\;\\bethℶ \\beth ℸ\\;\\;\\;\\;\\dalethℸ \\daleth ℷ\\;\\;\\;\\;\\gimelℷ \\gimel","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"}]},{"title":"DC Doujin 2023 EP1 先行预告","slug":"dcd2023ep1-trailer","date":"2023-11-05T04:32:52.000Z","updated":"2023-11-05T05:25:44.130Z","comments":true,"path":"2023/11/05/dcd2023ep1-trailer/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/dcd2023ep1-trailer/","excerpt":"","text":"DC Doujin 2023，点击访问。 DC Doujin将在11月带来他的第一部视频作品“一触即发 A Cusp Before It Rings”。这个视频，对日常学校干饭的情景进行真实再现。其中由木稿比你铁饰演的受伤学生受到热烈关注，其原型是初中部的一位学生，我们将其镜头化，力求最真实地表现出其强烈的反差感。 禁止用于商业用途，转载请注明出处 DC Doujin。 Copyright © 2023 DC Doujin, JustPureH2O. All Rights Reserved.","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"《原神》枫丹语言考究","slug":"fontainish-research","date":"2023-11-05T02:59:02.000Z","updated":"2023-11-05T04:30:50.613Z","comments":true,"path":"2023/11/05/fontainish-research/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/fontainish-research/","excerpt":"","text":"起因 这天月假，当我正为即将到来的水神池子疯狂做任务屯原石时，在列表里看到了一个悬赏整整30原石的世界任务。本着不放过任何一个给原石的任务的宗旨，我来到了秋分山西侧，白淞镇东北方向的海边房屋处。只见一位男子全身掩埋在海沙之下、动弹不得，面前摆放着一只散发香味的甜甜花酿鸡。我看他精神失常，满嘴都是“新型美容方式”的胡话又哭又闹，呜呜呜呜，好可怜呀。于是我决定帮他一把……找出了幕后黑手，此时他举起一个木牌，只见上面用老米祖传的架空文字写了一些东西，随着剧情推进，我们得知这是“抗议”（protest）。枫丹作为两个月前才开放的新国家，其文学文化充满乐子的xxs神明固然吸引了我。于是我决定用手头上有限的图片资料，整理出一份类似于枫丹语言图鉴的资料来。以便后期深入探究枫丹的风土人情。 初探 这是在上一部分中提到的，写有“抗议”（protest）的木牌，其中各个字母的对应关系已经标注出来了（相信不用标注也看得出来）。不难发现，最后一个字母与倒数第四个字母是相同的，恰巧对应上protest中字母t的位置。某种方面上证明了这一猜测的正确性，但是鉴于这抽象到与原英文字母完全不搭边的枫丹字体~~（很水体）~~实在是太过亮眼，我的内心还是有一点怀疑和否定的。那么我们将这七个字母挨个抽取出来，放到别的语境中去转译，不就可以验证它的准确性了吗？ 其实也无需这么麻烦，读完前面的大佬对提瓦特通用语的解析。我们惊奇地发现，这很水体居然与提瓦特通用语的字母如出一辙： 图片来源于：哔哩哔哩，语颂源，【原神考据】提瓦特通用文 当然也有一些变化，比如哪里可能突然多出来一横、又或者是将圆弧形的笔画变得棱角分明。图中的S和E就是两个典型例子。考虑到可能是手写体带来的美化、钝化等，我接下来去到了枫丹的主城区中，分别在蒸汽鸟报社、卡郎代沙龙前拍下了这几张图片~~（因为他们离锚点非常的近，不需要跑图）~~。 我们根据已经解译出来的提瓦特通用语字母进行对拍，发现蒸汽鸟报社的招牌上写着：LOISEAU DE VAPEUR。明显是法语，但是其中的VAPEUR和英语的VAPOR（蒸气）非常相似，因此对拍基本无误。但是由于我本人不懂法语，解释不了第一个词，只能求助于度娘。度娘也是给我甩了一个解释：鸟。并纠正了一个小错误：LOISEAU应为L’OISEAU。完美契合蒸汽鸟报社的招牌。 同理，卡郎代沙龙的门牌上写着：CARITAT。推测其原型是18世纪的姓氏德·卡里塔，孔多塞侯爵（Nicolas de Caritat）的妻子便是18世纪的一位著名沙龙主人。 最后放出蒸汽鸟报社门前牌子上的翻译： Exploring the manufacture of security machinery 探秘发条机关（守卫机器）的制造流程 Joyous tour through the aquatic workshop 水下工坊快乐一日游游记 Exclusive compilation of the past top duellists 旧时顶级决斗代理人的独家专访合集 Interview with the deboard restaurant artists 采访德波饭店的艺术家们 Iridescene tour and the new trend of music 虹彩巡游之旅，以及新派音乐","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"}]},{"title":"常用算法模板","slug":"common-algo-templates","date":"2023-10-28T06:11:51.000Z","updated":"2023-11-05T02:33:44.995Z","comments":true,"path":"2023/10/28/common-algo-templates/","link":"","permalink":"https://justpureh2o.github.io/2023/10/28/common-algo-templates/","excerpt":"","text":"1. Trie树（字典树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int son[N][70], idx = 0, cnt[N];int map(char c) &#123; // 字符映射到对应数字 if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return c - &#x27;0&#x27;; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 11; if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 37;&#125;void insert(char s[]) &#123; // 插入一个字符串 int len = strlen(s); int p = 0; // 指针 for (int i = 0; i &lt; len; i++) &#123; // 遍历字符串中每一个字符 int u = map(s[i]); // 映射到数字 if (!son[p][u]) son[p][u] = ++idx; p = son[p][u] // 更新指针，指向下一个节点 &#125; cnt[p]++;&#125;bool query(char s[]) &#123; // 查询一个字符串 int len = strlen(s); int p = 0; for (int i = 0; i &lt; len; i++) &#123; // 遍历+查找 int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return false; &#125; return cnt[p];&#125;int count(char s[]) &#123; // 对指定字符串计数 int len = strlen(s); int p = 0; // 可以用 if (query(s)) 代替下边的遍历查找 for (int i = 0; i &lt; len; i++) &#123; int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return 0; &#125; return cnt[p];&#125; 并查集 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int p[N];int find(int x) &#123; // 查找父节点+路径压缩 if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;void merge(int a, int b) &#123; // 合并两个集合 p[find(a)] = find(b);&#125;bool query(int a, int b) &#123; // 查询两个节点是否在同一个集合中 return find(a) == find(b);&#125; 单调队列 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];deque&lt;Node&gt; q;void peak(int k) &#123; // 查找区间最值，n为数组大小，k为区间大小，即区间中有k个元素 for (int i = 1; i &lt;= N; i++) &#123; // while (!q.empty() &amp;&amp; nodes[i].val &lt;= q.back().val) q.pop_back(); // 查找区间最小值，将大于号改为小于号 while (!q.empty() &amp;&amp; nodes[i].val &gt;= q.back().val) q.pop_back(); // 当新进元素大于队尾元素，删除队尾直到队尾大于新元素，或者直到队列为空 q.push_back(nodes[i]); // 将新进元素压入队尾 if (i - q.front().idx == k) q.pop_front(); // 滑出队头元素所在区间，弹出队头 if (i &gt;= k) cout&lt;&lt;q.front().val&lt;&lt;endl; &#125; &#125; 单调栈 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];stack&lt;Node&gt; stk;int ans[N];void NGE(int k) &#123; // 查找下一个更大的元素，即NGE问题 for (int i = 1; i &lt;= N; i++) &#123; // while (!stk.empty() &amp;&amp; nodes[i].val &lt; stk.back().val) // NSE问题，下一个更小的元素，仅改变大于小于号 while (!stk.empty() &amp;&amp; nodes[i].val &gt; stk.top().val) stk.pop(); // 将栈顶比当前更小的元素弹出 if (stk.empty()) ans[i] = 0; // 查无 else ans[i] = s.top(); // 顶为最大 stk.push(nodes[i]); // 压入当前 &#125; &#125; 单源最短路径 朴素Dijkstra 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稠密图，使用邻接矩阵存图int g[N][N], dist[N];bool st[N];int n; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 dist[1] = 0; // 起点最短路径就是0 for (int i = 1; i &lt;= n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; // 循环所有未确定距离的点，找出最小值 &#125; st[t] = true; // 标记访问 for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); // 间接的路径：从起点经t再连接到j点 &#125; &#125;&#125; 单源最短路径 堆优化Dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稀疏图，使用接表存图int head[N], e[N], w[N], ne[N];int idx = 0;void add(int a, int b, int x) &#123; idx++; e[idx] = b; w[idx] = x; ne[idx] = head[a]; head[a] = idx;&#125;int dist[N];bool st[N];int n;typedef pair&lt;int, int&gt; PIR; // 二元组存储点序号-距离 priority_queue&lt;PIR, vector&lt;PIR&gt;, greater&lt;PIR&gt; &gt; heap; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 heap.push((PIR) &#123;1, 0&#125;); // 初始点入队，序号为1距离为0 while (!heap.empty()) &#123; // 堆不空时 PIR t = heap.top(); // 优先队列，队头元素总为未确定点中最近的一个 int id = t.first, dis = t.second; if (st[id]) continue; for (int i = head[id]; ~i; i = ne[idx]) &#123; int j = e[i]; // 边终点 if (dist[j] &gt; dis + w[i]) &#123; dist[j] = dis + w[i]; // 更新最短距离 heap.push((PIR) &#123;j, dist[j]&#125;); // 更新的点压入优先队列 &#125; &#125; &#125;&#125; 背包类动态规划 01背包 想象你在一个绝版手办售卖会上。这里的每种手办由于需要保证它的稀有程度，活动主办方提前向卖家商议了一个计策：即保证每种老婆 手办有且只能有一个。这样他们就可以开出天价 （但要保证在物价局划定的价格上限内） （爆long long也没问题！）。那么作为一个资深 御宅 手办收藏家的你，自然不会错过这次难得的机会，你出门时偷偷拿走了麻麻の钱包，发现里面有NNN元现金（假定你不知道麻麻の银行卡密码），那么你可以买到手办的最大价值是多少？ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = c; j &gt;= v[i]; j--) &#123; // 倒着循环，c为容量上限，防止做减法时减为负数内存异常 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 但是最后还是被麻麻发现力（悲 背包类动态规划 完全背包 这种问题类似于西方魔幻小说里的情节：一位勇士无意间闯进了古代君王的藏宝阁，受金钱和权力的蛊惑。看着地上不尽的金币与皇冠，他拿出了一个麻袋。他想要在麻袋规定的最大容量内装尽可能最大价值的物品，超出规定容量，这个袋子很可能破掉，导致财宝落入山谷、沼泽等任何危险的地方。这位勇士十分谨慎，他不希望总重量超过额定重量，那么他能装的最大物品价值是多少？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; // 完全背包，即每个物品数量有无限个，可以自由装配 for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = v[i]; j &lt;= c; j++) &#123; // 正着循环，与01背包相反，c为容量上限 // 由于计算当前状态需用到dp[j-v[i]]状态，若升序循环，这个状态总会在前几步被算出 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 // dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) // 若不选择当前物品，最大价值为dp[i-1][j]，即前一个/i-1个物品，容量上限为j (j&lt;=c)时的最大价值 // 若选择当前物品，最大价值为dp[i][j-v[i]]+w[i]，因为每种物品可以放入无限个，放入第i个物品后仍然可以继续放入相同物品直到超出容量上限j &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 然而我们的勇士痴迷于装入财宝，忽视了高悬在他头顶的致命机关，随着绳子断裂，我们的勇士就此葬身于这个隐蔽的藏宝阁中，带不走任何一枚金币。因此我们的最大价值应该是000 因此我们应该拒绝这种来历不明的诱惑，青少年反诈，从我做起！ 背包类动态规划 多重背包 《竞赛班传奇》 第一部，第一幕 人物：“和蔼可亲滴”福建籍物理竞赛教练 茂华；“偷奸耍滑的”山东老家OIer 国祯；“热心尽职喜欢让同学们多多预习物理知识的”物理课代表曹牧 茂华上场，开玩笑的语气说 茂华： 电荷量滴单位是~库 仑，符号C（写下一个大C），艹！ 全班哄笑，国祯猥琐的笑，茂华眉头一蹙，表情严肃，严肃语气 茂华： 国祯！还在那里笑，曹牧，检查一下国祯有没有记笔记！ 曹牧起身走向国祯，其他人目光盯着曹牧，国祯将物理书翻开，指着笔记处，曹牧低头查看，然后抬头 曹牧： 他写了，但是…… 严肃的，急速的，愤怒之极的，气震寰宇的，振聋发聩的，势如破竹的，响彻云霄的，如雷贯耳的，不共戴天的，耳机党爆炸的，外放党社死的 茂华： 站起来！没写笔记！ 国祯吓一跳，乖乖站起，曹牧缓缓退回，众人起哄国祯，茂华声音略小 茂华： 在这里偷奸耍滑是会被刷出去滴。到时候你竞赛搞不好，高考也考滴西撇，看你到时候怎么办！ 国祯： （解释的语气）我没有偷奸耍滑！ 茂华语气有所缓和 茂华： 那你把这道题解出来，你就可以坐下了 题面： 给定NNN个物品，背包最大容量CCC。对于第iii种物品，给定每个iii种物品的大小ViV_iVi​，价值WiW_iWi​，以及个数SiS_iSi​，试求出背包可以装下物品的最大价值AAA。 国祯小嘴一撇，这还不简单？他立马拿起了一支0.5mm的黑色签字笔在草稿纸上飞速演算。得益于他积累了一坤年的OI知识，2分钟后，在众人惊异的目光中，国祯自信满满地拿出了写有正确答案的草稿纸。他将右手伸得十分用力，好像要把草稿纸怼到茂华脸上一样，他的嘴角浮现出一抹byd笑容。 只见茂华呆立原地，嘴巴微张，如同按下了暂停键。3秒钟的寂静过后，下课铃如同国祯的战鼓一般敲响，宣告这次对决以国祯的大比分取胜而落下帷幕。茂华直立的双腿尴尬的向门口转去，颤抖的双唇之间轻飘飘冒出了两个字：“下课”。随后咬紧嘴唇，一步一步踱向门外。 国祯如获新生。在众人崇拜和惊诧的目光中，他迷失了自我，他快步走向一体机，熟练地打开希沃白板，好像已经练习过成千上万遍似的，将一句话加粗写在了白板上： 通常情况下，多重背包的思路是将一堆A物品拆分成n个A物品，每个物品只能使用一次，便可转化为01背包问题 他不管大家是否了解01背包的含义，他此刻只想在众人面前分享打败茂华的喜悦感，以及打败茂华所需要的知识，这又何尝不是一种爱屋及乌的思想呢？ 第二天，当上午的物理课准时来到，茂华却没有准时跨进教室的门。通常情况下，他每次课前都会提前2分钟来到教室里对同学进行题目过关。 1分钟后，茂华挟着几本不合身份的普及组信息竞赛导论及考纲，昂首阔步地走进了一班教室。他大声说着：“通常情况下。这是国祯同学昨天下课后给你们上的课里的一句原话！” 原来茂华前一天下课后并没有跑回办公室又哭又闹大发牢骚，而是现场网购了信息竞赛教程，准备在第二天的物理课上给国祯单独上节课：学生是永远无法击败老师滴！ 他打开了浏览器，输入一行神秘的IP地址，按下回车，一个界面清爽的网站跳了出来。顶端用紫色的大写字母写着MHOI四个大字。 “牛逼吧，这是我连夜赶工自创的网站，”他笑着打开了题目列表中的第一道题，标题： 国祯接招 。国祯轻蔑地瞥了一眼，题干还是昨天那样，一模一样，“看好了国祯，”他指向下排的一行小字，“数据范围：n≤10000n \\leq 10000n≤10000！看你那吃了食的小脑袋还能不能算出这道题目。” 显然，茂华是有备而来，国祯倒吸一口冷气。手工计算绝对是行不通了，但是对于竞赛班的高思娃国祯，绝对是有两把刷子的，毕竟正如茂华所说：“偷奸耍滑耍小聪明早就被刷下去了”。 面对如此巨大的物品总数，一些牛逼娃想到了用二进制拆分表示物品个数的方法。尽管换汤不换药，本质还是一个01背包问题，但是经过祖先们灵魂的注入，茂华是肯定不敢把你踢出竞赛班滴。 ForExampleFor ExampleForExample 假设原有10个价值为2的物品，将10分为1+2+4+3，等同于有4个不同的01物品，价值分别为12=2，22=4，42=8，32=6，即2，4，8，6 国祯很快在VSCode上写出了一段教科书式的、注释易懂的模板代码，这次就算是物竞数竞化竞生竞的人也可以轻易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int idx = 0;// 记录数组下标 int main() &#123; int n, c; cin&gt;&gt;n&gt;&gt;c; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; // v w n // 即体积，价值，个数 cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k = 1; // 记录2的幂，初始值为2的0次幂，即1 //if (s == 0) s = INF; // 当题目中说数量0时默认为无限次时可以使用，这其实已经属于混合背包（多重+完全）的范畴 while (k &lt;= s) &#123; // 个数可以继续被分解 s -= k; // 更新个数 idx++; // 新的下标 v[idx] = a * k; // 分解后该物品的大小 w[idx] = b * k; // 分解后该物品的价值 k *= 2; // k更新为2的下一个幂 &#125; if (s) &#123; // 若无法被完全分解，剩下一部分 idx++; // 记录新的下标 v[idx] = a * s; // 大小 w[idx] = b * s; // 价值 &#125; &#125; // 01背包模板 for (int i = 1; i &lt;= n; i++) &#123; for (int j = c; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 国祯长舒一口气，这次他又获得了胜利。评测点加载了几秒。国祯定住了，#10号点出现一个大大的WrongAnswerWrong AnswerWrongAnswer。国祯感觉堕入了万丈深渊，只见茂华狂笑了起来，带动全班其他同学的笑容，一班霎时被笑声吞没。国祯盯着评测信息，783ms783ms783ms的运行时间让他更为疑惑，莫非茂华手动写了一个错误答案？ 国祯尴尬的转向各位同学，其他同学瞬间停止了笑容。先前还在交头接耳的同学们如同机器一般齐刷刷的转向国祯，给人一种惊悚透骨的感觉。他们异口同声张开了嘴，在茂华扭曲的笑容下，说出了让国祯后悔了一辈子的话来： “三年OI一场空，不开long long见祖宗！” OVER\\mathcal {OVER} OVER 背包类动态规划 混合背包 混合背包，顾名思义。它混合了多种背包，实际应用中这一类问题比较有现实意义。主要思路是，将分属于各个类型背包的物品用几个条件判断语句写出来，然后分别套用各类背包的解决方案进行求解。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (A) &#123; // 01背包物品，写01背包模板 &#125; if (B) &#123; // 完全背包物品，写完全背包模板 &#125; if (C) &#123; // 其他…… &#125; &#125; return 0; &#125;","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"}]},{"title":"国祯文集","slug":"gz-articles","date":"2023-10-26T09:29:45.000Z","updated":"2023-11-04T08:27:07.535Z","comments":true,"path":"2023/10/26/gz-articles/","link":"","permalink":"https://justpureh2o.github.io/2023/10/26/gz-articles/","excerpt":"","text":"曾茂华到底有多六 ——By 国祯 曾茂华是中国当代著名的科学家和教育家，他以“慈父”、“良师”、“学者”等称号闻名于世。 1：曾茂华的蠢行为 曾茂华的蠢行为: 他在大学期间参加了一个乐队，并担任主唱。然而，不幸的是，由于自己的疏忽，他犯下了一件愚蠢的事情——用刀砍掉了对方的手指头。这件事让他成了学校里的头号人物之一。从那以后，他再也不敢做任何愚蠢的事情了。这是因为他害怕自己会被开除出乐队或者成为众矢之的的对象。如果他继续做出这些错误的举动，那么他会失去自己的乐队成员资格，甚至还会遭到开除。所以，为了避免发生这样的悲剧，他必须要记住：永远不要犯错！ 2：为什么他会做出这种愚蠢的事情? 曾茂华的蠢行为发生在他身上，是因为他自己没有意识到他自己的愚蠢。他不知道怎么做才能让事情变得更好，他只想走捷径，而不是去努力做好事情。这种心态会导致他做出错误的决定，因为他会忽略一些重要的信息，或者选择性地记住某些信息。当我们看到一个人犯了下述三种类型的罪时，我们通常就能预测到这个人会再犯同样的问题：1. 根本不会思考问题2. 一味追求便利3. 盲目模仿别人 3: 该如何面对这个问题? 要想解决问题,首先要认识到自己的行为是愚蠢的。只有当你明白自己做了什么蠢事时,才能够改变你的行为来避免这种错误。其次，不要让别人知道你所犯下的错误。这并不是因为你不想坦白自己所犯错误,而是因为这样会给别人带来困扰。最后,如果你真的想要解决这个问题,可以尝试通过一些有趣的方式来实现它。例如,你可以去找一位专业人士帮助你分析一下这件事情,或者试着去找到一个愿意与你分享观点和建议的人。总之,如果你认为自己的行为很蠢,那么就要大胆地承认出来。只有敢于直面自己的无知,才能真正地改善自己的生活。 曾茂华先生不仅对科学领域做出了巨大贡献，而且为国家培养出一批优秀的人才。这些人中不乏有牛顿这样伟大的人物，也有王选这样杰出的人物。","categories":[],"tags":[{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"CSP-J 2023 游记","slug":"journey-to-the-cspj2023","date":"2023-10-24T08:21:36.000Z","updated":"2024-01-07T03:33:37.020Z","comments":true,"path":"2023/10/24/journey-to-the-cspj2023/","link":"","permalink":"https://justpureh2o.github.io/2023/10/24/journey-to-the-cspj2023/","excerpt":"","text":"又名：《第一次考就被小学生薄纱的一集》 本次考场：绵阳东辰国际学校 第一节 赛前准备 插一句：CSP-J 2023没有设置赛前试机环节（包括CSP-S，成都绵阳都这样），个人推测可能是由于开放自选Windows和Linux系统带来的结果。如果你听见诸如：不要操作电脑，违者将作作弊处理 的话时，请将你按捺不住的双手安稳的放在双腿上，避免出现意料之外的事来。 然而赛前试机仍然是必要的一环（但是如果考场纪律有要求那就算了），因为这样可以让选手对机器有一个初步的了解。因为我本人习惯使用Win+E打开文件系统管理器，用Win+V记录剪切板数据，可是这些功能在考场电脑上都无法使用，进行赛前试机不仅可以避免因赛时临时发现无法使用某些功能而带来的苦恼心态爆炸点+1，而且还可以将IDE环境调整到个人喜欢的状态（例如缺省源代码，相当于每次新建代码不用重新打头文件）。选手可以不占用正式比赛时间完成一些个性化操作，方便赛时操作，其重要性不言而喻。 当然，开赛前乱猜试题PDF密码是极其无意义且几乎不可能成功的一件事，更不要使用暴力破解密码工具破解文件（相信守规矩的你也不会将这种工具带进考场里来），这么做不仅会被当做作弊者处理，而且造成的数据丢失也只能由你自己负责。 第二节 开赛之初 考场下发的PDF文件带有密码保护，输入时请务必瞪大眼睛区分大小写字母O、o与数字0；小写字母l、大写字母I与数字1，并且将其中的特殊字符认真核对一遍。本次考试，我有幸将密码中的数字0写成了小写字母o，于是浪费了宝贵的2分钟时间改正密码（真实情况是监考老师在黑板上书写密码时字迹不规范导致的混淆）。因此需要认真看好你的密码。 就我认为：在一开始就仔细写好文件重定向输入输出是极其重要的，因为随着考试时间的推进，你的思考重点将从细节性问题变为如何拿到更多的分数上骗分。你就会忽略重新写上两行重定向IO的代码，因而可能Au-&gt;Cu，光荣AFO。为了引起你的注意，使用极长的注释双斜线是可行的，我本人习惯打上断点。例如： 12//////////////////////////////////////////////// freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//////////////////////////////////////////////// freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 将比 12//freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 显眼得多——尤其是当你喜欢为每行代码写上包含心血的易懂注释时。事后你可以通过长按Ctrl+逗号（Dev-C++）的方式快速且安全的删除这些斜线。 不仅如此，看好输入输出文件名也是一个非常重要的细节，建议直接复制粘贴。对于标准样例，直接选中PDF文字再复制一般都不是一个明智的做法，手动输入也是可行的，但是对拍有时会比较繁琐（例如普及组T3的样例）。这边传授一个方便的做法：选中代码左侧序号，在WPS中直接右键菜单点击消除文字即可（本次考试我就是使用的这个方便技巧快捷复制样例数据）。最好找张纸记下来，后面会讲到原因。 顺利解锁了PDF文件，你要做的第一件事就是将四道题全部读熟。对整场比赛的题目有大致的规划，有可能你先前做题时做过与T4极其相似的题目，那么放弃显然是一个很不划算的决策。将题目读熟，大概判断一下算法实现，评估自己哪些题能做好，哪些题要放一放/完全放弃。知己知彼方能百战百胜。 赛初的状态基本上决定了你整场比赛的表现，因此在赛初就做好一切细节方面的完全准备，对你的信心增长是非常重要的！ 第三节 赛中时期 那么你现在拿到了第一题（信心题）。一般来说，CSP的复赛，算法很少裸露地出现在题目之中，前两题近似看作数学题。保证你的数学思维在线，因为第一题的思路可能千奇百怪，如果你一段时间没有思路（对于第一题大概是5~15分钟），可以考虑先做其他题目。刷新一下思维定势，有可能T1的灵感就乍现于其他题目之中。 在符合时间规划的前提下尽可能多去造hack数据，写出一段代码（尤其是T3放大模拟时）后，千万保证没有任何逻辑问题。当然，不是所有人都能只看代码就能检查的出其中的逻辑漏洞。因此你需要多造hack数据。hack数据多数情况下包括这几个要素：方程的特殊解、极端值/边界值、大数据（int越界）。在规划好的时间内想尽办法为你的代码多挑几根刺出来，你的代码才能更加趋近于满分解。 千万不要看你旁边的人！！！ 除非S组巨佬闯进了J组蒟蒻区，否则千万不要在比赛中途去看任何人的任何行为。一方面，你的行为可能被视作交谈作弊喜提CCF全国通报、禁赛3年大礼包；另一方面，如果你抱着嘲笑别人的心态去观察别人，那么你的脸很可能就会被你自己打烂。我在考试时因为瞧不起隔壁的一位小学生，当他开始疯狂敲代码时，我自己的心态就爆炸了——把所有人，不分男女、年龄高低，都当作你的敌人，轻视则死。同时这也给你带来一部分紧张感，会使你的发挥更佳。 给自己适当的放松与勉励，要相信，上天不是无故给你这个周末不用冒着风雨大太阳上补习班的珍贵机会（对于高中生，则是周六不用坐在教室里上正课的机会）。当你完全确认你的代码已经完美无瑕时，告诉自己：*同学们都还在悲催的上着课，我却在外边快乐的敲着代码。*如此一来可以起到调整心态的作用。 别激动到顺手关了PDF文件。如果你还记得或者是在草稿纸上写了密码，那无所谓；但是如果你没写，你的处境就非常尴尬，这时你可以举手找老师再要，但这绝对对你的心态是一个不小的打击。 第四节 赛末时期 经历三个半小时的不懈奋斗，比赛终于迎来最后的半小时。无论你的完成情况如何，一定要用这最后的时间好好检查一下你的代码。瞄一眼你是否有与下面类似的代码： 12freopen(&quot;uqe2.in&quot;, &quot;r&quot;, stdin); // 危freopen(&quot;uqe2.out&quot;, &quot;w&quot;, stdout); // 爆零警告 这段代码的主人是个懒人无疑了，如果你把CCF提供的附加样例复制了出来。切记最后把文件名里的序号删除，否则你就可以AFO了。 或者以下的代码： 1234#include &lt;Windows.h&gt;//其他的代码if (system(&quot;fc uqe.out uqe.ans&quot;)) cout&lt;&lt;&quot;WA&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;AC&quot;&lt;&lt;endl; 这位同学也是个Windows爱好者受害者无疑了，CCF明文规定了测试用系统为NOI Linux。因此不存在Windows.h这个头文件，如果你忘记删除了，那一定是个大大滴CE。正式比赛时，用bits/stdc++.h万能头即可(Windows和Linux通用）。我有一个考S组的朋友，因为忘记删除这个对拍头文件而喜提一个0分，直接亏大发。 不要忘记将你的重定向取消注释。你连读入输出都没有了，属实是可以AFO了。最后三分钟，请将你的蹄子挪开键盘鼠标。否则可能会越改越慌，不妨好好回想一下这周老师留了什么作业，你缺了哪些课需要去补，总之不要再动你的鼠标键盘了！如果实在是不放心编译问题，按一下F11，通过即可。保证你的工作目录下只留.cpp文件，所以将你复制的样例文件和编译的exe文件全部删除。 第五节 考试结束 请你千万保持冷静，不要习惯性地把机器关机了。CCF明文规定：由关机造成的数据损失，责任由考生自负。只需要把你的IDE关闭就好。 回家后，把周一要交的作业补好。别再谈考试的事情了，让你自己有个好心情。毕竟不管你的表现怎么样，它都过去了不是吗？","categories":[],"tags":[{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}],"categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}