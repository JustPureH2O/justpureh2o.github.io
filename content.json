{"meta":{"title":"JustPureH2O的博客","subtitle":"深水摸大鱼","description":"JustPureH2O的小窝","author":"JustPureH2O","url":"https://justpureh2o.github.io","root":"/"},"pages":[{"title":"","date":"2024-01-06T08:32:47.655Z","updated":"2024-01-06T08:32:47.655Z","comments":true,"path":"404.html","permalink":"https://justpureh2o.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 回到主页"},{"title":"所有分类","date":"2023-11-04T03:04:22.866Z","updated":"2023-10-26T08:58:13.786Z","comments":true,"path":"categories/index.html","permalink":"https://justpureh2o.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-10-26T08:03:52.000Z","updated":"2023-10-26T08:55:42.018Z","comments":true,"path":"about/index.html","permalink":"https://justpureh2o.github.io/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-04T03:04:22.867Z","updated":"2023-10-26T09:06:37.321Z","comments":true,"path":"friends/index.html","permalink":"https://justpureh2o.github.io/friends/index.html","excerpt":"","text":""},{"title":"DC Doujin 同人创作","date":"2023-11-04T08:33:40.000Z","updated":"2023-12-03T05:33:52.933Z","comments":true,"path":"dcdoujin/index.html","permalink":"https://justpureh2o.github.io/dcdoujin/index.html","excerpt":"","text":"DC Doujin 简介 DC Doujin 同人创作（以下简称DCD），由JustPureH2O于2023年11月5日创建。主要发布一些幽默视频，以及对应的幕后纪实。旨在用最真实最还原的镜头记录学校生活的点点滴滴。目前该频道的拍摄、剪辑、发布均由JustPureH2O一人承担，主要演员有木稿比你铁、狂三唯吾所爱 新闻 DC Doujin 2023 EP1 先行预告 DC Doujin 2023 EP1 一触即发 正式发布 演员 1. 木稿比你铁 DC Doujin 2023 EP1 拍摄前 2. 狂三唯吾所爱 （左侧）DC Doujin 2023 EP1 拍摄时"},{"title":"机房管理助手 v9.x已成功破解","date":"2023-12-24T00:45:33.000Z","updated":"2024-01-06T06:51:10.844Z","comments":true,"path":"misc/index.html","permalink":"https://justpureh2o.github.io/misc/index.html","excerpt":"","text":"任务管理器已解禁，您也可以自由使用注册表和组策略进行其他操作"},{"title":"高2023级一班热梗总结","date":"2023-11-04T08:33:30.000Z","updated":"2024-01-07T03:51:18.574Z","comments":true,"path":"memes/index.html","permalink":"https://justpureh2o.github.io/memes/index.html","excerpt":"","text":"2023.9 1. 吃饱啦 九月初的某节语文课，当语文老师问及苏轼的个人形象时，国祯和小又肥同时说出了“优雅”二字，国祯更是以一个屁总结了自己的观点。此后不久，国祯和冰正在激烈地讨论老八秘制小汉堡的事情，正当所有人因为思考语文老师提出的问题而陷入短暂沉寂时，冰向后一靠，把手垫在脑后，说了一句：“吃饱啦！”。便如此得名。 2. 电饭煲 国祯表示历史老师长得很像电饭煲，于是得名 3. 干饭 9月4日，一班真正意义上进行了一次以教室为起点的干饭行动，基本上一分钟内能够到达食堂。 4. Global Reading 张伟水课的新型套路——不讲正课天天喊我们拿出Global Reading来看，久而久之成为英语课和扣分的代名词。 5. 手套月饼 9月28日周四晚，东辰组织制作月饼，有人在月饼里放狠料咖啡粉、硬币、长尾夹（后被取出）。事后国祯将此事传开，被茂华得知，被张伟处分。 6. 巨人熊猫，孔子牙膏（富兰克林，酱香瑞幸） 张伟最爱罚背的几篇Global Reading上的文章，国庆放假前被总结为这句口头禅 2023.10 7. 奖励 张伟扣分前的口头禅，后演变为罚背的代名词"},{"title":"所有标签","date":"2023-10-26T08:56:08.000Z","updated":"2023-10-26T08:57:03.066Z","comments":true,"path":"tags/index.html","permalink":"https://justpureh2o.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"这魔术，我约瑟夫秒了！","slug":"magic-show-with-josephus","date":"2024-02-10T08:23:45.000Z","updated":"2024-02-10T11:21:28.619Z","comments":true,"path":"2024/02/10/magic-show-with-josephus/","link":"","permalink":"https://justpureh2o.github.io/2024/02/10/magic-show-with-josephus/","excerpt":"","text":"（操作没成功の尴尬，图片来自知乎） 前言 这篇文章从数学方面推导刘谦2024年央视春晚上表演的第二个魔术的秘密、分析尼格买提错误之处，并在已知信息的加持下尝试推测尼格买提手上所剩的两张半面扑克牌的牌型。有一说一撒贝宁是真的会测假 对应魔术节目：《守岁共此时》的回看请戳这里，在一小时十分整处。 魔术步骤 四张牌面向下，并打乱。 对折四张牌，并沿折痕撕开，得到两批半牌，每批四个共八个半牌 （反过来折是为了方便撕开）。将左右手的两批牌按同一个方向叠在一起。 根据自己名字的字数，从上端挨个拿出一个牌放到最底端，执行字数次。 拿起最上面三张，插进其他牌的中间（意思是这三张看作一个整体，不能放在最上面或者最下面，必须夹在其他牌中间）。 拿起最上边的牌，藏起来不要看魔术常规操作之不要看。 继续从最上边拿牌：南方人拿一张、北方人拿两张、不确定就拿三张。然后像第四步那样插进中间位置。 还是从最上边拿牌：男生拿一张、女生拿两张。然后将拿出的牌扔出去。 「见证奇迹的时刻」——每一次操作，将最上边的牌移到最下边，每次仅移动一张牌，进行七次。 「好运留下来，烦恼丢出去」——对于每次操作：第奇数次，将牌移到最下边；第偶数次，丢出去。最后直到只剩一张牌 最后拿出藏起来的牌，如果你的名字在四个字及以内、且操作无误，你会发现这两张半牌是严丝合缝的，他们可以拼成一张牌！ 列数模拟 先不管你拿了哪几张牌，也不管打乱前它们的先后顺序如何——因为它们都跟魔术本身、也和我们的推导无关。我们只着眼于打乱后的牌，将它们按照上下依次编号为1~4。如下图： 1234 沿折痕撕开，假设第1号牌撕成的两张半牌编号为1和A（数字在上字母在下），八张半牌叠在一起，得到的牌堆是这样的： 1234ABCD 接下来的推导就围绕上面这个牌堆开展。 对应第三步——从上边拿出和自己名字字数相同的牌，放到最下边。假如我拿出三张，也就是编号为1、2、3的三张牌，放到最下边。牌堆变成这样： 4ABCD123 第四步——再拿出最上边三张牌，卡到中间去： CD4AB123 第五步——藏起最上边的牌，也就是编号为C的牌。 第六步——根据南北方人拿牌。因为我祖籍北方出生在南方，我这里就拿三张牌插入到中间位置（B和1之间）： ABCD4123 我是男生，丢最上边的一张牌，也就是说丢出编号为A的那张（此时内心默默丢掉了两张牌）： 男：BCD4123 女：CD4123 然后是见证奇迹的时刻。此时男生手里剩下7张牌、女生则是6张。这里其实无需说出那句咒语：如果你是男生，就不做操作；如果是女生，就将最上边的牌放到最下边。 男：BCD4123 女：D4123C 最后是好运留下来、烦恼丢出去。按照规则，我们要轮流进行两个操作：移动最上边的牌到最下边、丢掉最上边的牌。如此操作直到只剩下一张牌。这其中涉及到一个知识点——约瑟夫环问题 约瑟夫环问题 百度百科 约瑟夫问题 简而言之，就是从特定编号出发，每经过nnn个数便将此时的数字挑出，剩下的数重新编号（保证起始编号相同），问最后剩下的编号是什么。这个环节的操作在这个例子下可以被抽象成：从D开始，每两次操作，丢出第二张牌。 也就是说，七个人围成一圈，“1、2、1、2……”的报数，最后剩下的是几号。这里有一个巧算的方法，适用于“1、2、1、2……”报数模型。首先找出不大于人数7的最大的2的整数幂，因为22=42^2=422=4，所以令t=7−4=3t=7-4=3t=7−4=3。当最终剩下2k2^k2k个人的时候，第一个报数的就是最后一个被留下的，因此有公式：2t+1=72t+1=72t+1=7。 对于男生，最后剩下的牌就是最下边的那一个，编号3。 对于女生，剩下的是第2×(6−4)+1=52\\times(6-4)+1=52×(6−4)+1=5个，同样是3。 拿出藏起来的牌C，我们开头就知道了：第三张牌被分成了3和C。也就是说它们可以拼合成同一张牌！魔术成功了！ 回顾总结 不妨从一开始就观察3和C的变换规律，可以发现3号牌自从第三步结束后被移动到最下边以来就几乎没改变过位置；而前四步则是合力将C拉到了最前边好让它被顺利地挑出去。然而最为精妙的还是对“1、2、1、2……”报数约瑟夫环模型的应用。那么为什么尼格买提的操作会失败呢？看下图： 右上角是他的操作：他在“南方人和北方人”的操作里拿了三张牌，但是插入的时候错误将其中两张牌插到了最下边并且这两张牌和另外的那一张牌分开了（原规则是一起插到中间）。 因此这堆牌的底端变成了黑桃Q，不久之前，他藏起了一张黑桃A。所以，他最后拿出的牌是对不上的，一张是黑桃A，一张是黑桃Q。 下面是从班级群里偷的几张图，以实际证明这个理论是成功的： 当然，如果就某位“客串见证人”的失误而大做文章的话，显然是极其招人嫌恶的。刘谦本人的魔术并没有什么问题，尼格买提可能也只是太过关注自己接下来在春晚上的表现而有些分神罢了。如果这个失误真的导致2025年春晚刘谦不被总导演邀请上台的话，这种毫无底线夸大其词的舆论只会是雪上加霜，让所有人更不好过而已……事后小尼本人也道了歉，因此已经没有必要再抓住谁人的过错不放，只是从科学的角度出发，论证这个魔术的成功之处。毕竟少有节目能如此调动起屏幕内外所有人的互动热情，如此看来，刘谦的魔术也是非常成功的了。","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"数学","slug":"数学","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数 简明教程","slug":"linear-algebra-explicit-tutorial","date":"2024-01-21T04:45:07.000Z","updated":"2024-02-10T07:37:16.242Z","comments":true,"path":"2024/01/21/linear-algebra-explicit-tutorial/","link":"","permalink":"https://justpureh2o.github.io/2024/01/21/linear-algebra-explicit-tutorial/","excerpt":"","text":"线性代数 简明教程 前言 我个人认为我自己与线性代数的渊源是极深的。差不多整一年之前，初三上册的寒假，我在启动某二字二次元风格开放世界游戏时偶然做到了一个世界解谜。与平常无脑过的难度不同，这次的解谜可谓是充满血和汗水的教训——看攻略前千万要搞清楚站位和朝向……于是一步错步步错，耗费了整整半个小时才碰巧还原到原始的状态。自此便有了用严格的数学论证来解决这种世界解谜的想法，然而苦于当时数学功底不够、那些线上线下的教程又对我这种“跳级生”极其的不友好，最终还是将它抛到脑后去了。 但是我最开始想做关于线性代数的内容却是在高一上期末那会，刚好我的竞赛内容推进到了高斯消元相关内容，因而我对线性代数的内容有了一定了解。正巧年末购书有优惠，买了一本Steven J. Leon的《线性代数》（原书第十版）自己学习。深谙零基础学生自学的痛苦的我随即就想要上一篇全网最简明易懂的线性代数教程出来，这篇教程旨在让零基础初学者也能吸收学会线性代数的相关知识点。你可以将它理解成上述《线性代数》著作的一个口语版理解和集注，我所做的就是将书中的晦涩的知识自己吸收后转化为易于读者消化的简明概述。也正是因为其趣味性的必需特点，部分科学定义可能在本教程转述时出现细微的偏颇，还请指出，但在编写过程中我会尽量将原书的科学性与本教程的趣味性、通俗性有机融合起来，从而让读者毫不费力地学习线性代数的知识内容，快乐学习。 你谷博客似乎没有可折叠文字块选项，所以开局有这么一大段废话。如果不介意LaTeX公式显示问题的同志们可以到我的GitHub博客学习。 第一章 矩阵与方程组 需要注意的是：本教程中的矩阵表示方法可能与你在课上或是其他教程中看到的有些许出入。为了兼具美观和统一，单行行向量用圆括号包起，变量顶部用向量符号标记，如行向量：a⃗=(1234)\\vec a=\\begin{pmatrix}1&amp;2&amp;3&amp;4\\end{pmatrix}a=(1​2​3​4​)。其余情况均以方括号包起，变量用单一字母或符号表示，如2×32\\times32×3矩阵b=[13−30−40]b=\\begin{bmatrix}1&amp;3&amp;-3\\\\0&amp;-4&amp;0\\end{bmatrix}b=[10​3−4​−30​]。 相信大多数人入门线性代数的第一堂课就是学习如何利用矩阵求解线性方程组的吧。矩阵作为一个仅由数字和括号组成的表示方法，既避免了书写各种未知数符号的麻烦，也能一眼看出各未知量之间的数量关系，实属上乘的表示方法。矩阵的一些特殊性质也可以帮助我们解决一些难以解决的问题。 第一节 方程组与矩阵的互相转化 假设我们有一个方程组：{3x1−x3=8x1−4x2−x3=−1−2x1+x2=5\\begin{cases}3x_1-x_3=8\\\\x_1-4x_2-x_3=-1\\\\-2x_1+x_2=5\\end{cases}⎩⎪⎨⎪⎧​3x1​−x3​=8x1​−4x2​−x3​=−1−2x1​+x2​=5​。首先将所有未知数提到等号左侧，常数全部移到右侧。我们暂时先忽略掉等号右边的常数项。我们将每行未知数的系数提取出来，放入矩阵的第一行，矩阵的第一行就表示方程组中第一个方程的未知数系数（没有默认为0），以此类推到下边几行，最终你会得到一个列数与未知数个数相等、行数与方程个数相等的矩阵。本例中它长成这个样子： A=[30−11−4−1−210]A=\\begin{bmatrix}3&amp;0&amp;-1\\\\1&amp;-4&amp;-1\\\\-2&amp;1&amp;0\\end{bmatrix}A=⎣⎡​31−2​0−41​−1−10​⎦⎤​ 如此得到的矩阵叫做系数矩阵，顾名思义，它只表示了原方程组的系数，而忽略了常数项。它同时也是一个3×33\\times33×3矩阵，一般地，对于一个n×mn\\times mn×m矩阵（n,m∈N+n,m\\in\\mathbb N_+n,m∈N+​），它有nnn行mmm列。 此时，如果我们加上等号右侧的常数项，原先的3×33\\times33×3矩阵会变成3×43\\times43×4的。人们为了区分常数和系数，选择在书写时将常数加入到最右侧那一列，并且在最右一列的前面加上竖线分隔系数，如此得到的矩阵叫做增广矩阵。本例中AAA的增广矩阵形式A′A^\\primeA′写作： A′=[30−181−4−1−1−2105]A^\\prime=\\left[\\begin{array}{ccc|c}3&amp;0&amp;-1&amp;8\\\\1&amp;-4&amp;-1&amp;-1\\\\-2&amp;1&amp;0&amp;5\\end{array}\\right]A′=⎣⎡​31−2​0−41​−1−10​8−15​⎦⎤​ 当矩阵元素不明时（通常是为了举例），我们为了简便表示矩阵本身，采用右下角元素+括号的方式。例如一个i×ji\\times ji×j矩阵AAA，可以写作：A=(aij)A=(a_{ij})A=(aij​)。 第二节 矩阵的基本运算 1. 矩阵加法 仅限构造相同的矩阵，也就是说进行加法运算的两个矩阵行列数必须相同，这样的两个矩阵是同型的。相加时同一行同一列的元素相加即可（增广矩阵同理）。 例如：[1022−13212]+[−2320110−13]=[1−20+32+22+0−1+13+12+01−12+3]=[−134204205]\\begin{bmatrix}1&amp;0&amp;2\\\\2&amp;-1&amp;3\\\\2&amp;1&amp;2\\end{bmatrix}+\\begin{bmatrix}-2&amp;3&amp;2\\\\0&amp;1&amp;1\\\\0&amp;-1&amp;3\\end{bmatrix}=\\begin{bmatrix}1-2&amp;0+3&amp;2+2\\\\2+0&amp;-1+1&amp;3+1\\\\2+0&amp;1-1&amp;2+3\\end{bmatrix}=\\begin{bmatrix}-1&amp;3&amp;4\\\\2&amp;0&amp;4\\\\2&amp;0&amp;5\\end{bmatrix}⎣⎡​122​0−11​232​⎦⎤​+⎣⎡​−200​31−1​213​⎦⎤​=⎣⎡​1−22+02+0​0+3−1+11−1​2+23+12+3​⎦⎤​=⎣⎡​−122​300​445​⎦⎤​ 矩阵加法满足：结合律、交换律 2. 矩阵减法 矩阵减法是矩阵加法的逆运算，因此对于两个矩阵的形式要求同上，只是相同位置的元素相减而已。 矩阵减法满足：结合律、交换律 3. 标量乘法/矩阵数乘 矩阵的数乘也很简单，让矩阵中每个元素乘以这个数就可以了。 例如：4⋅[1022−13212]=[4×14×04×24×24×−14×34×24×14×2]=[4088−412848]4\\cdot\\begin{bmatrix}1&amp;0&amp;2\\\\2&amp;-1&amp;3\\\\2&amp;1&amp;2\\end{bmatrix}=\\begin{bmatrix}4\\times1&amp;4\\times0&amp;4\\times2\\\\4\\times2&amp;4\\times-1&amp;4\\times3\\\\4\\times2&amp;4\\times1&amp;4\\times2\\end{bmatrix}=\\begin{bmatrix}4&amp;0&amp;8\\\\8&amp;-4&amp;12\\\\8&amp;4&amp;8\\end{bmatrix}4⋅⎣⎡​122​0−11​232​⎦⎤​=⎣⎡​4×14×24×2​4×04×−14×1​4×24×34×2​⎦⎤​=⎣⎡​488​0−44​8128​⎦⎤​ 矩阵数乘满足：交换律、结合律、分配律 4. 矩阵转置 矩阵转置就是将原矩阵的行变成新矩阵的列，直观理解就是顺时针旋转90度后再水平镜像过去。转置用上标TTT表示。 例如：A=[1022−13212]A=\\begin{bmatrix}1&amp;0&amp;2\\\\2&amp;-1&amp;3\\\\2&amp;1&amp;2\\end{bmatrix}A=⎣⎡​122​0−11​232​⎦⎤​，则AT=[1220−11232]A^T=\\begin{bmatrix}1&amp;2&amp;2\\\\0&amp;-1&amp;1\\\\2&amp;3&amp;2\\end{bmatrix}AT=⎣⎡​102​2−13​212​⎦⎤​ 矩阵的主对角线（左上-右下）元素转置前后不变，且具有可逆性[(AT)T=A(A^T)^T=A(AT)T=A]、数乘不变[(k⋅AT)=k⋅(AT)(k\\cdot A^T)=k\\cdot(A^T)(k⋅AT)=k⋅(AT)]、分配律[(AB)T=ATBT(AB)^T=A^TB^T(AB)T=ATBT]。 有一类特殊矩阵，它转置后恰好就是它自身。这类矩阵被称为对称矩阵，它是自转置的，即AT=AA^T=AAT=A。对称矩阵的元素恰好关于主对角线对称，并且是一个n×nn\\times nn×n的正方形矩阵。这两条性质是对称矩阵的两个基本性质。 5. 矩阵乘法 该内容将在第二章涉及。 第三节 消元 按照一般思路（就是我们在小学学的方法），我们会选择通过方程互相加减各自的倍数，达到消去未知数的目的。这种方法在矩阵上同样适用，而且它有一个贼高坤的名称：高斯消元法（Gaussian Elimination）。 回忆一下我们从出生就会用的消元原理，我们的目标就是让每个未知数都对应一个常数项，那么它的值就可以直接用常数除以系数的方式求出。矩阵中也是如此，为了能够化简出可直接求解的矩阵，我们在此引入初等行变换的概念： 交换某两行 把矩阵的某一行同乘以一个非零的数 把某行的若干倍加和到另一行 这三条很容易理解。第一条：相当于交换方程组顺序，不影响计算；第二条：相当于对某一行方程放缩某倍，它等价于原方程；第三条：相当于前两条的融合，也是消元的关键一招。这三条规则在之后的初等矩阵内容中会再次出现。 首先从一个例子讲起，让读者感受一下初等行变换的魅力： 考虑这个方程组： {2x+3y=−1…1x−2z=6…2x+2y−4z=−2…3\\begin{cases}2x+3y=-1&amp;\\dots1\\\\x-2z=6&amp;\\dots2\\\\x+2y-4z=-2&amp;\\dots3\\end{cases}⎩⎪⎨⎪⎧​2x+3y=−1x−2z=6x+2y−4z=−2​…1…2…3​ 按照如上所述，将它转写成增广矩阵的形式： (230−11−20612−4−2)\\left(\\begin{array}{ccc|c}2&amp;3&amp;0&amp;-1\\\\1&amp;-2&amp;0&amp;6\\\\1&amp;2&amp;-4&amp;-2\\end{array}\\right)⎝⎛​211​3−22​00−4​−16−2​⎠⎞​ 我们总结一下常用的消元原理，应用到矩阵上就是： 枚举每一列ccc，选出无序组中第ccc列系数绝对值最大的一行ppp，并移到无序组的最上边。（变换规则一） ppp行通过自乘，将第ccc列的系数变成111，并标记ppp为有序。（变换规则二） 通过加减有序组中某一行的非零倍，将之后所有行的第ccc列系数化为000。（变换规则三） 令矩阵A=(2−11141−151110)A=\\left(\\begin{array}{ccc|c}2&amp;-1&amp;1&amp;1\\\\4&amp;1&amp;-1&amp;5\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)A=⎝⎛​241​−111​1−11​150​⎠⎞​（有序组用绿色表示） 枚举第一列，c=1c=1c=1。开始时，所有行均无序。选出绝对值最大的那一项，本例中为第二行，进行移动，原矩阵变为： (41−152−1111110)\\left(\\begin{array}{ccc|c}4&amp;1&amp;-1&amp;5\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​421​1−11​−111​510​⎠⎞​ 第二步，自乘并标记有序，因此第一行除以444，原矩阵就变成了： (10.25−0.251.252−1111110)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​121​0.25−11​−0.2511​1.2510​⎠⎞​ 第三步，将无序组的第ccc列消成000。本例中，我们让第二行减去二倍第一行；第三行直接减去第一行，得到： (10.25−0.251.250−1.51.5−1.500.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\0&amp;-1.5&amp;1.5&amp;-1.5\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.25−1.50.75​−0.251.51.25​1.25−1.5−1.25​⎠⎞​ 枚举第二列，此时c=2c=2c=2。第一步，选出第二列系数绝对值最大的那一行，移到无序组最上端。本例中无需移动，自乘−23-\\frac{2}{3}−32​，标记有序，原矩阵为： (10.25−0.251.2501−1100.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\\\textcolor{green}{0}&amp;\\textcolor{green}{1}&amp;\\textcolor{green}{-1}&amp;\\textcolor{green}{1}\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.2510.75​−0.25−11.25​1.251−1.25​⎠⎞​ 最终的最终，第三行减0.750.750.75倍第二行，得到我们心心念念的化简后的矩阵： A=(10.25−0.251.2501−11002−2)A=\\left(\\begin{array}{ccc|c}1&amp;0.25&amp;-0.25&amp;1.25\\\\0&amp;1&amp;-1&amp;1\\\\0&amp;0&amp;2&amp;-2\\end{array}\\right)A=⎝⎛​100​0.2510​−0.25−12​1.251−2​⎠⎞​ 为什么把矩阵化简成这种金字塔型的形式呢？你会发现：最后一行仅有一个带系数的未知数x3x_3x3​，我们直接求，x3=−1x_3=-1x3​=−1。向上一行，现在x3x_3x3​相当于常数，移到常数中与111合并，x2x_2x2​也可直接求了……经过如上的反代操作，三个未知数都会被求出来。至此我们才发现这个三角形矩阵的魅力之处。 一般地，对于一个矩阵，如果它的非零系数呈阶梯形分布，则称这类矩阵为行阶梯形矩阵。将非零系数挑出来，它们组成的是一个上三角形矩阵；对应地，零项就会组成下三角矩阵。上三角矩阵通常以UUU表示、下三角矩阵通常用LLL表示。 原方程组有唯一解： {x=1y=0z=−1\\begin{cases}x=1\\\\y=0\\\\z=-1\\end{cases}⎩⎪⎨⎪⎧​x=1y=0z=−1​ 第四节 秩 类比一元二次方程的根存在性判别法——Δ\\DeltaΔ判别式法，即对于一元二次方程ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0，根的个数={0b2−4ac&lt;01b2−4ac=02b2−4ac&gt;0=\\begin{cases}0&amp;b^2-4ac&lt;0\\\\1&amp;b^2-4ac=0\\\\2&amp;b^2-4ac&gt;0\\end{cases}=⎩⎪⎨⎪⎧​012​b2−4ac&lt;0b2−4ac=0b2−4ac&gt;0​。那么，矩阵方程是否也有类似的根存在性判别方法呢？ 答案是有的，而且不止一种，这意味着“矩阵是否有解”这样的问题会有多种解决方案。现在介绍的是最为简单常用的一种——秩。 在线性代数中，一个矩阵A的列秩是A的线性独立的纵列的极大数目。类似地，行秩是A的线性无关的横行的极大数目。即如果把矩阵看成一个个行向量或者列向量，秩就是这些行向量或者列向量的秩，也就是极大无关组中所含向量的个数。 ……咱们抛掉这种看也看不懂的高级语文句法，听我给你总结： 通俗来讲，把一个矩阵化成最简形式（特指行阶梯形）后，非零行的个数就是矩阵的秩。这其实是秩的最大线性无关组的定义。再次白话总结：如果存在三个行向量（列向量一样的，保证所有向量都是行/列向量即可）：a⃗=(1,2,3),b⃗=(2,4,6),c⃗=(−1,0,5)\\vec a=(1,2,3),\\vec b=(2,4,6),\\vec c=(-1,0,5)a=(1,2,3),b=(2,4,6),c=(−1,0,5)。根据高中数学中立体几何的知识——a⃗\\vec aa和b⃗\\vec bb显然是共线的（就是值的最简比相同，本例中均为1:2:31:2:31:2:3）像这样共线的两个向量，拉到线性代数中就说他们是线性相关的；反之是线性无关的，例如本例中a⃗,c⃗\\vec a,\\vec ca,c和b⃗,c⃗\\vec b,\\vec cb,c这两组向量互相不共线，它们互相都是线性无关的。 矩阵AAA的秩用R(A)R(A)R(A)表示[r(A)r(A)r(A)、rk(A)rk(A)rk(A)、rank Arank\\;ArankA、rank(A)rank(A)rank(A)等均可]。 现在明白了吧，如果一个矩阵的某两行线性相关，它们都会被初等行变换第三条狠狠薄纱——在乘/除一个非零数后相减，其中一行就会被全部消成0，从方程组角度来看就是0x1+0x2+⋯+0xn=0,n∈N+0x_1+0x_2+\\dots+0x_n=0,n\\in\\mathbb N_+0x1​+0x2​+⋯+0xn​=0,n∈N+​，带什么值都成立（相当于浪费了一行）。 当然上边这一段也有表述不准确之处，假设有一个增广矩阵A=[12322463−1054]A=\\left[\\begin{array}{ccc|c}1&amp;2&amp;3&amp;2\\\\2&amp;4&amp;6&amp;3\\\\-1&amp;0&amp;5&amp;4\\end{array}\\right]A=⎣⎡​12−1​240​365​234​⎦⎤​。初等行变换第三条秒了第一、第二行，然而事情有些不对劲了…… A′=[1232000−1−1054]A^\\prime=\\left[\\begin{array}{ccc|c}1&amp;2&amp;3&amp;2\\\\0&amp;0&amp;0&amp;-1\\\\-1&amp;0&amp;5&amp;4\\end{array}\\right]A′=⎣⎡​10−1​200​305​2−14​⎦⎤​ 第二行不乐意了，它还存留这最后一点倔强，好像在说：“你总结的不对呢~真是雑鱼~”。但是明眼人都看得出来，0x1+0x2+0x3=−10x_1+0x_2+0x_3=-10x1​+0x2​+0x3​=−1这种事情是绝对不可能发生的，也就是无解。按照刚刚说的，这个增广矩阵的秩R(A′)=3R(A^\\prime)=3R(A′)=3，可是它对应的系数矩阵B′=[123000−105]B^\\prime=\\left[\\begin{array}{ccc}1&amp;2&amp;3\\\\0&amp;0&amp;0\\\\-1&amp;0&amp;5\\end{array}\\right]B′=⎣⎡​10−1​200​305​⎦⎤​的秩R(B)=2R(B)=2R(B)=2，就有R(A′)≠R(B)R(A^\\prime)\\neq R(B)R(A′)​=R(B)且R(A′)&gt;R(B)R(A^\\prime)&gt;R(B)R(A′)&gt;R(B)，于是我们就找到了矩阵无解的一个条件了。矩阵无解的充要条件是R(A)&gt;R(B)R(A)&gt; R(B)R(A)&gt;R(B)。 再考虑有无穷解的情况：无非就是出现了0x1+k2x2+⋯+knxn=s0x_1+k_2x_2+\\dots+k_nx_n=s0x1​+k2​x2​+⋯+kn​xn​=s的情况，此时x1x_1x1​可以代任何值。与无解不同，这次的最简行阶梯形矩阵，无论是系数矩阵还是增广矩阵形式，它们的秩都是相同的，并且都浪费了至少一行方程式。我们知道：一个三元一次方程组是无法用相异的（行向量形式表示下不共线）两个方程解出唯一值的，相反，解形如：{x1=2−x2x3=4\\begin{cases}x_1=2-x_2\\\\x_3=4\\end{cases}{x1​=2−x2​x3​=4​表明x1x_1x1​由x2x_2x2​确定、而−x2-x_2−x2​又由x1−2x_1-2x1​−2确定，然而这俩都不确定，导致这两个数可以取无穷多的值，也就导致矩阵有无穷组解。综上：矩阵有无穷组解的充要条件是R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n（nnn为未知数个数）。 最后就是有唯一解：如果一切进行顺利的话，既没有全零行，也没有无解行。那么此时系数矩阵和增广矩阵的秩会相同，且等于未知数个数，即R(A)=R(B)=nR(A)=R(B)=nR(A)=R(B)=n。 总结，假设一个由nnn个未知数组成的最简行阶梯形矩阵AAA、以及它的增广矩阵BBB。矩阵解的个数={1R(A)=R(B)=n0R(A)&lt;R(B)∞R(A)=R(B)&lt;n=\\begin{cases}1&amp;R(A)=R(B)=n\\\\0&amp;R(A)&lt;R(B)\\\\\\infty&amp;R(A)=R(B)&lt;n\\end{cases}=⎩⎪⎨⎪⎧​10∞​R(A)=R(B)=nR(A)&lt;R(B)R(A)=R(B)&lt;n​。 例1.1.1 Delivery Mathematics 快递员的数学题 「稻妻狛荷屋的人气跨国快递员绮良良在送货途中遇到了一个难题，你作为无所不知无所不晓的旅行者自然是乐意地接下了她的委托。当你来到委托地点时，你发现这是一道解谜题目……」 稻妻号称最难的方块解谜是一组由n,n∈N+n,n\\in\\mathbb N_+n,n∈N+​个正方体可旋转方块组成的阵列，击打其中的某个方块会使得与之相关联的其他方块共同旋转一个特定角度。在这个谜题中，每个方块每次仅能水平顺时针旋转90度，传动方式在下图给出。问若要使所有方块同时朝向北方，需要如何击打方块？给出任意可行解，但需要保证每个方块旋转的次数不超过4（不击打也可以，相当于次数为0）。 由于钟离先生远在海那一头的璃月喝茶听评书、宵宫也正忙着制作夏日祭的烟花而无法抽身、香菱在万民堂做饭、安柏在侦察蒙德郊区、芙宁娜忙着吃蛋糕……总之没有其他人召唤物能帮你解决这个问题，你只能凭借自己的力量解开这个谜题。 问题分析：首先我们要搞清楚传动规则，我们会发现当你击打了一个方块，包括它在内、再按顺时针方向数两个方块都在旋转相同的角度。这也是这道题被称作难题的原因之一，只用想象力是很难想象的出来的……于是为了用代数方法解决该问题，我们选择用四个未知数、四个方程表示每个方块操作后的状态，问题解决的标志既为四个方块的状态均为aaa（aaa表示北方）。 算法设计：考虑到单个方块每旋转四次就相当于一次循环，因此我们重定义方向标，从北开始，顺时针方向将方位标记为4n,4n+1,4n+2,4n+3(n∈N)4n,4n+1,4n+2,4n+3(n\\in\\mathbb N)4n,4n+1,4n+2,4n+3(n∈N)。这么做可以避免一些复杂的取模运算。接着我们根据传动规则表示每个方块的状态，令方块1-4被击打次数分别为w,x,y,zw,x,y,zw,x,y,z。以方块1为例：击打自己、3号和4号都会导致1号顺时针旋转90°，再算上1号初始朝向为222，得到：w+y+z+2=4nw+y+z+2=4nw+y+z+2=4n。其他方块以此类推，解析出的方程组对其求解即可。这样的矩阵一定有唯一解，每个未知数都以nnn表示，将一个自然数代入nnn值即可解出答案。 解：设方块1-4的击打次数分别为w,x,y,z∈Nw,x,y,z\\in\\mathbb Nw,x,y,z∈N，设朝向从北方按顺时针方向分别为4n,4n+1,4n+2,4n+3,n∈N4n,4n+1,4n+2,4n+3,n\\in\\mathbb N4n,4n+1,4n+2,4n+3,n∈N。 根据传动规则，有如下线性方程组： {w+y+z=4n−2x+w+y=4ny+x+z=4nz+w+x=4n−2\\begin{cases}w+y+z=4n-2\\\\x+w+y=4n\\\\y+x+z=4n\\\\z+w+x=4n-2\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​w+y+z=4n−2x+w+y=4ny+x+z=4nz+w+x=4n−2​ 增广矩阵形式为： [10114n−211104n01114n11014n−2]\\left[\\begin{array}{cccc|c}1&amp;0&amp;1&amp;1&amp;4n-2\\\\1&amp;1&amp;1&amp;0&amp;4n\\\\0&amp;1&amp;1&amp;1&amp;4n\\\\1&amp;1&amp;0&amp;1&amp;4n-2\\end{array}\\right]⎣⎢⎢⎡​1101​0111​1110​1011​4n−24n4n4n−2​⎦⎥⎥⎤​ （化简过程略），行阶梯形式为： [11104n−201114n00124n−200034n−4]\\left[\\begin{array}{cccc|c}1&amp;1&amp;1&amp;0&amp;4n-2\\\\0&amp;1&amp;1&amp;1&amp;4n\\\\0&amp;0&amp;1&amp;2&amp;4n-2\\\\0&amp;0&amp;0&amp;3&amp;4n-4\\end{array}\\right]⎣⎢⎢⎡​1000​1100​1110​0123​4n−24n4n−24n−4​⎦⎥⎥⎤​ 因为系数矩阵的秩与增广矩阵的秩相同且都等于未知数个数444，因此矩阵有唯一解{w=4n−43x=4n+23y=4n+23z=4n−43\\begin{cases}w=\\frac{4n-4}{3}\\\\x=\\frac{4n+2}{3}\\\\y=\\frac{4n+2}{3}\\\\z=\\frac{4n-4}{3}\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​w=34n−4​x=34n+2​y=34n+2​z=34n−4​​。易知nnn的合法值满足1+3k,k∈N1+3k,k\\in\\mathbb N1+3k,k∈N的数学关系，此处求最小值，令n=1n=1n=1，得到{w=0x=2y=2z=0\\begin{cases}w=0\\\\x=2\\\\y=2\\\\z=0\\end{cases}⎩⎪⎪⎪⎨⎪⎪⎪⎧​w=0x=2y=2z=0​。 因此，最佳方案是暴击击打2号和3号方块各两次。 后日谈：有些读者可能会问，这个难道不是有无穷解吗？为什么上边说这个矩阵只有唯一解？其实这个矩阵确实只有唯一解，因为R(A)=R(B)=4R(A)=R(B)=4R(A)=R(B)=4，造成它有无数组解的原因是nnn这个自然数。我们在开头只为这个矩阵设定了四个未知数w,x,y,zw,x,y,zw,x,y,z，因此矩阵只有四个元，因而有唯一解。 洛谷习题： P3389 [模板] 高斯消元法 P2455 [SDOI2006] 线性方程组 P4035 [JSOI2008] 球形空间产生器 第二章 矩阵乘法 第一节 什么是矩阵乘法 你经常能在各种线性代数的书上看到这样一串定义式：(BA)ij=∑i=1paikbkj(BA)_{ij}=\\sum\\limits_{i=1}^{p}a_{ik}b_{kj}(BA)ij​=i=1∑p​aik​bkj​。这对于自学者（比如说我自己）其实是非常不友好的。他们在举例计算时很容易被i,j,ki,j,ki,j,k绕进去，不仅计算速度慢不说，还很容易出错……那我在此举出一个简记方法： 将左边的矩阵的每一行看作每个未知数都代了确定值的方程、右边的矩阵每一列看作是前者方程的未知数系数。二者相乘本质上就是让未知数和系数匹配上，并计算出结果放入结果矩阵的特定位置。这个特定位置也有讲究——计算时我们需要固定一个行/列，相对应地我们需要遍历另一个矩阵的列/行，遍历的方向就是这个“特定位置”的排布方向，当遍历完一轮，开始下一轮时，这个“特定位置”的起始点将移到下一行/列，若固定一列则右移一列；反之下移一行。看以下例子来加深理解： 这是固定特定列求值的例子，固定行求值留给读者自行实操。不想再做图了，我太懒了 那么什么样的矩阵才能进行乘法运算呢？答案是一个n×pn\\times pn×p和一个p×mp\\times mp×m的矩阵，观察规律，我们发现前矩阵的列数需要等于后矩阵的行数。根据如上概括的矩阵乘法的意义——即搭配未知数与系数。显然，当后一个矩阵的列数大于前一个矩阵的行数时，我们进行系数配对时就会发现多出几个失配的系数。矩阵乘法国不养闲人，这种单身汉显然是不可以光天化日下大摇大摆出来遛弯的。因此保证其中一个矩阵的行数等于另一个矩阵的列数后方可相乘。 类比四则运算的乘法，矩阵乘法是否也有结合律、分配律和交换律呢？很遗憾，不完全是，前二者是矩阵乘法运算所具备的性质、但最后那个交换律不是。不是所有的矩阵相乘都满足乘法交换律，举几个特例：同型零矩阵相乘、一个矩阵（可逆）和它的逆矩阵相乘，矩阵乘法满足交换律的充要条件证明过于复杂烧脑，此处不做陈述主要是我也不会证qwq……。 证明：一般矩阵不满足乘法交换律 假设一般矩阵A=(anp)A=(a_{np})A=(anp​)，一般矩阵B=(bpm)B=(b_{pm})B=(bpm​)，则ABABAB可以进行，因为AAA的行数和BBB的行数均为ppp。得到的乘积CCC是一个m×mm\\times mm×m矩阵；反过来，BABABA无法进行，因为BBB的列数不等于AAA的行数，即m≠nm\\neq nm​=n。 假设A=(ann),B=(bnn)A=(a_{nn}),B=(b_{nn})A=(ann​),B=(bnn​)。ABABAB和BABABA均可进行，假设乘积为C=(cnn)C=(c_{nn})C=(cnn​)。当C=ABC=ABC=AB时，根据矩阵乘法的计算式，得到cij=∑k=1naikbkjc_{ij}=\\sum\\limits_{k=1}^{n}a_{ik}b_{kj}cij​=k=1∑n​aik​bkj​；当C=BAC=BAC=BA时，根据计算公式得cij=∑k=1nbikakjc_{ij}=\\sum\\limits_{k=1}^{n}b_{ik}a_{kj}cij​=k=1∑n​bik​akj​。一般情况下，aikbkj≠akjbika_{ik}b_{kj}\\neq a_{kj}b_{ik}aik​bkj​​=akj​bik​。得证。 矩阵和数字一样，也有幂次方的计算。特殊地，任意n×nn\\times nn×n非零矩阵的零次幂都是一个n×nn\\times nn×n的单位矩阵。主对角线的值全是1，其余元素均为0的矩阵叫做单位矩阵，用字母III表示；零矩阵的任何非零正整数次幂都是一个零矩阵，零矩阵的元素全部是0，用字母OOO表示。一个3×33\\times33×3的单位矩阵是这样的：I=[100010001]I=\\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1\\end{bmatrix}I=⎣⎡​100​010​001​⎦⎤​。在算法设计中，经常用类似于大数快速幂（位运算版本）的方式快速计算矩阵的幂次方。 例2.1.1 Akasha Browser with Irminsul Kernel 世界树搜索引擎 你作为刚刚清除了须弥世界树痼疾的英雄旅行者，突然对虚空终端的运作方式有了兴趣。你从大贤者那里了解逼问到，虚空终端实质上是一个仅显示搜索结果的前端程序，但关键词搜索功能却是基于须弥地下空间的世界树。带着这个疑问，你再次来到了世界树前，见到了小吉祥草王大人，希望能让她告诉你世界树的运作方式…… 背景知识： 一般浏览器的结果返回功能大多数依赖于矩阵运算，这里属于最简单的一种——我们只需要矩阵的乘法运算（某些情况下会用到转置）。然而随着科技的快步发展，数据量的快速增加，这种方式如今只在很小的范围内被使用（由于码量小思维简单，它有时会在个人博客的关键词搜索功能中被用到）；目前广泛使用的一种是向量相似性搜索，它本质上是在一定范围内搜索与目标向量辐角最为接近的已有向量，在“矩阵的几何表示”章节中会涉及到。这里介绍的是简单匹配搜索。 问题分析：因为矩阵乘法本质上是未知数和系数的配对求值，我们需要构造一个方法来使得“搜索内容”和“已有内容”配对。并且搜索引擎总会返回与你搜索的内容最为相似的结果，搜索“比尔·盖茨”，第一条肯定是关于他个人的介绍，而绝对不可能是一则寻狗启示……因此，我们设计的矩阵必须能在经历一轮运算后能够正确返回每个关键词出现的频率（简单点说就是出现次数），这样虚空终端才能对频率进行排序，并返回频率最大的那个结果。 算法设计：不妨考虑这样几个矩阵——其中一个存储关键词、另一个存储搜索内容。比如我需要将几篇论文（为方便使用英文表示，并且假设词根相同的单词为同一个单词，即不考虑词汇变形）《Basic Structure of Elemental Monuments》（元素方碑的底层构造）、《Junior Elemental Reaction》（初等元素反应）、《Advanced Elemental Theory》（高等元素论）、《Architectural Structure in the Mausoleum of King Deshret》（赤王陵的建筑结构）以及《Advanced Sumeru Linguistic Analysis》（高等须弥语音学解析）。我们在此次挑选一些关键词存储（方便读者观察）：Structure、Element、Junior和Advanced。为每篇论文编号1-5，矩阵如下图： 假如热爱学习的艾尔海森来到了教令院的大图书馆，它想测试一下这全新开发的文献查询系统，输入了Advanced一词。假设已录入数据库就是以上形式，我们如何构造一个“查询矩阵”来和数据库矩阵进行运算呢？ 首先根据矩阵乘法的前提要求，这个查询矩阵必须是四行。不妨让每行代表我们的词库词语，艾尔海森输入的是Advanced——即对应数据库矩阵的第四列（未知数），我们要配对它的系数，因此它必须在第四行，才能保证系数正确匹配未知数。同理，查询矩阵的第一行对应Structure、第二行Element、第三行Junior。他输入了一个Advanced，因此我们的查询矩阵如下图： 乘法的目的是将二者匹配起来，得到的结果如下图： 返回矩阵的数字代表关键词在对应数据库项中的出现次数，也就是说，如果此时再加入一篇论文《Advanced Usage of the Word Advanced》（“Advanced”一词的进阶用法），返回矩阵的最后一行（第六行）会出现一个222。经过虚空终端的一轮排序，它自然就会来到第一位的位置。如果要分别查询两个不同关键词，在查询矩阵右侧再加一列即可，返回矩阵中多出的一列就是新关键词的出现次数；如果需要同时查询两个关键词，在同一列对应位置写入111即可…… 后日谈：可靠情报称——愚人众第二席执行官“博士”伙同教令院高层贤者向世界树中加入了大量带有重复词语标题的、正文中充满了强烈心理暗示的催眠文献，须弥民众所佩戴的虚空终端中写入的关键词查询算法自动按关键词出现频率返回结果、其内置的播放功能在结果返回后自动激活，播放其中内容，导致须弥大范围民众出现意识不清、报告称出现“重复经历同一天”、“既视感”等异常现象。后续调查正持续跟进中……——《蒸汽鸟报》记者 夏洛蒂 须弥的大范围“失控”已被证明是须弥民众针对教令院的一次毫无意义的武装暴动，目前已被教令院大贤者和“博士”联合镇压。主要组织者纳西妲、旅行者已被尽数羁押等候问讯。——教令院 例2.1.2 Light Novel Query 轻小说查询 八重堂的主编八重神子最近在为轻小说的事情发愁……并不是因为销量不够，正相反：八重堂最近推出了一项跨国销售项目，各种经典作品被远销往了枫丹廷。这就牵涉出一个问题——枫丹的市民们不想远离枫丹城区、横穿须弥沙漠、翻越璃月高山、躲避稻妻雷暴就为了看一看有哪些轻小说符合自己的独特口味……于是八重神子找到了见多识广的你，希望你能帮她做出一套轻小说内容检索系统。当然作为报酬给你的原石和摩拉是肯定是不会少的…… 当然，这套系统有一定要求。因为有很多轻小说为了吸引读者，取的标题和内容是完全对不上号的，神子的想法是做一套正文内容检索——每本轻小说的总字数在出版时就统计好了，但是苦于稻妻的信息存储技术不是很发达，神子希望存储在数据库矩阵里的数据尽可能小。请问该如何设计符合要求的存储算法？ 问题分析：每本书中特定的词可能重复出现成百上千次（同样用英文单词表示，且同词根不同词形的两个词算作同一个单词参与计数），我们的要求是让数据尽可能小，既然总字数都已经给出了，我们不妨使用指定词出现的频率来表示这个词的出现次数（单词出现次数=全书总词数×出现频率）。这样的搜索方法叫做相对频率搜索。 算法设计：大致原理和例2.1.1里的一模一样，只是数据库矩阵存储的不再是出现总次数，而是对应词的相对频率。因而图例2.1.3可以变化为如下形式： 明显一看，第三篇文章出现Advanced的频率最高，应该优先返回。但是这个例子并不是很好（明明说了按内容搜索你还在这搜索标题），但是当加入大量的正文内容时，这个方法的优势也就体现出来了。这里由于篇幅图太大耗我洛谷高级图床空间，我也懒得写那么多字原因就不举过长的例子，本例仅作对相对频率搜索的原理的理解。 后日谈：八重堂轻小说搜索引擎被教令院照搬去做了论文的查询系统…… 第二节 初等矩阵与矩阵递推 假设存在一个n×nn\\times nn×n的单位矩阵III，对III只进行一次初等行变换得到的矩阵叫做初等矩阵，通常用EEE表示。一个矩阵的行变换和列变换都可以用初等矩阵的乘法进行。 仅交换了两行的单位矩阵称作第I类初等矩阵（只进行了初等行变换第一条），将它左乘到一个矩阵前，可以进行相应的行运算；右乘到一个矩阵后可以进行相应的列运算。比如，一个第I类初等矩阵EI=[010100001]E_I=\\begin{bmatrix} 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1\\end{bmatrix}EI​=⎣⎡​010​100​001​⎦⎤​（交换第一、二行），和一个3×33\\times33×3矩阵A=[425026551]A=\\begin{bmatrix} 4 &amp; 2 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}A=⎣⎡​405​225​561​⎦⎤​。左乘就是EIA=[026425551]E_IA=\\begin{bmatrix}0 &amp; 2 &amp; 6 \\\\ 4 &amp; 2 &amp; 5\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}EI​A=⎣⎡​045​225​651​⎦⎤​（交换一、二行）；右乘就是AEI=[245206551]AE_I=\\begin{bmatrix} 2 &amp; 4 &amp; 5\\\\ 2 &amp; 0 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}AEI​=⎣⎡​225​405​561​⎦⎤​（交换一、二列）。 仅将某一行乘以一个非零倍数的矩阵叫做第II类初等矩阵（只进行了初等行变换第二条），左乘行运算、右乘列运算。例如一个第II类初等矩阵EII=[300010001]E_{II}=\\begin{bmatrix} 3 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1\\end{bmatrix}EII​=⎣⎡​300​010​001​⎦⎤​（第一行乘3）和一个3×33\\times33×3矩阵A=[425026551]A=\\begin{bmatrix} 4 &amp; 2 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}A=⎣⎡​405​225​561​⎦⎤​。EIIA=[12615026551]E_{II}A=\\begin{bmatrix} 12 &amp; 6 &amp; 15\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}EII​A=⎣⎡​1205​625​1561​⎦⎤​（第一行乘3）；AEII=[12250261551]AE_{II}=\\begin{bmatrix} 12 &amp; 2 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 15 &amp; 5 &amp; 1\\end{bmatrix}AEII​=⎣⎡​12015​225​561​⎦⎤​（第一列乘3）。 仅将某一行的非零倍加到另一行上的矩阵叫做第III类初等矩阵（只进行了初等行变换第三条），同样是左乘行运算、右乘列运算，但是有一点点小不同，不要根据思维定势随便写答案！例如一个第III类初等矩阵EIII=[120010001]E_{III}=\\begin{bmatrix} 1 &amp; 2 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1\\end{bmatrix}EIII​=⎣⎡​100​210​001​⎦⎤​（第二行乘2加到第一行）和祖传的矩阵A=[425026551]A=\\begin{bmatrix} 4 &amp; 2 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}A=⎣⎡​405​225​561​⎦⎤​。EIIIA=[4617026551]E_{III}A=\\begin{bmatrix} 4 &amp; 6 &amp; 17\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}EIII​A=⎣⎡​405​625​1761​⎦⎤​（第二行的2倍加到第一行）；AEIII=A=[41050265151]AE_{III}=A=\\begin{bmatrix} 4 &amp; 10 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 15 &amp; 1\\end{bmatrix}AEIII​=A=⎣⎡​405​10215​561​⎦⎤​（第一列的2倍加到第二列）。注意初等矩阵的行列变换与乘法后矩阵的行列变换，哪一行/列乘了倍数、哪一行/列被加上了！ 因此我们可以不必使用高斯消元，仅使用初等矩阵乘法也可以达到将普通矩阵消元变成最简行阶梯形矩阵！而且它可以进行列运算，甚至比高斯消元法更高级一点。 接下来是我们的矩阵递推。大家都知道斐波那契数列，它的前两项均为1，此后的每一项都是前两项之和，即an={an−1+an−2n&gt;21n=1,n=2a_n=\\begin{cases}a_{n-1}+a_{n-2}&amp;n&gt;2\\\\1&amp;n=1,n=2\\end{cases}an​={an−1​+an−2​1​n&gt;2n=1,n=2​。大多数信息竞赛生在学习到递归算法时都会被要求写程序求解斐波那契数列的某一项，当然代码也非常的简单，如下： 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;long long fib(int n) &#123; if (n == 1 || n == 2) return 1; return fib(n - 1) + fib(n - 2); &#125;int main() &#123; int n; cin&gt;&gt;n; cout&lt;&lt;fib(n)&lt;&lt;endl; return 0;&#125; 这段代码其实就是照搬了上面的通项公式，但是递归有个弊端就是效率和内存，当nnn为百万级别、甚至十亿级别时它就显得很小丑了。那么我们如何用矩阵加速计算呢？我们用斐波那契数列的递推来向读者介绍矩阵递推的操作方法： 首先我们将通项公式变成我们想要求的形式，为了便于输出，要求结果矩阵的第一个元素就是答案，因此结果矩阵就是：a⃗=(an,an+1)\\vec a=(a_n,a_{n+1})a=(an​,an+1​)。又因为an=an−1+an−2a_n=a_{n-1}+a_{n-2}an​=an−1​+an−2​，并且an+1=an+an−1a_{n+1}=a_n+a_{n-1}an+1​=an​+an−1​。我们还需要保证初始矩阵在经历一轮变换前后，始终都是同型的，这里是1×21\\times21×2的矩阵，操作后也应该是1×21\\times21×2的矩阵。于是我们的递推矩阵应该是一个2×22\\times22×2矩阵。不妨将递推矩阵MMM的每一行从上至下分别表示为an−1a_{n-1}an−1​和an−2a_{n-2}an−2​的系数，由以上二式可得：M=[?1?1]M=\\begin{bmatrix} ? &amp; 1 \\\\ ? &amp; 1\\end{bmatrix}M=[??​11​]。别急，左边还有一列未填满——我们希望每次操作都会把矩阵元素整体向左移一个位置，就好像一个滑动窗口（但不是单调队列），我们的第一列也可以求出来了。最终就是M=[0111]M=\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 1\\end{bmatrix}M=[01​11​] 那么求数列第nnn项——每次右乘MMM都相当于多求出一项，并且当MMM只被乘了一次时，结果矩阵的第一个元素是a2a_2a2​。因此要让第nnn项来到第一个位置，我们需要进行n−1n-1n−1次乘法，ana_nan​也就是AMn−1AM^{n-1}AMn−1的第一行第一列元素。可以写出如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MOD 1000000007#define N 15using namespace std;typedef long long ll;int n = 2; // 递推矩阵行列数均为2 struct Matrix &#123; ll mat[N][N]; Matrix() &#123; memset(mat, 0.0, sizeof mat); // 初始化时内部变量自动置零，无需每次定义变量时再置零 &#125; void I() &#123; for (int i = 1; i &lt;= n; i++) mat[i][i] = 1; // 构造2×2单位矩阵 &#125;&#125;; Matrix operator *(const Matrix &amp;l, const Matrix &amp;r) &#123; // 重载乘法运算符，实现矩阵乘法 Matrix res; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // res.mat[i][j] = (res.mat[i][j] + l.mat[i][k] * r.mat[k][j] % MOD) % MOD; // 取模用这个 res.mat[i][j] += l.mat[i][k] * r.mat[k][j]; &#125; &#125; &#125; return res;&#125;Matrix qpow(Matrix a, ll b) &#123; Matrix res; res.I(); while (b) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; int a; cin&gt;&gt;a; Matrix A; A.mat[1][1] = A.mat[1][2] = 1; // 初始矩阵 Matrix M; M.mat[1][2] = M.mat[2][2] = M.mat[2][1] = 1; // 递推矩阵 A = A * qpow(M, a - 1); cout&lt;&lt;A.mat[1][1]&lt;&lt;endl; return 0;&#125; 它的时间复杂度可以做到O(n3log⁡T)\\mathcal O(n^3\\log T)O(n3logT)，nnn是递推矩阵长/宽，这里是222；TTT是幂指数。因此这里的时间复杂度是：O(8log⁡(a−1))\\mathcal O(8\\log(a-1))O(8log(a−1))，比朴素斐波那契递推的O(2a−1)\\mathcal O(2^{a-1})O(2a−1)强了不少！ 例2.2.1 Lost Control! Blubberbeast’s Reproduction 膨膨兽泛滥危机 由于枫丹水质的大幅改善，膨膨兽的天敌数量锐减，枫丹城区近海的膨膨兽也得到了更多的食物，进而开始大量地繁殖。水质改善的第一年，已登记的膨膨兽数量是6765头，恰好是斐波那契数列的第20项。第二年，膨膨兽数量没有变化，之后的每一年，膨膨兽数量都是前两年之和的85%85\\%85%，已知膨膨兽的平均寿命是15年、枫丹廷近海能承载的最大膨膨兽数量是90万只。那么请问15年后近海的膨膨兽数量是多少？这15年内枫丹廷是否需要向近海投放膨膨兽的天敌以遏制后者疯狂繁殖？（结果出现出现小数则向上取整） 问题分析：这是一道标准的矩阵快速幂递推问题，它基于斐波那契数列递推、却比它更高级。首先，它的初始值不再是(1,1)(1,1)(1,1)而是(6765,6765)(6765,6765)(6765,6765)，其次，从第三项起，每一项都是前两项和的一个倍数，这里是0.850.850.85。那我们怎么构造递推矩阵MMM来解决问题呢？ 算法设计： 已知初始矩阵A=(6765,6765)A=(6765,6765)A=(6765,6765) 。根据题目描述很容易写出通项公式：an={67650&lt;n≤20.85⋅(an−1+an−2)n&gt;2a_n=\\begin{cases}6765&amp;0&lt;n\\leq2\\\\0.85\\cdot(a_{n-1}+a_{n-2})&amp;n&gt;2\\end{cases}an​={67650.85⋅(an−1​+an−2​)​0&lt;n≤2n&gt;2​。我们要保证初始矩阵经过一次递推后，得到的新矩阵与初始矩阵同型，因此根据矩阵乘法定义，我们的递推矩阵必须是一个2×22\\times22×2矩阵。于是拿出祖传单位矩阵模板I=[1001]I=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1\\end{bmatrix}I=[10​01​]开始构造递推矩阵！ 对于前项和的问题，前面已经给出了，因而我们的递推矩阵变成了M=[0111]M=\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 1\\end{bmatrix}M=[01​11​]；接下来解决倍数问题——根据通项公式，an−1a_{n-1}an−1​和an−2a_{n-2}an−2​的系数都是0.850.850.85，我们构造递推矩阵时也要考虑到这一点，当n&gt;2n&gt;2n&gt;2时，递推公式展开如下：an=0.85an−1+0.85an−2,an+1=0.85an+0.85an−1a_n=0.85a_{n-1}+0.85a_{n-2},a_{n+1}=0.85a_n+0.85a_{n-1}an​=0.85an−1​+0.85an−2​,an+1​=0.85an​+0.85an−1​。如果第一行代表an−1a_{n-1}an−1​的系数、第二行代表an−2a_{n-2}an−2​的系数0.850.850.85，第二列显然应该同时乘以0.85，左边一列的作用是使原矩阵整体向左移一个位置。最后我们的递推矩阵就是M=[00.8510.85]M=\\begin{bmatrix} 0 &amp; 0.85 \\\\ 1 &amp; 0.85\\end{bmatrix}M=[01​0.850.85​]。直接将初始矩阵右端乘以递推矩阵的幂次方就可以了。注意因为初始矩阵的右侧是第二年的膨膨兽个数，乘以递推矩阵本身（一次方），会让第二年的膨膨兽个数移到结果矩阵的前端，要想让第一项变成第15年的个数，递推矩阵的幂必须是141414，即15−115-115−1。 代码实现上，仅需将AAA矩阵和MMM矩阵的初始值改变就可以了。 最终结果：875076。结果小于90万，因此不需要投放天敌。 后日谈：那如果将系数改变为0.860.860.86呢？输出的结果将是977427，接近100万了。因此但凡枫丹水质再好那么一点点，使得这个系数升高了0.1，那么枫丹廷说不定都会变成膨膨兽的第二家园了！ 洛谷例题： P3390 [模板] 矩阵快速幂 P1962 斐波那契数列 P1349 广义斐波那契数列 P1939 矩阵加速（数列） P3216 [HNOI2011] 数学作业 第三章 矩阵的逆 第一节 浅谈矩阵的“逆” “逆”这个词相信你早已听说过：同余意义下存在乘法逆元，大多数矩阵也存在逆矩阵。“逆”普遍用来描述不同意义下的“倒数”的概念，倒数一般满足a⋅a−1=1a\\cdot a^{-1}=1a⋅a−1=1的性质，即本体×本体的逆=单位一。矩阵中的“单位一”是单位矩阵III，也因此我们的逆矩阵需要满足这个式子：AA−1=IAA^{-1}=IAA−1=I，并且这个式子倒过来也必须成立（为数不多的满足矩阵乘法交换律的情况之一）。 如果对于一个矩阵AAA，存在另一个矩阵BBB，使得：AB=BA=IAB=BA=IAB=BA=I成立。则称矩阵AAA是可逆的，或称之为非奇异的，矩阵BBB是矩阵AAA的逆矩阵，通常表示成A−1A^{-1}A−1。特殊地，单位矩阵III的逆矩阵是它本身，即II=I2=III=I^2=III=I2=I；零矩阵OOO不可逆，或称之为奇异的，即不可能存在矩阵BBB，使得OB=BO=IOB=BO=IOB=BO=I。类比实数运算，111的倒数永远是它本身、000没有倒数，因为分母为000，没有意义；2×0.5=0.5×2=12\\times0.5=0.5\\times2=12×0.5=0.5×2=1，同时0.5=2−10.5=2^{-1}0.5=2−1。 第二节 行列式 行列式是一种函数，写出来有点像矩阵的绝对值。它可以用来判断一个矩阵是否有解、也可以定量分析线性变换对原向量的影响。矩阵AAA的行列式通常用det⁡(A)\\det(A)det(A)或者是∣A∣|A|∣A∣表示。这一节主要介绍行列式判断矩阵是否可逆。 2×22\\times22×2矩阵A=[a11a12a21a22]A=\\begin{bmatrix}a_{11}&amp;a_{12}\\\\a_{21}&amp;a_{22}\\end{bmatrix}A=[a11​a21​​a12​a22​​]的行列式为det⁡(A)=a11a22−a12a21\\det(A)=a_{11}a_{22}-a_{12}a_{21}det(A)=a11​a22​−a12​a21​。特殊地，1×11\\times11×1矩阵的行列式就是a11a_{11}a11​的值。当一个矩阵的行列式为000时，它是奇异的、也就是不可逆的；反之则非奇异/可逆。 那我们在上边只提到了两种方阵，那对于3×33\\times33×3、4×44\\times44×4、n×nn\\times nn×n的方阵又该怎么办呢？答案是分而治之——分治！ 第三节 代数余子式 我们拿出祖传的3×33\\times33×3矩阵A=[425026551]A=\\begin{bmatrix} 4 &amp; 2 &amp; 5\\\\ 0 &amp; 2 &amp; 6\\\\ 5 &amp; 5 &amp; 1\\end{bmatrix}A=⎣⎡​405​225​561​⎦⎤​，我们随机在其中挑选一位受害者。我个人看第二行第一列的000元素不太顺眼，作为矩阵AAA的定义者，我有权利将它变成自己所喜欢的样子，因此我把元素a21a_{21}a21​拿掉。可是拿掉以后它还是个000！于是我将它所在的那一行以及那一列全部剔除，把剩下的元素按照原来的相对顺序靠拢，组成一个新的2×22\\times22×2矩阵B=[2551]B=\\begin{bmatrix}2&amp;5\\\\5&amp;1\\end{bmatrix}B=[25​51​]。现在整个矩阵没有000元素了，看上去清爽多了~~~ 像上边这样，将nnn阶行列式中元素aija_{ij}aij​（1≤i≤n,1≤j≤n1\\leq i\\leq n,1\\leq j\\leq n1≤i≤n,1≤j≤n）所在的第iii行、第jjj列所有元素删去，剩下元素组成的新n−1n-1n−1阶行列式叫做原行列式的余子式，用MijM_{ij}Mij​表示，代表它是删去原矩阵第iii行和第jjj列得到的余子式。它通常将一个高阶行列式拆分为一个个低阶行列式便于计算，这其中就是用到了分治（子问题递归）的思想。 我们要计算整个n×nn\\times nn×n矩阵的行列式，就需要拆开余子式。最终分治成多个2×22\\times22×2的矩阵求其行列式并加和起来。有一个定理：当n≥2n\\geq2n≥2时，一个n×nn\\times nn×n的方阵的行列式可以表示成任意行/列的余子式展开，即： det⁡(A)=∑i=1n(−1)i+kaikMik=∑i=1n(−1)i+kakiMki,k∈[1,n]\\det(A)=\\sum\\limits_{i=1}^{n}(-1)^{i+k}a_{ik}M_{ik}=\\sum\\limits_{i=1}^{n}(-1)^{i+k}a_{ki}M_{ki},k\\in[1,n]det(A)=i=1∑n​(−1)i+kaik​Mik​=i=1∑n​(−1)i+kaki​Mki​,k∈[1,n] 日常做题时，通常选取000最多的那一行/列进行展开以减少计算量。 第四节 矩阵的逆 第一节解释清楚了逆矩阵的概念，那么如何求逆矩阵呢？首先是前提——判断矩阵是否可逆！我们引入矩阵行等价的概念： 如果一个矩阵AAA能经过有限次初等行变换得到另一个矩阵BBB，则称AAA与BBB是行等价的。比如说你交换一个矩阵的两行（初等行变换第一条）得到的矩阵本质上还是原来的矩阵，因为如果当你把变换前后的矩阵拆分成一个个行向量，它们在坐标系上的关系不变（交换两行向量不变，同乘倍数向量共线还挺押韵）。联系到第二节的初等矩阵知识，初等行变换可以转化为矩阵左乘初等矩阵，定义可以转换为如下的数学语言：如果存在矩阵AAA和矩阵BBB，使得B=E1E2E3…EnAB=E_1E_2E_3\\dots E_nAB=E1​E2​E3​…En​A成立，则称AAA与BBB是行等价的；相应的，初等矩阵右乘就对应两个矩阵列等价。 矩阵行等价有反身性、传递性。例如：AAA与BBB行等价，BBB与CCC行等价，则以下两条均成立： BBB与AAA行等价 AAA与CCC行等价 相应的，若有方程组，使得Ax=bAx=bAx=b。在等号两端同时乘一个符合乘法运算条件的矩阵MMM，新的方程MAx=MbMAx=MbMAx=Mb与先前的方程的解相同。第二个方程与第一个方程就是一组等价方程组。 当且仅当Ax=bAx=bAx=b与Bx=cBx=cBx=c是等价方程组时，增广矩阵(A∣b)(A\\mid b)(A∣b)与(B∣c)(B\\mid c)(B∣c)行等价。这个推论的证明需要用到一个定理：若EEE为一个初等矩阵，则它是非奇异的，且E−1E^{-1}E−1和EEE是同类型矩阵。 证明：根据初等矩阵的定义，它是由单位矩阵III经过单次初等行变换而来。根据行变换类型的不同，分为三种情况讨论： 第一种，EEE为第I类初等矩阵。假设它由单位矩阵交换第iii和第jjj行而来，左乘同样的EEE矩阵，进行相应行运算——右边的EEE矩阵将交换i,ji,ji,j行，因为EEE原本就是III交换i,ji,ji,j行得来的。因此左乘后原式=EE=I=EE=I=EE=I，根据逆矩阵的定义：EEE的逆矩阵就是它本身，即E−1=EE^{-1}=EE−1=E，因此二者同类型，都是第I类初等矩阵。 第二种，EEE为第II类初等矩阵。假设EEE是III的第iii行乘一个非零数α\\alphaα而来，构造新的初等矩阵E′E^\\primeE′，若想使得E′E=IE^\\prime E=IE′E=I，用于进行行运算的左矩阵必须要让第iii行乘上1α\\frac{1}{\\alpha}α1​回到111。因此E′E^\\primeE′的第iii行同乘以非零数1α\\frac{1}{\\alpha}α1​，得到E′E=IE^\\prime E=IE′E=I。因此二者都是第II类初等矩阵。 第三种，EEE为第III类初等矩阵，且是III的第iii行加上第jjj行的k,(k≠0)k,(k\\neq0)k,(k​=0)倍得到的。因此构造初等矩阵E′E^\\primeE′，作为左矩阵，它的效果是让右矩阵的第iii行减去kkk倍第jjj行，因此E′=E−1E^\\prime=E^{-1}E′=E−1，且是III将第jjj行乘−k-k−k加到第iii行得到的。二者同为第III类初等矩阵。 定理得证。 两个非奇异矩阵等价的条件是：假设AAA为一个n×nn\\times nn×n的方阵，所以下面三条命题等价： AAA是非奇异的 Ax=0Ax=0Ax=0只有平凡解000 AAA与III行等价 在矩阵运算中，Ax=0Ax=0Ax=0的零解x=0x=0x=0就是这个方程的一个平凡解。（因为实在是太显而易见了所以很平凡） 证明：首先证第一条可以导出第二条。假设AAA为非奇异方阵，x′=0x^\\prime=0x′=0是方程的一个解。因此x′=Ix′=(AA−1)x′=A−1(Ax′)x^\\prime=Ix^\\prime=(AA^{-1})x^\\prime=A^{-1}(Ax^\\prime)x′=Ix′=(AA−1)x′=A−1(Ax′)。因为x′x^\\primex′是Ax=0Ax=0Ax=0的一个解，因此Ax′=0Ax^\\prime=0Ax′=0，原式=A−1(Ax′)=A−1⋅0=0=A^{-1}(Ax^\\prime)=A^{-1}\\cdot0=0=A−1(Ax′)=A−1⋅0=0。因而原方程仅有平凡解。 再证第二条可以导出第三条。AAA可以化简成行阶梯形矩阵UUU，方程变为Ux=0Ux=0Ux=0。因为严格三角形矩阵可以通过变换得到单位矩阵III，所以需要证明UUU是否是严格三角形矩阵。如果UUU的主对角线出现了000，那肯定不是严格三角形矩阵。因为阶梯形矩阵要保证每一行都比它的上一行前边的000元素多，因为AAA是方阵，到最后一行时只能全部为000。此时矩阵有无数组解，因为实际上他只列出了n−1n-1n−1个方程，最后一行的方程不被计入系数矩阵和增广矩阵的秩，导致R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n。因此有无数组解；反之若UUU的主对角线全不为000，它可以被化简成单位矩阵III（使用高斯消元即可）。因此AAA与UUU行等价、UUU与III行等价，传递得AAA与III行等价。 最后证第三条可以导出第一条。根据行等价的定义，必有I=E1E2E3…Ek−1EkAI=E_1E_2E_3\\dots E_{k-1}E_{k}AI=E1​E2​E3​…Ek−1​Ek​A。根据方才证明的结论：初等矩阵是非奇异的，根据单位矩阵的性质：单位矩阵也是非奇异的。因而AAA也是非奇异的，且A−1=(E1E2…Ek−1Ek)−1=EkEk−1…E2E1A^{-1}=(E_1E_2\\dots E_{k-1}E_k)^{-1}=E_kE_{k-1}\\dots E_2E_1A−1=(E1​E2​…Ek−1​Ek​)−1=Ek​Ek−1​…E2​E1​。 证毕 根据第三条，我们就可以知道一个求逆矩阵的方法了：既然I=E1E2E3…Ek−1EkAI=E_1E_2E_3\\dots E_{k-1}E_{k}AI=E1​E2​E3​…Ek−1​Ek​A，我们给等号两端同时乘一个A−1A^{-1}A−1，得到A−1=E1E2E3…Ek−1EkIA^{-1}=E_1E_2E_3\\dots E_{k-1}E_{k}IA−1=E1​E2​E3​…Ek−1​Ek​I。因此A−1A^{-1}A−1又与III行等价。前两个方程是一对等价方程，我们换元，假设x=E1E2E3…Ek−1Ekx=E_1E_2E_3\\dots E_{k-1}E_{k}x=E1​E2​E3​…Ek−1​Ek​，两个方程如下：{I=xAA−1=xI\\begin{cases}I=xA\\\\A^{-1}=xI\\end{cases}{I=xAA−1=xI​。因此增广矩阵(A∣I)(A|I)(A∣I)可以被化简为(I∣A−1)(I|A^{-1})(I∣A−1)。我们只需高斯消元将分隔线左侧化成III，右侧自然就是逆矩阵A−1A^{-1}A−1了。 例3.4.1 How Aranaras Measure Timeflow 兰那罗的时间观念 你在须弥冒险时，遇到了森林可爱的孩子们——兰那罗。这些小小的生物有着与世无争的纯净心灵、以及大大的胸怀。你们一同冒险，击败了桓那兰那故土的污秽化身，拯救了须弥森林。然而，在和兰那罗对话期间，除开他们奇妙的比喻之外，还有一件事情是你久久无法忘怀的——他们的时间单位。你听过最多的是“种子长成大树”、“太阳升起又落下”、“落落梅从出生到长大”、“大树长成雨林”…… 假如你们经过很长一段时间的交谈，你渐渐明确了各种时间描述词之间的数学关系，关系如下表。请你求出每个描述词所对应的时间间隔 已知大树长成雨林的时间是种子长成大树的50倍；树木从种子长成大树的期间，落落莓已经生长过整整15次了（由种子出生到果实成熟和从成熟到下一颗种子扎根生长的时间相同）；兰那罗从种子长成大树期间，普通人已从黑发少年变为白发苍苍的老人了；普通人从青年到老年的时间足够让三颗种子先后成长为大树；一片树木生长成为雨林，不仅足够让161616个人先后从少年变为老年，而且还需要额外的60年时间完全长成一片健康的雨林。请问“大树长成雨林”、“树木从种子长成大树”、“兰那罗从种子变成大树”、“落落莓从扎根到成熟”以及“普通人从少年到老年”所经过的时间各是多少年？（四舍五入到最近整数，单位：年） 问题分析：既然各个描述词对应时长的倍数关系都已给出，我们可以两两列出方程组求解。这里我们用到矩阵的逆来方便求出方程的解。 算法设计：首先将各个描述词用未知数表示出来，再用数学关系表示出题干中各个描述词的关系，如此得到的5个方程恰好能使矩阵有唯一解。因为一般的方程Ax=bAx=bAx=b可以写成x=A−1bx=A^{-1}bx=A−1b的形式，所以求出AAA的逆矩阵，再对常数项组成的列向量进行左乘即可。 解：设“大树长成雨林”、“树木从种子长成大树”、“兰那罗从种子变成大树”、“落落莓从扎根到成熟”以及“普通人从少年到老年”的时间分别为x1,x2,x3,x4,x5x_1,x_2,x_3,x_4,x_5x1​,x2​,x3​,x4​,x5​年。根据题干描述。可以得到如下关系： {x1=50x230x4=x2x3=x5x5=3x2x1=16x5+60\\begin{cases}x_1=50x_2\\\\30x_4=x_2\\\\x_3=x_5\\\\x_5=3x_2\\\\x_1=16x_5+60\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x1​=50x2​30x4​=x2​x3​=x5​x5​=3x2​x1​=16x5​+60​ 整理得： {x1−50x2=030x4−x2=0x3−x5=0x5−3x2=0x1−16x5=60\\begin{cases}x_1-50x_2=0\\\\30x_4-x_2=0\\\\x_3-x_5=0\\\\x_5-3x_2=0\\\\x_1-16x_5=60\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x1​−50x2​=030x4​−x2​=0x3​−x5​=0x5​−3x2​=0x1​−16x5​=60​ 对应系数矩阵A=[1−500000−103000010−10−30011000−16]A=\\begin{bmatrix}1&amp;-50&amp;0&amp;0&amp;0\\\\0&amp;-1&amp;0&amp;30&amp;0\\\\0&amp;0&amp;1&amp;0&amp;-1\\\\0&amp;-3&amp;0&amp;0&amp;1\\\\1&amp;0&amp;0&amp;0&amp;-16\\end{bmatrix}A=⎣⎢⎢⎢⎢⎡​10001​−50−10−30​00100​030000​00−11−16​⎦⎥⎥⎥⎥⎤​。常数矩阵b=[000060]b=\\begin{bmatrix}0\\\\0\\\\0\\\\0\\\\60\\end{bmatrix}b=⎣⎢⎢⎢⎢⎡​000060​⎦⎥⎥⎥⎥⎤​，未知数矩阵x=[x1x2x3x4x5]x=\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\\\x_4\\\\x_5\\end{bmatrix}x=⎣⎢⎢⎢⎢⎡​x1​x2​x3​x4​x5​​⎦⎥⎥⎥⎥⎤​。对应方程为Ax=bAx=bAx=b。 两侧同时乘以A−1A^{-1}A−1得：x=A−1bx=A^{-1}bx=A−1b。根据逆矩阵求法，初始矩阵为(A∣I)=[1−50000100000−10300010000010−1001000−3001000101000−1600001](A|I)=\\left[\\begin{array}{ccccc|ccccc}1&amp;-50&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\\\0&amp;-1&amp;0&amp;30&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0&amp;-1&amp;0&amp;0&amp;1&amp;0&amp;0\\\\0&amp;-3&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\\\1&amp;0&amp;0&amp;0&amp;-16&amp;0&amp;0&amp;0&amp;0&amp;1\\end{array}\\right](A∣I)=⎣⎢⎢⎢⎢⎡​10001​−50−10−30​00100​030000​00−11−16​10000​01000​00100​00010​00001​⎦⎥⎥⎥⎥⎤​ 高斯消元后，将(A∣I)(A|I)(A∣I)消成(I∣A−1)(I|A^{-1})(I∣A−1)形式，得：(I∣A−1)=[10000−24004002501000−0.50080.500100−1.501251.500010−160130041516000001−1.500251.5](I|A^{-1})=\\left[\\begin{array}{ccccc|ccccc}1&amp;0&amp;0&amp;0&amp;0&amp;-24&amp;0&amp;0&amp;400&amp;25\\\\0&amp;1&amp;0&amp;0&amp;0&amp;-0.5&amp;0&amp;0&amp;8&amp;0.5\\\\0&amp;0&amp;1&amp;0&amp;0&amp;-1.5&amp;0&amp;1&amp;25&amp;1.5\\\\0&amp;0&amp;0&amp;1&amp;0&amp;-\\frac{1}{60}&amp;\\frac{1}{30}&amp;0&amp;\\frac{4}{15}&amp;\\frac{1}{60}\\\\0&amp;0&amp;0&amp;0&amp;1&amp;-1.5&amp;0&amp;0&amp;25&amp;1.5\\end{array}\\right](I∣A−1)=⎣⎢⎢⎢⎢⎡​10000​01000​00100​00010​00001​−24−0.5−1.5−601​−1.5​000301​0​00100​400825154​25​250.51.5601​1.5​⎦⎥⎥⎥⎥⎤​。AAA的逆矩阵就是A−1=[−240040025−0.50080.5−1.501251.5−1601300415160−1.500251.5]A^{-1}=\\begin{bmatrix}-24&amp;0&amp;0&amp;400&amp;25\\\\-0.5&amp;0&amp;0&amp;8&amp;0.5\\\\-1.5&amp;0&amp;1&amp;25&amp;1.5\\\\-\\frac{1}{60}&amp;\\frac{1}{30}&amp;0&amp;\\frac{4}{15}&amp;\\frac{1}{60}\\\\-1.5&amp;0&amp;0&amp;25&amp;1.5\\end{bmatrix}A−1=⎣⎢⎢⎢⎢⎡​−24−0.5−1.5−601​−1.5​000301​0​00100​400825154​25​250.51.5601​1.5​⎦⎥⎥⎥⎥⎤​。 根据方程Ax=bAx=bAx=b，得到x=A−1bx=A^{-1}bx=A−1b，此时x=[x1x2x3x4x5]=A−1b=[−240040025−0.50080.5−1.501251.5−1601300415160−1.500251.5]×[000060]=[15003090190]x=\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\\\x_4\\\\x_5\\end{bmatrix}=A^{-1}b=\\begin{bmatrix}-24&amp;0&amp;0&amp;400&amp;25\\\\-0.5&amp;0&amp;0&amp;8&amp;0.5\\\\-1.5&amp;0&amp;1&amp;25&amp;1.5\\\\-\\frac{1}{60}&amp;\\frac{1}{30}&amp;0&amp;\\frac{4}{15}&amp;\\frac{1}{60}\\\\-1.5&amp;0&amp;0&amp;25&amp;1.5\\end{bmatrix}\\times\\begin{bmatrix}0\\\\0\\\\0\\\\0\\\\60\\end{bmatrix}=\\begin{bmatrix}1500\\\\30\\\\90\\\\1\\\\90\\end{bmatrix}x=⎣⎢⎢⎢⎢⎡​x1​x2​x3​x4​x5​​⎦⎥⎥⎥⎥⎤​=A−1b=⎣⎢⎢⎢⎢⎡​−24−0.5−1.5−601​−1.5​000301​0​00100​400825154​25​250.51.5601​1.5​⎦⎥⎥⎥⎥⎤​×⎣⎢⎢⎢⎢⎡​000060​⎦⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎡​15003090190​⎦⎥⎥⎥⎥⎤​。 即{x1=1500x2=30x3=90x4=1x5=90\\begin{cases}x_1=1500\\\\x_2=30\\\\x_3=90\\\\x_4=1\\\\x_5=90\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x1​=1500x2​=30x3​=90x4​=1x5​=90​ 因此，“大树长成雨林”的时间是150015001500年、“树木从种子长成大树”需要303030年、“兰那罗从种子变成大树”需要909090年、“落落莓从扎根到成熟”需要111年、“普通人从少年到老年”需要909090年。 最后，森林会记住一切。 第五节 行列式的性质 感谢初等矩阵的加持，我们需要记背的知识点又多了不少呢…… 我们在第三节说了，用余子式计算矩阵行列式时，需要按照同一列或者是同一行展开。为什么不能沿对角线或者是其他花里胡哨的顺序算余子式呢？下面有个引理告诉你原因： 设AAA为n×nn\\times nn×n的方阵，MijM_{ij}Mij​表示aija_{ij}aij​的代数余子式，则： ai1Mj1+ai2Mj2+⋯+ainMjn={det⁡(A)i=j0i≠ja_{i1}M_{j1}+a_{i2}M_{j2}+\\dots+a_{in}M_{jn}=\\begin{cases}\\det(A)&amp;i=j\\\\0&amp;i\\neq j\\end{cases}ai1​Mj1​+ai2​Mj2​+⋯+ain​Mjn​={det(A)0​i=ji​=j​ 不难发现，i=ji=ji=j的情况就是沿同一列的余子式展开。假如i=j=1i=j=1i=j=1，原式就是沿第一行、从第一列到第nnn列元素的余子式之和。而这恰好是一个矩阵的余子式展开（人家行列式就是这么算出来的，肯定是对的），因而结果等于det⁡(A)\\det(A)det(A)。当i≠ji\\neq ji​=j时，就是上边说的花里胡哨的展开。为了证明它，我们假设一个新的矩阵A′A^\\primeA′。它的第jjj行被替换成原AAA矩阵的第iii行，这样的话这个余子式展开就是A′A^\\primeA′的正确的余子式展开，也就是说它的结果等于det⁡(A′)\\det(A^\\prime)det(A′)。然而A′A^\\primeA′有两行是相同的，也就是说它不可逆（最简阶梯形的最后一行全为0），因而det⁡(A′)=0\\det(A^\\prime)=0det(A′)=0，结果也就是000。 假如det⁡(A)=α\\det(A)=\\alphadet(A)=α，那如果有一个初等矩阵左乘它进行行变换，乘积的行列式是否也等于α\\alphaα呢？接下来就来探究这个问题： 假如E1E_1E1​为一个2×22\\times22×2的第I类初等矩阵，且是单位矩阵交换第一、二行得来的。假设A=(a22)A=(a_{22})A=(a22​)为一个2×22\\times22×2的方阵。那么E1A=[a21a22a11a12]E_1A=\\begin{bmatrix}a_{21}&amp;a_{22}\\\\a_{11}&amp;a_{12}\\end{bmatrix}E1​A=[a21​a11​​a22​a12​​]，那么det⁡(E1A)=a21a12−a22a11\\det(E_1A)=a_{21}a_{12}-a_{22}a_{11}det(E1​A)=a21​a12​−a22​a11​，而det⁡(A)=a11a22−a12a21=−det⁡(E1A)\\det(A)=a_{11}a_{22}-a_{12}a_{21}=-\\det(E_1A)det(A)=a11​a22​−a12​a21​=−det(E1​A)，所以det⁡(E1A)=−det⁡(A)\\det(E_1A)=-\\det(A)det(E1​A)=−det(A)。 推广到3×33\\times33×3矩阵，假设3×33\\times33×3方阵A′A^\\primeA′是AAA交换一、三行得来的。那么按照第二行展开余子式就是：det⁡(A′)=−a21∣a32a33a12a13∣+a22∣a31a33a11a13∣−a23∣a31a32a11a12∣\\det(A^\\prime)=-a_{21}\\left|\\begin{array}{cc}a_{32}&amp;a_{33}\\\\a_{12}&amp;a_{13}\\end{array}\\right|+a_{22}\\left|\\begin{array}{cc}a_{31}&amp;a_{33}\\\\a_{11}&amp;a_{13}\\end{array}\\right|-a_{23}\\left|\\begin{array}{cc}a_{31}&amp;a_{32}\\\\a_{11}&amp;a_{12}\\end{array}\\right|det(A′)=−a21​∣∣∣∣​a32​a12​​a33​a13​​∣∣∣∣​+a22​∣∣∣∣​a31​a11​​a33​a13​​∣∣∣∣​−a23​∣∣∣∣​a31​a11​​a32​a12​​∣∣∣∣​。 根据2×22\\times22×2矩阵行列式的性质有det⁡(A′)=a21∣a12a13a32a33∣−a22∣a11a13a31a33∣+a23∣a11a12a31a32∣=−det⁡(A)\\det(A^\\prime)=a_{21}\\left|\\begin{array}{cc}a_{12}&amp;a_{13}\\\\a_{32}&amp;a_{33}\\end{array}\\right|-a_{22}\\left|\\begin{array}{cc}a_{11}&amp;a_{13}\\\\a_{31}&amp;a_{33}\\end{array}\\right|+a_{23}\\left|\\begin{array}{cc}a_{11}&amp;a_{12}\\\\a_{31}&amp;a_{32}\\end{array}\\right|=-\\det(A)det(A′)=a21​∣∣∣∣​a12​a32​​a13​a33​​∣∣∣∣​−a22​∣∣∣∣​a11​a31​​a13​a33​​∣∣∣∣​+a23​∣∣∣∣​a11​a31​​a12​a32​​∣∣∣∣​=−det(A)。 因此对于n×nn\\times nn×n的方阵，交换其中两行对行列式的影响是改变其符号。其余两类矩阵自行证明，总规律如下： det⁡(EA)=det⁡(E)det⁡(A)\\det(EA)=\\det(E)\\det(A)det(EA)=det(E)det(A)，且det⁡(E)={−1E是第I类初等矩阵kk≠0且E是第II类初等矩阵1E是第III类初等矩阵\\det(E)=\\begin{cases}-1&amp;\\text{E是第I类初等矩阵}\\\\k&amp;k\\neq0\\text{且E是第II类初等矩阵}\\\\1&amp;\\text{E是第III类初等矩阵}\\end{cases}det(E)=⎩⎪⎨⎪⎧​−1k1​E是第I类初等矩阵k​=0且E是第II类初等矩阵E是第III类初等矩阵​。 洛谷例题： P7112 [模板] 行列式求值 P4783 [模板] 矩阵求逆 第四章 向量空间 第一节 欧几里得向量空间 简称欧氏空间，Rn\\bold R^nRn表示一个n,n∈N+n,n\\in\\mathbb N_+n,n∈N+​维欧氏空间。我们在高中立体几何部分接触了向量在空间内的表示方法，一般来说它们都使用行向量(x,y)(x,y)(x,y)表示一个由原点指向(x,y)(x,y)(x,y)的向量。线性代数中为了区分，大多数时候使用列向量[xy]\\begin{bmatrix}x\\\\y\\end{bmatrix}[xy​]来表示与上边相同的行向量。 如果仅把[xy]\\begin{bmatrix}x\\\\y\\end{bmatrix}[xy​]描述成由原点指向(x,y)(x,y)(x,y)的有向线段，显然是不太合理的。根据向量知识，一段由(1,1)(1,1)(1,1)指向(x+1,y+1)(x+1,y+1)(x+1,y+1)的有向线段也可以用[xy]\\begin{bmatrix}x\\\\y\\end{bmatrix}[xy​]来表示。因此对于一个列向量，它可以在对应维度空间内画出无数个起点和终点各不相同的向量图像来。如果根据这个原理，列向量表示法就失去了唯一性…… 事实不然，我们发现，无论这个向量的起点如何变化，它们的方向（辐角）、长度（模长）相同，它们可以经过平移变换成同一个向量。只要确定以上这两项的值，一个nnn维向量也就随之确定了。 （向量vvv可以通过平移变为向量uuu，这两个向量是相等的，都可以用(1,1)(1,1)(1,1)表示） 根据勾股定理可以计算出向量的长度，这叫做向量的模长，a⃗=(x,y)\\vec a=(x,y)a=(x,y)的模长一般写作∣a⃗∣|\\vec a|∣a∣，数值上等于x2+y2\\sqrt{x^2+y^2}x2+y2​。若是Rn\\bold R^nRn上的一个普通向量a⃗n=(a1,a2,a3,…,an)\\vec a_n=(a_1,a_2,a_3,\\dots,a_n)an​=(a1​,a2​,a3​,…,an​)，就有∣a⃗n∣=a12+a22+a32+⋯+an2=∑i=1nai2|\\vec a_n|=\\sqrt{a_1^2+a_2^2+a_3^2+\\dots+a_n^2}=\\sqrt{\\sum\\limits_{i=1}^{n}a_i^2}∣an​∣=a12​+a22​+a32​+⋯+an2​​=i=1∑n​ai2​​。这些是我们高中时期就学习过的内容。 高中数学教材在虚数那一章还有一个选学知识（2023版）——辐角。尽管它标成“选学”，其实我们早在三角函数的几何表示里就接触过辐角了：一个起点是原点的向量可以看作是它从xxx轴正半轴逆时针旋转θ rad\\theta\\;radθrad得来的，这里的θ\\thetaθ就是向量的辐角。它很有用——是FFTFFTFFT算法中单位根操作的灵魂，FFTFFTFFT被广泛用于电子设备的自然信号处理，你桌面美化包里的频谱图的底层实现就是FFTFFTFFT算法。FFTFFTFFT讲解见此。 我们定义向量的数乘运算：辐角不变，模长相乘。图示： （v=3u=3[11]=[33]v=3u=3\\begin{bmatrix}1\\\\1\\end{bmatrix}=\\begin{bmatrix}3\\\\3\\end{bmatrix}v=3u=3[11​]=[33​]） 我们定义向量的加法，参见高中物理合力与分力的知识。矢量（既有方向又有大小的量）的加法遵循平行四边形法则，平行四边形法则如下图： 即以要进行加法的两个共起点向量为平行四边形的相邻边，做出完整的平行四边形，它们的和向量的起点与前两个向量起点相同，终点是平行四边形的对角顶点。上图中AD⃗=AB⃗+AC⃗\\vec{AD}=\\vec{AB}+\\vec{AC}AD=AB+AC。 和平行四边形法则等价的还有三角形法则： 即将其中一个向量的起点平移到另一个向量的终点处，和向量的起点是后者的起点，终点是前者的终点。上图中AD⃗=AB⃗+CD⃗,CB⃗=CD⃗+DB⃗\\vec{AD}=\\vec{AB}+\\vec{CD},\\vec{CB}=\\vec{CD}+\\vec{DB}AD=AB+CD,CB=CD+DB，注意向量的字母表示有先后顺序，因此AD⃗\\vec{AD}AD不可颠倒变成DA⃗\\vec{DA}DA，事实上DA⃗=−AD⃗\\vec{DA}=-\\vec{AD}DA=−AD。 在向量表示中：u=[xuyu],v=[xvyv],u+v=[xu+xvyu+yv]u=\\begin{bmatrix}x_u\\\\y_u\\end{bmatrix},v=\\begin{bmatrix}x_v\\\\y_v\\end{bmatrix},u+v=\\begin{bmatrix}x_u+x_v\\\\y_u+y_v\\end{bmatrix}u=[xu​yu​​],v=[xv​yv​​],u+v=[xu​+xv​yu​+yv​​]。因此向量相加，坐标相加。 减法则是坐标相减，将减数向量做反向同模长的反向量再进行加法运算即可。 由于矩阵可以拆分成一个个列向量和行向量，而且矩阵的加法与数乘均与刚刚介绍的向量的加法与数乘规则相同。因此矩阵具备表示向量组的条件，称之为向量空间。向量空间中定义的加法和数乘需要满足如下几条（假设x,y,z\\bold x,\\bold y,\\bold zx,y,z为向量，α,β\\alpha,\\betaα,β为标量/常数）： x+y=y+x\\bold x+\\bold y=\\bold y+\\bold xx+y=y+x (x+y)+z=x+(y+z)(\\bold x+\\bold y)+\\bold z=\\bold x+(\\bold y+\\bold z)(x+y)+z=x+(y+z) x+0⃗=x\\bold x+\\vec0=\\bold xx+0=x x+(−x)=0⃗\\bold x+(-\\bold x)=\\vec 0x+(−x)=0 α(x+y)=αx+αy\\alpha(\\bold x+\\bold y)=\\alpha\\bold x+\\alpha\\bold yα(x+y)=αx+αy (α+β)x=αx+βy(\\alpha+\\beta)\\bold x=\\alpha\\bold x+\\beta\\bold y(α+β)x=αx+βy (αβ)x=α(βx)(\\alpha\\beta)\\bold x=\\alpha(\\beta\\bold x)(αβ)x=α(βx) 1⋅x=x1\\cdot\\bold x=\\bold x1⋅x=x 好多啊ccc，其实就是需要把“加法”定义成正统的加法（满足交换律、结合律）；“数乘”定义为正规的数乘（满足结合律、分配律，没有交换律）。可以发现矩阵的加法和数乘和它完美匹配！因此矩阵可以作为一个向量空间。 于是，向量空间VVV中的元素称作向量。因为这个空间需要包罗万象，就像宇宙空间要包含我们赖以生存的地球一样……它包括我们所需要的向量，因此向量运算最基本的两种——加法与数乘运算所导出的结果必须也在向量空间VVV内，这叫做向量空间内加法和数乘的封闭性，向量空间必定符合这个性质。如此一来，向量空间VVV就足以作为向量所生存的“宇宙空间”了。 当然有时我们并不需要那么多空间，好比一个人住一个城市……先不提城市各项环节能否正常运作，如果只是用来溜达的，那也是太过巨大了，有些地方可能你一辈子也取不到，还不如开始就不要。向量空间其实也可以像这样压缩范围，并且压缩后的向量空间也必须是全集VVV的子集。根据向量空间的定义，该空间内的向量做任意加法和数乘运算得到的结果都得是空间内的向量。若向量空间VVV的子集SSS满足加法和数乘运算的封闭性，那么SSS是VVV的一个子空间。特殊地，{0}\\{\\bold 0\\}{0}与VVV都是VVV的子空间，{0}\\{\\bold0\\}{0}称作零子空间，其他非零且不等于VVV的子空间称作真子空间（类比集合的空集、子集和真子集概念）。 在矩阵中，也存在零空间。它表现为矩阵方程Ax=0Ax=\\bold0Ax=0在Rn\\bold R^nRn上的解集NNN。我们首先验证数乘封闭性，Aαx=α(Ax)=α⋅0=0∈NA\\alpha x=\\alpha(Ax)=\\alpha\\cdot\\bold0=\\bold0\\in NAαx=α(Ax)=α⋅0=0∈N；紧接着是加法封闭性：A(x+y)=Ax+Ay=0+0=0∈NA(\\bold x+\\bold y)=A\\bold x+A\\bold y=\\bold0+\\bold0=\\bold0\\in NA(x+y)=Ax+Ay=0+0=0∈N。封闭性得证，因此NNN是AAA的子空间。这种空间被称作矩阵的零空间，通常用N(A)N(A)N(A)表示AAA的零空间。 例4.1.1 Merusea Village Portal 海露村传送门 自从你来到枫丹，知晓了水仙十字结社的秘密之后，奇怪的事情开始在你身边上演…… 你在海露村遇见了抽象派美露莘大画师玛梅赫、以及一只发条机关狗西摩尔。很不巧，玛梅赫的作画颜料用完了，于是你们前去收集更加纯净的矿物颜料，期间玛梅赫邀请你们进入一个粉色的漩涡虫洞。或许是因为你前一天冒险到深夜，在这个温暖且舒适的环境下来了困意。一闭眼，再一睁眼，迎接你的不是如同往常一般的新地下区域——而是一片温暖的、舒适的粉色幻境——你被一个人丢在这个传送通道里了！ 为了不让派蒙着急，同时也为了你能尽快在下一次困意席卷前逃出这个空间，你需要确定这个传送门是否为“同维度空间卷曲型”——即传送过程中不发生维度的变化。你需要证明你身处的空间是一个三维空间的子空间，这样才能使用正确的方法逃出生天。你发现你的身高和体宽的比值是原来的一半、但是体宽不变。请证明你所在的空间是是三维空间的子空间。 问题分析：首先要根据已有的信息判断该向量空间是否为三维向量空间的子集，然后再验证加法与数乘的封闭性，只有当二者均成立时才能够证明该空间是三维空间的子空间。 算法设计：根据题干最后一句话，我们不妨将主人公设为三维坐标系原点，按照x,y,zx,y,zx,y,z三个坐标轴来建立变换关系。比如说“身高体宽比减半”代表的是现在的zzz轴是xxx轴的一半，假设原身高在zzz轴上有444个单位，而现在只有两个单位，证明现在的zzz轴被拉伸了一倍。最后关于封闭性的证明，设出几个具有普遍性的向量证明即可。 解：根据变换关系，得到该向量空间的集合形式S={[xyz]∣z=12x}S=\\left\\{\\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix}|z=\\frac{1}{2}x\\right\\}S=⎩⎨⎧​⎣⎡​xyz​⎦⎤​∣z=21​x⎭⎬⎫​。因此SSS为R3\\bold R^3R3的子集，令x=[2x2yy]x=\\begin{bmatrix}2x\\\\2y\\\\y\\end{bmatrix}x=⎣⎡​2x2yy​⎦⎤​， 数乘：αx=[2αx2αyαy]∈S\\alpha x=\\begin{bmatrix}2\\alpha x\\\\2\\alpha y\\\\\\alpha y\\end{bmatrix}\\in Sαx=⎣⎡​2αx2αyαy​⎦⎤​∈S；令a=[2ax2ayaz]a=\\begin{bmatrix}2a_x\\\\2a_y\\\\a_z\\end{bmatrix}a=⎣⎡​2ax​2ay​az​​⎦⎤​，b=[2bx2bybz]b=\\begin{bmatrix}2b_x\\\\2b_y\\\\b_z\\end{bmatrix}b=⎣⎡​2bx​2by​bz​​⎦⎤​，a+b=[2(ax+bx)2(ay+by)az+bz]∈Sa+b=\\begin{bmatrix}2(a_x+b_x)\\\\2(a_y+b_y)\\\\a_z+b_z\\end{bmatrix}\\in Sa+b=⎣⎡​2(ax​+bx​)2(ay​+by​)az​+bz​​⎦⎤​∈S，封闭性得证。 因此，所在空间SSS是三维空间的一个子空间。 后日谈：其实是你网卡了渲染出错了……和什么三维不三维空间没啥关系…… 第二节 基底、张成与张集 假设Rn\\bold R^nRn中有向量v1,v2,v3…vnv_1,v_2,v_3\\dots v_nv1​,v2​,v3​…vn​，那么α1v1+α2v2+α3v3+⋯+αnvn\\alpha_1v_1+\\alpha_2v_2+\\alpha_3v_3+\\dots+\\alpha_nv_nα1​v1​+α2​v2​+α3​v3​+⋯+αn​vn​称作向量v1,v2,v3…vnv_1,v_2,v_3\\dots v_nv1​,v2​,v3​…vn​的线性组合。向量v1,v2…vnv_1,v_2\\dots v_nv1​,v2​…vn​的所有线性组合构成的集合叫向量v1,v2…vnv_1,v_2\\dots v_nv1​,v2​…vn​的张成。 我们都知道，nnn个不共线向量唯一确定一个nnn维平面。假如有向量：a⃗=[113]T\\vec a=\\left[\\begin{array}{ccc}1&amp;1&amp;3\\end{array}\\right]^Ta=[1​1​3​]T和b⃗=[−12−1]T\\vec b=\\left[\\begin{array}{ccc}-1&amp;2&amp;-1\\end{array}\\right]^Tb=[−1​2​−1​]T。它们的张成就是（注：最好是验证两个向量在三维空间里的张成，既直观还符合常规认知）它们围成的nnn维平面。方才的a⃗\\vec aa和b⃗\\vec bb的张成如下图： 如果α1v1+α2v2+α3v3+⋯+αnvn=V\\alpha_1v_1+\\alpha_2v_2+\\alpha_3v_3+\\dots+\\alpha_nv_n=Vα1​v1​+α2​v2​+α3​v3​+⋯+αn​vn​=V，则称v1,v2…vnv_1,v_2\\dots v_nv1​,v2​…vn​张成VVV。用Span(v1,v2,…,vn)Span(v_1,v_2,\\dots,v_n)Span(v1​,v2​,…,vn​)表示。有以下两条性质： 若v1,v2,…,vn∈Vv_1,v_2,\\dots,v_n\\in Vv1​,v2​,…,vn​∈V，则Span(v1,v2,…,vn)Span(v_1,v_2,\\dots,v_n)Span(v1​,v2​,…,vn​)为VVV的子空间 向量平面VVV中一组向量的张成是VVV中包含这组向量的最小子空间 对于第一条，因为你怎么拟合平面，都不可能让你的平面比整个空间的维度更高，而且无论以什么系数搭配向量，它们所得的新向量都在整体空间内，第一条就能很简明的证明了。第二条性质，首先空间内向量的张成必为整个空间的子空间，毕竟用的都是数乘和加法，用的向量也都在空间内，总不能算一下加法向量就跑到空间外边去了吧，此外，因为数乘和加法的封闭性，任何经过这两个向量的空间都包含其张成，因此它是最小的。 和张成相对，如果v1,v2…vnv_1,v_2\\dots v_nv1​,v2​…vn​张成VVV，则VVV是v1,v2…vnv_1,v_2\\dots v_nv1​,v2​…vn​的张集。 基底，大家在高中立体几何部分学过了。当时的定义是：平面内不共线的两个向量叫做这个平面的一组基底。然而这段话可以用线性代数的语言原原本本描述出来：“在nnn维向量空间VVV中有nnn个线性无关的向量v1,v2,…,vnv_1,v_2,\\dots,v_nv1​,v2​,…,vn​，则称它们是向量空间的一组基”。线性无关的概念，之前已经简单讲过，总的来说就是向量不共线，即不存在标量α∈R\\alpha\\in\\mathbb Rα∈R，使得αv1=v2\\alpha v_1=v_2αv1​=v2​；线性相关则反之，指的是两个向量共线，即∃α∈R,αv1=v2\\exists\\alpha\\in\\mathbb R,\\alpha v_1=v_2∃α∈R,αv1​=v2​成立。正如在高中课堂上学的一样，给出一个nnn维空间的一组基底，该空间上所有的向量都可以用这组基底唯一地表示出来。比如下边这个例子： 例4.2.1 Al-Ahmar’s Trial 赤王的试炼 你和婕德一行人在圣显厅前击败了图谋不轨的镀金旅团，并在他们搭起的营帐里发现了一封密信。上面写着若想进入圣显厅，需先过三关试炼。为了能够一探黄金梦乡的秘密，你接下了完成三重试炼的任务，然而当你真正进入到第一重试炼时，却发现事情并没有这么简单…… 你进入了试炼场地，却发现整个世界天旋地转。最终安定下来，你发现赤王的神奇科技把你带入了一个nnn维空间内。这还没完，四周又有整齐排列的空气墙阻挡了你的通路。经过好一顿摸索，你终于发现这是一个555维空间，于是你开始建立空间坐标系，五个坐标轴分别是w,x,y,z,tw,x,y,z,tw,x,y,z,t，假设你现在所在的地方是原点O(0,0,0,0,0)O(0,0,0,0,0)O(0,0,0,0,0)，通关点P(4,2,−1,3,0)P(4,2,-1,3,0)P(4,2,−1,3,0)。四周的空气墙限制了你仅能沿着与向量a⃗=(2,2,0,1,3),b⃗=(−1,0,3,1,5),c⃗=(−2,0,0,4,1),d⃗=(1,1,2,6,7),e⃗=(1,1,2,2,6)\\vec a=(2,2,0,1,3),\\vec b=(-1,0,3,1,5),\\vec c=(-2,0,0,4,1),\\vec d=(1,1,2,6,7),\\vec e=(1,1,2,2,6)a=(2,2,0,1,3),b=(−1,0,3,1,5),c=(−2,0,0,4,1),d=(1,1,2,6,7),e=(1,1,2,2,6)平行的方向行动。请问如何安排前进方向使得你能够从起点OOO到达终点PPP？ 问题分析：这个问题明显是让我们用a⃗,b⃗,…,e⃗\\vec a,\\vec b,\\dots,\\vec ea,b,…,e来表示出从起点（原点）到终点的一个向量，因为这五个向量不共线，可以作为五维向量空间的一组基底。又因为基底可以唯一地表示出平面上的所有向量，考虑列方程组求解每个基向量的系数关系。 解：明显地，题中五个向量互相线性无关，因此可以作为该平面的一组基。由于向量加法和数乘运算的封闭性，且路径向量p⃗=(4,2,−1,3,0)\\vec p=(4,2,-1,3,0)p​=(4,2,−1,3,0)在该平面上，因此可以拆分成这些基向量的倍数和形式。 设p⃗=α1a⃗+α2b⃗+α3c⃗+α4d⃗+α5e⃗\\vec p=\\alpha_1\\vec a+\\alpha_2\\vec b+\\alpha_3\\vec c+\\alpha_4\\vec d+\\alpha_5\\vec ep​=α1​a+α2​b+α3​c+α4​d+α5​e，则有方程组{2α1−α2−2α3+α4+α5=42α1+α4+α5=23α2+2α4+2α5=−1α1+α2+4α3+6α4+2α5=33α1+5α2+α3+7α4+6α5=0\\begin{cases}2\\alpha_1-\\alpha_2-2\\alpha_3+\\alpha_4+\\alpha_5=4\\\\2\\alpha_1+\\alpha_4+\\alpha_5=2\\\\3\\alpha_2+2\\alpha_4+2\\alpha_5=-1\\\\\\alpha_1+\\alpha_2+4\\alpha_3+6\\alpha_4+2\\alpha_5=3\\\\3\\alpha_1+5\\alpha_2+\\alpha_3+7\\alpha_4+6\\alpha_5=0\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​2α1​−α2​−2α3​+α4​+α5​=42α1​+α4​+α5​=23α2​+2α4​+2α5​=−1α1​+α2​+4α3​+6α4​+2α5​=33α1​+5α2​+α3​+7α4​+6α5​=0​，方程组的解：{α1=2α2=1α3=−1.5α4=2.5α5=−4.5\\begin{cases}\\alpha_1=2\\\\\\alpha_2=1\\\\\\alpha_3=-1.5\\\\\\alpha_4=2.5\\\\\\alpha_5=-4.5\\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​α1​=2α2​=1α3​=−1.5α4​=2.5α5​=−4.5​ 因此，应在a⃗\\vec aa方向上移动2∣a⃗∣2|\\vec a|2∣a∣，在b⃗\\vec bb方向上移动∣b⃗∣|\\vec b|∣b∣，在c⃗\\vec cc的反方向上移动1.5∣c⃗∣1.5|\\vec c|1.5∣c∣，在d⃗\\vec dd方向上移动2.5∣d⃗∣2.5|\\vec d|2.5∣d∣，在e⃗\\vec ee的反方向上移动4.5∣e⃗∣4.5|\\vec e|4.5∣e∣就可以到达终点。 因此一旦选定了平面的基底，该平面上所有的向量都可以用这组基底唯一表示出来，具体操作是使待求向量u=α1v1+α2v2+α3v3+⋯+αnvnu=\\alpha_1v_1+\\alpha_2v_2+\\alpha_3v_3+\\dots+\\alpha_nv_nu=α1​v1​+α2​v2​+α3​v3​+⋯+αn​vn​，接着解方程求出系数α\\alphaα的值即可。 基底可以表示平面内所有的向量，故nnn维平面VVV的基张成VVV。 第三节 线性基 第二节里我们讲了向量空间的基底，基底其实还有一个名称叫线性基。平面中所有向量唯一对应一种基底的线性组合。在OI中常常被用于求第kkk大异或和的问题。为了和实数四则运算的线性基区分，这种线性基下称异或线性基 一组值的异或和可以看做该空间内异或线性基的向量的异或组合，由于基底表示向量的唯一性：原集合中的数可以通过异或线性基里的基向量唯一确定。它有如下几个性质，事实上，它和普通平面内的实数线性基有相似之处： 原序列中任何元素都可以通过异或线性基内的元素异或得到 异或线性基不存在重复元素，且在保证性质一的前提下，它的元素最少 异或运算也有一个特殊性质，若a xor b=ca\\;xor\\;b=caxorb=c，则a=c xor ba=c\\;xor\\;ba=cxorb 根据以上性质构造计算方法： 1234567891011void insert(ll x) &#123; for (int i = 63; i &gt;= 0; i--) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; // 要存放的数的当前位为1 if (!p[i]) &#123; p[i] = x; // 异或线性基该位为0，二进制下该位置为1 break; // 已找到位置存放，退出循环 &#125; x ^= p[i]; // 异或线性基该位为1，为化为下三角形矩阵形式方便计算置为0 &#125; &#125;&#125; 由于一般题目中数据范围是1e18，而转换为二进制位就有log⁡21018=18log⁡210≈60\\log_210^{18}=18\\log_210\\approx60log2​1018=18log2​10≈60位，因此数据类型最好选用无符号长长整型unsigned long long，线性基p数组至少需要60位。 有时并不是所有的插入操作都会成功，因为要保证异或线性基里的向量互相线性无关。存储操作本质上是拆分二进制位，然后将它尽量表示为已有基向量的异或和，好像除去每个人身上的共同特征，只保留人的独特个性一般。如果拆到最后再也拆不了了，证明它是独特的，可以加入其中。反之，这个数就可以被其他数通过异或运算代替，没必要加它，返回插入失败。可以有下面的代码： 123456789101112bool insert(ll x) &#123; for (int i = 63; i &gt;= 0; i--) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; if (!p[i]) &#123; p[i] = x; // 异或线性基该位为0，二进制下该位置为1 break; // 已找到位置存放，退出循环 &#125; x ^= p[i]; // 异或线性基该位为1，为化为下三角形矩阵形式方便计算置为0 &#125; &#125; return x; // 若被异或分解为0，则证明它可以被现有元素计算得到，为保证异或线性基元素互相线性无关，不予插入 &#125; 如果是求一个数能否被这个异或线性基表示出来，将最后一行改为return !x;即可（能表示即不可插入，不能表示即可以插入）。若某次插入失败，证明0\\bold 00可以被表示出来，在求最小值是要额外关注！我们在此维护一个布尔值flag = false，在插入失败后设为true表示需要特判000。 线性基用于求解一组数的异或和最值问题，有下面求最值的三个例子。它们无一例外使用了贪心法： 1. 求最大值 1234567ll xorMax() &#123; ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; ans = max(ans, ans ^ p[i]); &#125; return ans;&#125; 为什么从高位开始遍历？我们都知道如果一个数字的某位数大于另一个数字相同位置的数（两数数量级相同，即十进制下位数相同），那么前者是大于后者的。根据异或的运算法则：“不同为111，相同为000”。如果ans的高位此时是0，若进行异或运算的同位数字是0，即二者相同，结果为0，不会变得更小；反之若异或运算的对应二进制位为1，当前位异或结果是1，变大了，因此ans xor p[i]≥ans\\text{ans}\\;xor\\;p[i]\\geq\\text{ans}ansxorp[i]≥ans；如果ans高位为1，运算数对应位为0，结果为1，不会变得更大；若运算数当前位是1异或结果为0，变小了，所以ans xor p[i]≤ans\\text{ans}\\;xor\\;p[i]\\leq\\text{ans}ansxorp[i]≤ans。 2. 求最小值 1234567ll xorMin() &#123; ll ans = 0; if (flag) return 0; // 特判0 for (int i = 0; i &lt;= 63; i++) &#123; if (p[i]) return p[i]; &#125;&#125; 我们知道，可以通过任意组合（异或运算）异或线性基中的元素来得出各种新的元素，若0\\bold 00无法被表示出来，我们找到异或线性基里最小的元素即可，因为异或线性基里的每个元素也是原序列中某些元素的异或和；反之返回000。 3. 求第kkk小值 这才是异或线性基的高级玩法 为了求第kkk小值，首先要对异或线性基进行一轮清扫。将它高斯消元化简为最简形式，称作重构rebuild。 1234567void rebuild() &#123; for (int i = 63; i &gt;= 0; i--) &#123; // 从高位开始按位扫 for (int j = i - 1; j &gt;= 0; j--) &#123; // 遍历右移 if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; // 保证p[i]是异或线性基里第i位最小的那个，通过不断异或可以变小 &#125; &#125;&#125; 接着我们需要特判000，如果每一次插入都可以成功进行，向量之间互相线性无关，也就无法表示0\\bold 00。在求kkk小值时，若k=1k=1k=1，也就是说求最小值，明显应该返回000，如果按照常规思路返回f(k)f(k)f(k)就是错误的，因为这个做法的前提是f(1)≠0f(1)\\neq0f(1)​=0。所以如果先前的插入操作出现失败的情况，就要对000进行特判，原先的f(k)f(k)f(k)实为f(k−1)f(k-1)f(k−1)： 1234567891011121314ll queryKMax(ll k) &#123; if (k == 1 &amp;&amp; flag) return 0; // 特判 if (flag) k--; // 特判0，f(k)实为f(k-1) rebuild(); // 重构异或线性基 ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; if (p[i]) &#123; // 对k进行二进制分解 if (k &amp; 1) ans ^= p[i]; // 位为1，异或 k &gt;&gt;= 1; &#125; &#125; return ans;&#125; 除了求值，异或线性基还可以合并，甚至于求它和另一个异或线性基的交集与并集。所以异或线性基是一种数据结构。封装在一个结构体XorBase里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct XorBase &#123; ll p[64]; bool flag; XorBase() &#123; flag = false; memset(p, 0, sizeof p); &#125; bool insert(ll n) &#123; for (int i = 63; i &gt;= 0; i--) &#123; if ((n &gt;&gt; i) &amp; 1) &#123; if (!p[i]) &#123; p[i] = n; break; &#125; n ^= p[i]; &#125; &#125; if (!n) flag = true; return n; &#125; void rebuild() &#123; for (int i = 63; i &gt;= 0; i--) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; &#125; &#125; &#125; ll getMin() &#123; if (flag) return 0; for (int i = 63; i &gt;= 0; i--) &#123; if (p[i]) return p[i]; &#125; &#125; ll getMax() &#123; ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; ans = max(ans, ans ^ p[i]); &#125; return ans; &#125; ll MaxK(ll k) &#123; if (k == 1 &amp;&amp; flag) return 0; if (flag) k--; rebuild(); ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; if (p[i]) &#123; if (k &amp; 1) ans ^= p[i]; k &gt;&gt;= 1; &#125; &#125; return ans; &#125;&#125;; 4. 并集 思路就是枚举异或线性基AAA的内容，将其中元素全部加入到BBB中。 123456789XorBase Union(XorBase A, XorBase B) &#123; XorBase res = B; for (int i = 0; i &lt;= 63; i++) &#123; if (A.p[i]) &#123; res.insert(A.p[i]); &#125; &#125; return res;&#125; 5. 交集 如果一个异或线性基里的元素插入到另一个异或线性基里会失败，则将它插入到交集异或线性基中。 123456789101112XorBase Intersect(XorBase A, XorBase B) &#123; XorBase res; for (int i = 0; i &lt;= 63; i++) &#123; if (A.p[i]) &#123; if (!B.insert(A.p[i])) res.insert(A.p[i]); &#125; if (B.p[i]) &#123; if (!A.insert(B.p[i])) res.insert(B.p[i]); &#125; &#125; return res;&#125; 例4.3.1 DMG Bonus 核爆 作为一名资深神原玩家，你希望能在新限定五星角色初进卡池时尽快拿下全网首个999w核爆记录，以此证明自己的实力。现在你已经在游戏里做好了很多伤害加成型的食物，准备在boss战时一展身手。战斗开始时，你首先给角色吃下了基础食物（每局开始前必吃的食物），它的效果是在300秒内单角色爆发伤害增加70%70\\%70%，但是同时它有一个副作用…… 基础食物生效期内，如果角色吃下其他伤害加成型的食物，总伤害加成的百分比数值将是各种食物的伤害百分比数值的异或之和，即Dtotal=(⨁i=2nDi)×100%D_{total}=(\\bigoplus\\limits_{i=2}^{n}D_{i})\\times100\\%Dtotal​=(i=2⨁n​Di​)×100%，⨁i=1nDi\\bigoplus\\limits_{i=1}^{n}D_ii=1⨁n​Di​表示D1⊕D2⊕D3⊕⋯⊕DnD_1\\oplus D_2\\oplus D_3\\oplus\\dots\\oplus D_nD1​⊕D2​⊕D3​⊕⋯⊕Dn​，⊕\\oplus⊕为异或符号。各种食物的伤害加成在下边给出，如果不吃任何加成型食品（也不吃基础食品），爆发伤害期望值为140000014000001400000。吃完所有食物后，如果你用增伤角色施加了60%60\\%60%的爆发增伤。请问你的最大爆发伤害能否达到999999999999999999999，即107−110^7-1107−1？若不能，最高伤害是多少？（令每种食物只有一份，且食物效果均可叠加，结果四舍五入到万位） 编号 加成效果 1 270% 2 200% 3 280% 4 200% 5 180% 6 150% 7 75% 问题分析：题干信息已经很明显了，这是一道异或线性基的最大和问题。根据上文所述程序计算即可。 算法实现：这里使用的是结构体封装版本的异或线性基计算代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;struct XorBase &#123; ll p[64]; bool flag; XorBase() &#123; flag = false; memset(p, 0, sizeof p); &#125; bool insert(ll n) &#123; for (int i = 63; i &gt;= 0; i--) &#123; if ((n &gt;&gt; i) &amp; 1) &#123; if (!p[i]) &#123; p[i] = n; break; &#125; n ^= p[i]; &#125; &#125; if (!n) flag = true; return n; &#125; void rebuild() &#123; for (int i = 63; i &gt;= 0; i--) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; &#125; &#125; &#125; ll getMin() &#123; if (flag) return 0; for (int i = 63; i &gt;= 0; i--) &#123; if (p[i]) return p[i]; &#125; &#125; ll getMax() &#123; ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; ans = max(ans, ans ^ p[i]); &#125; return ans; &#125; ll MaxK(ll k) &#123; if (k == 1 &amp;&amp; flag) return 0; if (flag) k--; rebuild(); ll ans = 0; for (int i = 63; i &gt;= 0; i--) &#123; if (p[i]) &#123; if (k &amp; 1) ans ^= p[i]; k &gt;&gt;= 1; &#125; &#125; return ans; &#125;&#125; A;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; int x; cin&gt;&gt;x; A.insert(x); &#125; cout&lt;&lt;(1400000 * (A.getMax() + 60 + 70) / 100)&lt;&lt;endl; return 0;&#125; 运行代码，在输入框输入： 12345678727020028020018015075 结果输出：8162000.000。小于所给的107−110^7-1107−1。因而不能达到目标，最高伤害816万。 洛谷例题： P3812 [模板] 线性基 P4570 [BJWC2011] 元素 P4301 [CQOI2013] 新Nim游戏","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"数学","slug":"数学","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"教程","slug":"教程","permalink":"https://justpureh2o.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"2023年度总结——机房管理软件的破解经验","slug":"new-year-crack","date":"2023-12-31T12:22:54.000Z","updated":"2024-02-10T07:04:19.895Z","comments":true,"path":"2023/12/31/new-year-crack/","link":"","permalink":"https://justpureh2o.github.io/2023/12/31/new-year-crack/","excerpt":"","text":"文中提到的核心程序代码及食用方法在文章末尾处，或者访问我的云剪贴板来复制代码 极域——世界上最弱小最单纯的机房软件 注意，极域由C/C++语言开发。对于极域的反编译工作可以基本认定为徒劳且耗费大量时间的。 开始的开始，我的脱控方式还仅限于最原始的taskkill和ntsd。这种做法不仅有时会失效，而且一旦老师发现你的机子的监控屏幕是纯黑一片、且无法控制，他就会气急败坏地冲向你对你进行一顿输出，结果自然是被班主任教训一顿、这学期的信息课停上。 令人欣慰的是：这种低级脱控方式已经在学子之间渐渐隐没不见，取而代之的是层出不穷的脱控软件，例如JYTrainer、还有本人开发的ClassX（doge）等等…… 因为本人不会那些所谓的网络IP、频道更改之类的高科技东西，另一方面实现如上的功能多半需要辅助程序（容易被反脱软件检测到进程名）。本着精简实现、不易查封的原则，我从非exe层面出发，编写了一套脱控程序供大家伙们免费使用，毕竟人生苦短，及时行乐嘛（doge）。 板块一 TD到底是啥的缩写？ 你知道明明U盘里装着几个G的学习资料却无法在计算机课上给周边的同学炫耀是怎么样一种感觉吗？你知道明明想要打开小破站观看最爱的coser投稿的新擦边视频却被提示“该网站已被禁止”是什么样的感觉吗？ 出于以上两种痛苦的经历，我立志要写出能够禁止极域牛马功能的脚本。就先从U盘解禁和网络解禁两个方面入手！ Windows服务概述：打开任务管理器，选项卡里不仅有经典的“进程”选项、也有装机大佬们引以为傲的“性能”选项，可是我们今天的主角：“服务”选项却几乎无人问津。 类似于cmd的打开方式，服务管理器则需要在Win+R后输入services.msc来使用；你也可以通过任务管理器“服务”选项卡进入。那么什么是服务呢？ Windows服务是指系统自动完成的，不需要和用户交互的过程，可长时间运行的可执行应用程序。这些服务可以在计算机启动时自动启动，可以暂停和重新启动而且不显示任何用户界面。一个词概括就是：“幕后黑手”。开头立的flag就需要通过这种方式巧妙解决。 定位到极域安装目录：会发现下面有好多TD打头的文件，而当你在服务里面搜索时，你会发现一个惊人的巧合：TDNetFilter和TDFileFilter早已在你的机器上悄然运行了很久。看到它的名字，容易知道前者禁掉了你的网络、后者ban掉了你的U盘。如何终止服务呢？这也非常的简单： 在Windows系统中，与服务有关的命令是sc。要想停止某个服务，只需安装如下模式输入指令：sc stop [NAME]（NAME是服务名称）。于是我在ClassX的开头加入了如下的指令： 12sc stop tdnetfiltersc stop tdfilefilter 这样就结束了吗？然而并没有…… 板块二 可疑的程序 上一节里遗留了一个小问题：停止了服务后他就真的解禁了吗？事实并非如此：没过几秒，你的网络又会恢复到先前的状态、U盘再次被封杀。一切的一切都是因为两个不起眼的可疑程序…… ProcHelper64.exe和MasterHelper.exe——《我们俩》 有人问我当时是怎么发现的。首先需要知道，每个版本的Windows系统几乎都有一套特别的图标主题（图标存放在Shell32.dll中），现如今大部分机房电脑使用的是Win10系统，然而上述两个进程使用的是WinXP风格的图标，直接一眼丁真掏出taskkill秒了。真是实力坑队友。 因此ClassX里面还有这一段代码： 12345:ataskkill /f /t /im ProcHelper64.exetaskkill /f /t /im MasterHelper.exegoto a :a定义了一个函数a，中间是函数体，最后一行的goto a则是调用这个函数，注意goto a写在了a函数内部，起到了while (true) &#123;...&#125;的死循环作用。你也可以在空行出添加一段TIMEOUT /T 1，即延时一秒，因为这两个程序的复活时间大概在1秒左右（终止后一秒就会重启）。 板块三 拒绝访问什么鬼？ 第一种情况：钩子程序 如果你是Win7及以下的系统，且直接使用任务管理器结束进程，那么很有可能会出现像标题这样的提示。这是因为极域启动了一个系统钩子（四川人莫笑，Hook翻译过来的确是钩子的意思）。 Windows钩子概述：类似于游戏（以及Scratch）的消息机制，Windows中存在一种事件系统，Win+R弹出运行、输入eventvwr.exe/eventvwr.msc打开事件管理器，你会看到本机所有事件的发生时间及概况。把Windows系统的事件系统比作一条河流，最上游是系统，负责抛出事件，事件信息顺流而下；把应用程序比作渔夫，它们在河岸两侧用网捞特定类型的事件，大多数情况下自行处理后再放回到河中。 对于极域来说，它在一个名叫NtTerminateProcess的系统函数上下钩，检测这个函数的传入信息，即终止对象的进程名，是否是StudentMain.exe（极域主程序），若是，就返回false，也就是失败。因而导致开头所说拒绝访问的情况，而把钩子钩在此处的，就是我们的TD圈大佬LibTDProcHook.dll。因为本人使用Win10系统，这个钩子对于Win7以后的系统都会失效，因此Win8/10/11用户可以直接用任务管理器。对于Win7系统用户，在这里使用WinAPI终止这个TD模块。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;processthreadsapi.h&gt;using namespace std;DWORD GetPID(const char* proc) &#123; PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(snapshot, &amp;entry) == TRUE) &#123; while (Process32Next(snapshot, &amp;entry) == TRUE) &#123; if (stricmp(entry.szExeFile, proc) == 0) &#123; HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, entry.th32ProcessID); DWORD pid = GetProcessId(hProc); CloseHandle(hProc); return pid; &#125; &#125; &#125;&#125;int main() &#123; HMODULE hook = GetModuleHandle(&quot;LibTDProcHook64.dll&quot;); FreeModule(hook); HANDLE handle = OpenProcess(PROCESS_TERMINATE, FALSE, GetPID(&quot;StudentMain.exe&quot;)); TerminateProcess(handle, 0); return 0;&#125; 第二种情况：时代变了 自从学校机房的极域从2014版更新到了2020版，上述朴素解决方案已经不见效了。我也不知道从哪一年的版本开始，它给自己的服务加了一层防护，普通地运行bat脚本还木有用。但是它解决起来也简单，右键文件“以管理员模式运行”即可。 除此之外，你还可以在脚本开头加入： 1234567891011&gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit) 来实现UAC自动提权管理员！ 板块四 挂起进程 有一天我的同学给我推荐了这个方法，说是用一个命令行程序Suspend来命令层面挂起极域进程实现随意脱控，亲测有效。如果使用性能监视器也可以达到相同效果。 挂起为何物？ 大家可能有过这样的经历：当你用WPS做PPT或者正在用WPS演示PPT时，有时它会莫名其妙地卡掉，尤其是你画了太多墨迹注释时，看着永不停歇转动的“繁忙”鼠标图标，你也许会耐不住性子直接任务管理器结束进程，并发誓要下载一个破解版的微软Office全家桶来用。像这样，程序的卡死就是挂起的一个形式，当然，当CPU面临有限的内存分配问题时，它会优先分配运存给那些需要内存的重要程序而把不那么重要的进程挂起，表现为对用户操作无响应等。 那么你可能已经猜到了这一方法的逻辑了：我们挂起极域主进程。这样当教师端发送指令（黑屏安静、全屏广播等）时，你这边的极域接收端（学生端）就无法对指令作出响应，自然也就不会被控制。桌面监控同理，也会被影响，不同的是，教师端的监控小窗只会定格在你挂起极域前传输过来的最后一帧画面，总之瞒天过海是基本上没问题的了…… 根据上述原理，我们有两种方式来挂起一个进程（其实本来还有Win32API这种方法，留给读者自行研究）： 第一种 性能监视器 你可以打开任务管理器，在“性能”一栏的左下角可以看到“性能监视器”选项（Win10），对于Win11用户，则需点击“性能”栏右上角三个点，然后选中“性能监视器”；也可以Win+R输入perfmon.exe /res直接打开（万能）。还有几种方法见百度百科。 在性能监视器中，我们在最上面“进程”列表中找到StudentMain.exe（一般来说有两个同样的进程），接着挨个右键点击“暂停进程（S）”即可。 但是这样的话，你在教师端那边的小窗口上就会显示出一个性能监视器的窗口，感觉不太完美，怎么能优化一下呢？ 第二种 Suspend命令行 这里可以下载 下载后的压缩文件里面有一个.cmd文件，用记事本打开： 12345chcp 65001@set suspend_targets=osu!.exe DDLC.exe@suspend.exe %suspend_targets%pause@suspend.exe -r %suspend_targets% 其实我们真正需要修改的内容是第二行：它使用bat批处理脚本设置变量suspend_targets，传入需要挂起进程的进程名称话说DDLC是真的生草……。这里我们修改参数值为StudentMain.exe： 12345chcp 65001@set suspend_targets=StudentMain.exe@suspend.exe %suspend_targets%pause@suspend.exe -r %suspend_targets% pause之后的那一行是解除挂起的代码，因为bat执行到pause语句后会等待用户输入任意字符后才继续进行，因此如果遇到紧急情况需要解除挂起，只需在命令行窗口点击任意键即可。 需要注意的是，一定要把下载好的压缩包里面的所有文件放到同一个目录下，否则缺失任何文件这个工具都是无法正常运行的。 板块五 留给2024的一个小问题 那天我在思考如何一劳永逸的结束极域进程，我打开了服务列表，在里面看到两个纯大写拼成的服务名GATESRV和STUDSRV。可惜的是那天放学，我没能来得及探究清楚这两个服务与极域的关系，目前已知的信息就是它们绝对是极域自己启动的两个服务。 这个问题就留给2024的我解决吧 // TODO 红蜘蛛软件——可曾听闻我绿蜘蛛脚本的厉害？ 在本人印象中，红蜘蛛似乎就仅仅只是一个吉祥物，只有在开机后那么几秒，它拖着上世纪复古风的“高清”启动界面在我的眼前一闪而过，然后静静地躲在任务栏的小图标里，践行它大隐隐于市的人生信条…… 说实话要不是同学提醒我还真忘了机房里还有这位叫红蜘蛛的朋友，于是我着手开始破解它。红蜘蛛：我吃柠檬 1. 这玩意怎么跟2345一个德行？ 知道2345全家桶的同学们肯定对它恨之入骨，尤其是那些下载了2345的同学们。2345号称天朝第一大流氓软件，在无数人的电脑中如同鬼魂一般挥之不去。捆绑安装、弹窗广告、强制修改系统文件、浏览器劫持……无奇不有，关键是它的公司甚至推出极其出生的“推广包”机制来诱惑不良商户分发2345毒瘤软件。这篇文章介绍了清除2345的一种方案。 回到本节主题上来，为什么会取这样一种怨气十足的标题呢？是因为它和2345伪装成系统文件类似，红蜘蛛属于是反向利用了系统文件来给自己加上一层保护网。 打开任务管理器，除了霸占后台程序第一行的红蜘蛛本体，下面还有两个附属程序，名叫“3000soft通用组件”，如果直接终止进程，它很快会再次冒出来。将它们展开后发现叫做checkrs.exe和rscheck.exe的程序。那么运用上边经常用到的服务搜查法，我们发现了两个命名规则极其相似的服务：appcheck2和checkapp2。 然而我事后才发现红蜘蛛官网早已自报家门了……血亏！ 常规思想：我们使用sc命令结束这两个服务，然而…… // TODO 显示无法停止，那怎么办呢？ 考虑到这两个进程是红蜘蛛死掉后无限重启的命根，并且这两个进程也跟红蜘蛛主程序一样杀了就会重启……很明显，根本原因就是那两个服务，但是sc命令不管用了，咋办呢？（抠头） 这时我们就需要绕道而行，既然命令不行，我们转战注册表！打开注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services文件夹，它有很多个子文件夹，在下面定位到appcheck2和checkapp2，它的文件结构类似于这样（这里用别的服务替代一下）： （注意，这个并不是红蜘蛛的服务，是我临时找别的替代的，它们的文件名相同，只是数据不同而已） 容易发现：ImagePath项指向了服务的根文件地址，也就是俗称的万恶之源，既然每次终止组件后它会自动重启服务，那我们为何不破坏这个ImagePath，让它指向一个不存在的地址，这样它就启动不了任何东西了。在我的绿蜘蛛inf文件里如此写到： 123456789101112[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 然后你就可以用任务管理器终止两个通用组件，紧接着就可以终止红蜘蛛了！ 由于本人目前对红蜘蛛知之甚少，可以看这篇文章了解更多！ 学生机房管理助手——闻着臭吃着香 1. 不用逆向，能得到什么结论？ 其实一开始我以为它和极域一样是基于C++/C开发的因此无法反编译，直到回家之后我自己下载了一个。杀毒软件报毒删除了set.exe，打开main.exe主入口程序时它突然弹出了一条C#式的通知框提示set.exe未找到。于是果断打开dnSpy开启后面的破解，反编译破解的内容将在后面涉及到。 首先看到他的文件目录↓ 其中zy文件夹中存放的是各种浏览器的exe可执行文件，猜测是覆盖现有的高版本浏览器，以便它操作注册表禁止各种功能。 有一定经验的同学想必会一眼看到可疑的yl.reg注册表文件，但是先别急着合并注册表。首先，你的机器可能已经被禁用了注册表和任务管理器；第二，这个文件里也不是你心心念念的破解注册表（虽然后面我们会利用它破解机房管理助手）。对于未知的事物，最好还是保持谨慎勿近的态度为好…… 除此之外，一个名叫jfglzs.exe的程序吸引了我，根据我多年混迹于首拼梗圈的我一秒钟就反应过来，知道它就是“机房管理助手”的首拼。我们之后的破解也围绕着这个东西进行。 第一问 任务管理器、注册表、组策略咋解 本人Win11系统，正常情况下任务栏设置上端会有一个任务管理器选项。 如果你稍微懂一点高级知识，你也许会使用Win+R，并输入taskmgr试图使用任务管理器。然而这不可能奏效，因为你会接到一则提示： 输入regedit（注册表）和gpedit.msc（组策略管理器）也是一样的道理。很少很少的高材生会使用mmc试图加载组策略，但是这样也不可能奏效。搜索资料发现，修改注册表的某些键值可以实现禁用组策略、注册表、任务管理器的功能。深度分析yl.reg时就会发现这些东西： 第一行翻译过来就是：“禁用任务管理器”，它的值被设置成了1，也就是true。这一块还有禁止更改密码、禁止切换用户的设置等等。对于组策略，它的两个值则是存放在注册表：HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC中的RestrictToPermittedSnapins；和它的子目录HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;中的Restrict_Run。如果不出意外，它们的值都是非零的，意味着组策略被禁用了。要想破解，我们就需要用一个不直接调用注册表的方式来添加/更改注册表值，这也就是下面将要提出的inf安装文件法。 INF安装文件的机制 提起绿色版软件，大家应该不会陌生，它省去了冗杂的dll等库文件，仅仅一个exe文件驱动整个程序。在绿色版软件安装时，有时就是用的inf文件安装法。一个可运行的inf文件包含几个项： 123[Version]Signature=&quot;$CHICAGO$&quot;Provider=somebody Version段包含inf文件的基本信息，其中Signature指定了文件的适用系统，常见的值有MS、WindowsNT等，这里我们使用CHICAGO获得最广泛的支持（注意美元符号和引号的书写）。 123[DefaultInstall]DelReg=DeleteAddReg=Add 这一段声明了安装时所需的函数，DelReg负责删除注册表，AddReg负责创建/修改注册表。基本语法如下： DelReg：[ROOT] [PATH] [NAME]，ROOT就是注册表中HKEY开头的那些，你可以写全称，也可以写缩写形式（HK+后两个单词的首字母，HKEY_LOCAL_MACHINE=HKLM）；PATH是包含指定键值的文件夹路径；NAME就是键值的名字。 AddReg：[ROOT] [PATH] [NAME] [TYPE] [VALUE]，TYPE指定了注册表值的类型（0相当于缺省，默认字符串；1为DWORD值，设置十六进制值时只需两个数字一组，中间逗号分隔开，一定保证输入的十六进制为8位，一定记得写前导0！）；VALUE即为键值，值为字符串时需要在前后打上半角双引号。 等号右侧的值相当于C++中的typedef，用来重命名函数，因此，在后续的安装代码中，我们的字段标识符都要与等号右侧的值相符才可，在我们的inf中，它表现为这样（inf文件的注释用分号表示）： 12345678910111213[Delete]HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableCMD&quot;[Delete]HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot; 在记事本里编辑即可，记得保存为.inf文件，而后右键“安装”，或者在cmd里运行：InfDefaultInstall + inf文件地址（前提是你的cmd没被禁止）。 除此之外，我们发现了一些好玩的东西：yl.reg的最后几十行，将常用浏览器的起始界面通过注册表的方式修改成了它的官网，学有余力的娃们可以通过刚才介绍的AddReg函数把它的值改成你想要的值，在这里我换成了我精心制作的嘲讽页面： 1234567891011[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; yl.reg——队友坑害全队的典型例子。 当一切完成之后，你就可以自由使用任务管理器了，被锁定了cmd的同学们也可以尽情使用taskkill了！诶等等，事情好像有点不对劲…… 第二问 我的taskkill去哪了 可是我的taskkill还好好地躺在System32文件夹里啊 机房管理助手一启动，所有使用taskkill的脚本/程序都会失效，属于是老阴B了。如果不逆向破解，我还真不清楚这是怎么做到的。总之你可以在网站上下载一个taskkill（对上网下载一个下来），或者顶住巨大的学习难度学习WinAPI（TerminateProcess函数）写出一个拔山盖世的C++程序来。这一节就不多赘述其他内容了…… 第三问 yl.reg到底写了啥 其实最扎眼的就是它里面写的宣（补）战（贴）名单各种脱控工具箱，说实话那些工具箱软件我基本上一个都没见过…… 这些注册表项有一个很普遍的特征，它们无一例外指向了注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Hashes下很多以GUID形式命名的文件夹，那么这些文件夹具体起什么作用呢？ 这其实是组策略管理器的黑名单，具体见此，没错，组策略可以限制指定软件的运行。但是很遗憾，这些配置全部存放在上述的注册表里面。你可以把注册表看做系统的配置文件，操作系统几乎所有配置信息、甚至包括大部分软件程序的配置都存放在注册表中。这么看来除了BIOS没别的安全地方了 如果想要禁用这些项，并不需要挨个将每个文件删去，而是看到他的其中一个父文件夹codeidentifiers。它里面有一个二进制值authenticodeenabled，它指定组策略黑名单的ID标识符，也就是codeidentifier文件夹下以数字命名的文件夹，只有当子文件夹的名称与ID标识符相同时才会启用该文件夹下的配置。因此我们釜底抽薪，直接更改authenticodeenabled的值： 12[Add]HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14 假如我掏出逆向工具，阁下又该如何应对？ 正如开头所说，学生机房管理助手由C#开发，因此可以用dnSpy反编译它的可执行文件，得到源码。那么我们就开始吧！ 第一框 密码是啥 正如大多数软件那样，机房管理助手对它的源代码进行了一轮套壳，也就是代码混淆。为了让代码变成我们都容易看的形式。我们使用C#脱壳软件NET Reactor Slayer进行反混淆（代码混淆工具为NET Reactor）。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Security.Cryptography;using System.Text;using System.IO;public class Program&#123; public static void Main() &#123; // 更改这里的内容 string string_3 = &quot;12345678&quot;; // Class6.smethod_0() string value = &quot;C:\\\\WINDOWS&quot;; string s = value.Substring(0, 8); string s2 = value.Substring(1, 8); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); descryptoServiceProvider.Key = Encoding.UTF8.GetBytes(s); descryptoServiceProvider.IV = Encoding.UTF8.GetBytes(s2); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write); StreamWriter streamWriter = new StreamWriter(cryptoStream); streamWriter.Write(string_3); streamWriter.Flush(); cryptoStream.FlushFinalBlock(); memoryStream.Flush(); string string_4 = Convert.ToBase64String(memoryStream.GetBuffer(), 0, checked((int)memoryStream.Length)); // Class6.smethod_3() StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; string_4.Length; i++) stringBuilder.Append((char)(string_4[i] - 10)); string_3 = stringBuilder.ToString(); // Class6.smethod_2() MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider(); byte[] array2 = md5CryptoServiceProvider.ComputeHash(Encoding.Default.GetBytes(string_3)); stringBuilder.Clear(); for (int i = 0; i &lt; array2.Length; i++) stringBuilder.Append(array2[i].ToString(&quot;x2&quot;)); string str = stringBuilder.ToString().Substring(10); Console.WriteLine(str); &#125;&#125; 同时，机房管理助手的密码MD5文件存放在注册表HKEY_CURRENT_USER\\Software下的字符串值n里面。更改即生效！ 代码环节 ClassX 使用方法：另存为.bat文件直接运行 12345678910111213141516171819202122232425262728293031@echo off &gt;nul 2&gt;&amp;1 &quot;%SYSTEMROOT%\\System32\\cacls.exe&quot; &quot;%SYSTEMROOT%\\System32\\config\\system&quot; if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command &quot;Start-Process &#x27;%0&#x27; -Verb RunAs&quot; exit)sc stop tdnetfiltersc delete tdnetfiltersc stop tdfilefiltersc delete tdfilefiltersc stop GATESRVsc delete GATESRVsc stop STUDSRVsc delete STUDSRVregedit /c /s usb_reg.regecho Unhook through Regedit:ataskkill /f /t /im MasterHelper.exetaskkill /f /t /im ProcHelper64.exeTIMEOUT /T 1goto a 绿蜘蛛 使用方法：另存为.inf文件→右键安装；任务管理器先结束进程3000soft通用组件，再结束红蜘蛛软件 1234567891011[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\appcheck2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\rschck.exe&quot;HKLM,&quot;SYSTEM\\CurrentControlSet\\Services\\checkapp2&quot;,&quot;ImagePath&quot;,0,&quot;C:\\Windows\\SysWOW64\\chekrs.exe&quot; 学生机房管理助手通用破解 使用方法：另存为.inf文件→右键安装 123456789101112131415161718192021222324252627282930313233343536373839404142[Version]Signature=&quot;$CHICAGO$&quot;Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=Add[Delete] ; 大坏蛋，放开那个组策略管理器！HKCU,&quot;Software\\Policies\\Microsoft\\MMC&quot;,&quot;RestrictToPermittedSnapins&quot;HKCU,&quot;Software\\Policies\\Microsoft\\MMC\\&#123;8FC0B734-A0E1-11D1-A7D30000F87571E3&#125;&quot;,&quot;Restrict_Run&quot;[Delete] ; 注册表和任务管理器我来接手，你可以卷铺盖走人了！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableRegistryTools&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableTaskMgr&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableChangePassword&quot; HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableCMD&quot;[Delete] ; 我就要切换用户！HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;DisableSwitchUserOption&quot;HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;HideFastUserSwitching&quot;[Delete] ; 如果把我桌面搞乱了张伟会清理掉我的文件滴HKCU,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer&quot;,&quot;DesktopProcess&quot;[Add] ; 加点料才香~HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers&quot;,&quot;authenticodeenabled&quot;,1,00,11,45,14HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoConfigPage&quot;,1,00,00,00,01HKLM,&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System&quot;,&quot;NoDevMgrPage&quot;,1,00,00,00,01[Add] ; 嘲讽一波这sb管理助手，关键你就算换成自己的网页学校的破网也加载不出来（笑）HKLM,&quot;SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Microsoft\\Internet Explorer\\MAIN&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKLM,&quot;SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Default_Page_URL&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;.DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;HKEY_USERS,&quot;S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main&quot;,&quot;First Home Page&quot;,0,&quot;https://justpureh2o.github.io/misc/&quot;; TODO 再给你多附赠几个浏览器hhHKCU,&quot;Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Storage\\microsoft.microsoftedgedevtoolsclient_8wekyb3d8bbwe\\MicrosoftEdgeMain&quot;,&quot;Start Page&quot;,0,&quot;https://justpureh2o.github.io/2023/12/24/cracked-23-12-23&quot; ; Edge 浏览器主页","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"DC Doujin 2023 EP1 一触即发正式发布","slug":"dcdep1-release","date":"2023-12-03T05:02:42.000Z","updated":"2023-12-03T05:32:34.969Z","comments":true,"path":"2023/12/03/dcdep1-release/","link":"","permalink":"https://justpureh2o.github.io/2023/12/03/dcdep1-release/","excerpt":"","text":"","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"信竞初等数论导论","slug":"number-theory-junior","date":"2023-11-26T01:37:52.000Z","updated":"2024-01-06T07:12:26.780Z","comments":true,"path":"2023/11/26/number-theory-junior/","link":"","permalink":"https://justpureh2o.github.io/2023/11/26/number-theory-junior/","excerpt":"","text":"引入 如果说数论是数学体系中专门用来研究数字性质的一个分支，那么初等数论则是对整数的性质进行系统性的探讨与研究。千万不要因为其中的“初等”二字小瞧这初等数论尽管名称和学习难度上都没有高等数论那么有逼格，就像初等数学之于高数，数论的所有内容均筑基于此。其中欧几里得证明的算数基本定理（一切合数都可被分解为有限个质数的乘积）在质数筛、GCD（以及LCA)计算、无理数证明等问题上均有用武之地。可以说高等数论奠基于初等数论。它同时也是初学者接触数论的必经之路。 Part1. 前置知识 Div1. 数论有关定理 算术基本定理：每一个合数都可以被分解为有限个质数的乘积。即对于任意合数nnn，都存在： n=p1c1p2c2p3c3...pkckn=p_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}n=p1c1​​p2c2​​p3c3​​...pkck​​，其中ppp为质数。 推论一：正整数nnn的正因数集合为： {n=p1b1p2b2p3b3...pibi∣1≤bi≤ci,1≤i≤k}\\{n=p_{1}^{b_1}p_{2}^{b_2}p_{3}^{b_3}...p_{i}^{b_i} \\mid 1 \\leq b_i \\leq c_i, 1 \\leq i \\leq k\\}{n=p1b1​​p2b2​​p3b3​​...pibi​​∣1≤bi​≤ci​,1≤i≤k} 推论二：正整数nnn的正因数个数为：τ(n)=(c1+1)⋅(c2+1)⋅(c3+1)...(ck+1)=∏i=1k(ci+1)\\tau (n)= (c_1+1) \\cdot(c_2+1) \\cdot (c_3+1) ... (c_k+1) =\\prod_{i=1}^{k}\\left( c_i+1\\right) \\\\τ(n)=(c1​+1)⋅(c2​+1)⋅(c3​+1)...(ck​+1)=∏i=1k​(ci​+1) 推论三：正整数nnn的所有正因数之和为 σ(n)=(p1+p12+...+p1c1+1)×(p2+p22+...+p2c2+1)×...×(pk+pk2+...+pkck+1)=∏i=1kpkck+1pk−1\\sigma(n)=(p_1+p_1^2+...+p_1^{c_1}+1)\\times (p_2+p_2^2+...+p_2^{c_2}+1)\\times...\\times (p_k+p_k^2+...+p_k^{c_k}+1)=\\prod_{i=1}^{k}\\frac{p_k^{c_k+1}}{p_k-1}σ(n)=(p1​+p12​+...+p1c1​​+1)×(p2​+p22​+...+p2c2​​+1)×...×(pk​+pk2​+...+pkck​​+1)=∏i=1k​pk​−1pkck​+1​​ 质数分布定理：区间[1,N][1,N][1,N]中，当N→∞N\\to \\inftyN→∞时，质数个数π(x)≈nln⁡n\\pi (x)\\approx \\frac{n}{\\ln n}π(x)≈lnnn​。 费马小定理： 若ppp是一个质数，则ap≡a mod pa^p\\equiv a\\bmod pap≡amodp（≡\\equiv≡为同余符号）。 欧拉定理（费马小定理扩展）： 若a⊥na\\perp na⊥n（aaa与nnn互质），则有aφ(n)≡1 mod na^{\\varphi{(n)}} \\equiv 1 \\bmod naφ(n)≡1modn，其中φ(n)\\varphi(n)φ(n)为欧拉函数。 Div2. 同余 同余，顾名思义，两个数分别除以一个正整数mmm后得到相同的余数。即a mod m=b mod ma\\bmod m=b\\bmod mamodm=bmodm。但是它的定义给出了这样一句话：“对于正整数aaa和bbb，若(a−b)∣m(a-b)\\mid m(a−b)∣m（a−ba-ba−b能被mmm整除），则称aaa和bbb对模mmm同余，记作a≡b(modm)a\\equiv b\\pmod ma≡b(modm)”。当然以上两种说法是等价的。 同余具有以下三种基本性质： 反身性：对于任何正整数aaa，a≡a(modm)a\\equiv a\\pmod ma≡a(modm) 对称性：即对于a≡b ( mod m)a\\equiv b\\;(\\bmod m)a≡b(modm)，有b≡a(modm)b\\equiv a\\pmod mb≡a(modm) 传递性：若a≡b(modm)a\\equiv b\\pmod ma≡b(modm)，且b≡c(modm)b\\equiv c\\pmod mb≡c(modm)，有a≡c(modm)a\\equiv c\\pmod ma≡c(modm) 当然，它可以延申到计算机的模运算（毕竟出现了 mod \\bmodmod）。模运算有三种基本运算： 加运算：(a+b)%m=(a%m+b%m)%m(a+b)\\% m=(a\\% m+b\\% m)\\% m(a+b)%m=(a%m+b%m)%m 减运算：(a−b)%m=(a%m−b%m)%m(a-b)\\%m=(a\\%m-b\\%m)\\%m(a−b)%m=(a%m−b%m)%m 乘运算：(a⋅b)%m=((a%m)∗(b%m))%m(a\\cdot b)\\%m=((a\\%m)*(b\\%m))\\%m(a⋅b)%m=((a%m)∗(b%m))%m 还有两个推论： 幂运算：ab%p=((a%p)b)%pa^b\\%p=((a\\%p)^b)\\%pab%p=((a%p)b)%p 求和运算：(∑x=1nx)%p=(∑x=1nx%p)%p(\\sum\\limits_{x=1}^{n}x)\\%p=(\\sum\\limits_{x=1}^{n}x\\%p)\\%p(x=1∑n​x)%p=(x=1∑n​x%p)%p 同余消去原则： 若同余号两端的项相等，且都与模nnn互质，则可以同时消去 举例：a⋅c≡b⋅c mod na\\cdot c\\equiv b\\cdot c \\bmod na⋅c≡b⋅cmodn，如果gcd(c,n)=1gcd(c,n)=1gcd(c,n)=1，则a⋅c≡b⋅c⇒a≡b mod na\\cdot c\\equiv b\\cdot c\\Rightarrow a\\equiv b \\bmod na⋅c≡b⋅c⇒a≡bmodn。 Part2. 质数 质数的判断：除了它自身PPP以及111以外，不存在其他正整数NNN使得N∣PN\\mid PN∣P。 Div1. 质数判断 试除法： 这是三种方法中，唯一一种能做到100%正确的质数判断方法。对于给定数nnn，遍历所有[2,n][2,\\sqrt n][2,n​]间的正整数mmm，若出现m∣nm\\mid nm∣n则证明它不是质数，因为质数只能被1以及它本身整除。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及、提高 试除法の大胜利！ 费马素性检验： 是上述费马小定理的实际运用，它与常规算法思想有所不同：它主张在[2,n−1][2,n-1][2,n−1]中随机选取一个数aaa。若出现与费马小定理不符的情况，那么nnn一定为合数；若每次均符合定理，称为 费马伪素数 ，因为它很大概率是一个质数。 1234567891011bool isPrime(int n) &#123; if (n &lt;= 2) return false; int k = 10; while (k--) &#123; srand(time(0)); int a = rand() % (n - 2) + 2; if (__gcd(a, n) != 1) return false; if (qpow(a, n - 1, n) != 1) return false; &#125; return true;&#125; 复杂度：O(klog⁡n)\\mathcal O(k\\log n)O(klogn)，其中kkk为随机数检验次数，log⁡n\\log nlogn是因为使用了快速幂算法。 适用范围：提高T2及以下（慎用） 为什么用该方法判断的质数 大概率 是个质数呢？不妨测试一下561（3）、1105（5）、1729（7）（括号内为它的最小因子），你会发现函数的返回值均为true，即都为质数。可见这个算法不是100%正确的，这些“漏网之鱼”被称为“Carmichael数”。它们极其罕见，一亿范围内仅255个。也因如此，你可以通过打表特判的方式抠掉这些特例（你保证记得住就行）。2016年中国物流工人余建春给出了一个Carmichael数的判断准则，这个标准目前在国际上得到了广泛认同。 对于优化，你可以在函数起始点加入类似于if (n % 2 == 0 || n % 3 == 0) return false;的特判，进一步降低复杂度。 Miller-Rabin算法： 该算法同样无法保证结果100%准确，慎用！ MB算法实质上是对费马素性检验算法的效率和准确度优化。算法流程如下： 将n−1n-1n−1分解为2s+d2^s+d2s+d的形式，其中ddd为奇数 从[2,n−2][2,n-2][2,n−2]中选取整数aaa，称为“基数” 计算ad mod na^d \\bmod nadmodn的值，若结果为111或n−1n-1n−1，则可能为质数，继续检验 若结果不等于111或n−1n-1n−1，计算a2d mod na^{2d} \\bmod na2dmodn、a4d mod na^{4d} \\bmod na4dmodn、a6d mod na^{6d} \\bmod na6dmodn……a2s−1d mod na^{2^{s-1}d} \\bmod na2s−1dmodn的值，若结果等于n−1n-1n−1，则可能为质数，继续检验 若都不等于111，则nnn一定是合数。称为强费马证据。 当然，它同样有特例，称为强伪质数，如2047（23）、3277（29）、4033（39）等（括号内为它的最小因子）。 Div2. 质数筛 常见的质数筛法有：试除法、埃氏筛、线性筛。 试除法：从质数定义出发，即存在一个正整数NNN，对于任意[2,N][2,\\sqrt N][2,N​]间的正整数MMM，总有N mod M≠0N\\bmod M \\neq 0NmodM​=0成立。代码实现只需枚举[2,N][2, \\sqrt N][2,N​]间所有正整数，并让NNN对其取余。若取模运算出现000则代表它不为质数，没有出现000则为质数。 123456bool isPrime(int n) &#123; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 复杂度：O(N)\\mathcal O( \\sqrt N )O(N​) 适用范围：普及T2及以下 这里所展示的试除法代码实际上经过一轮优化。若严格根据质数定义，第二行的循环上限应为n−1n-1n−1。考虑到如下性质：∀m∈[2,N]\\forall m\\in [2,\\sqrt N]∀m∈[2,N​]，若m∣Nm\\mid Nm∣N，则一定有Nm∣N\\frac{N}{m}\\mid NmN​∣N。因此可以将循环上限压缩至N\\sqrt NN​。 埃氏筛：全称叫埃拉托斯特尼筛法，老哥生活在2200年前的古希腊，不借助望远镜就计算出了地球的周长（与真实值偏差仅0.96%）、同时他也是第一位根据经纬线绘制出世界地图的人、也是最先提出将地球根据南北回归线分为“五带”的大人物。他提出的筛法核心思想如下： 第一步：列出从2开始的一列连续数字；第二步：选出第一个质数（本例中为2），将该质数标记，将数列中它的的所有倍数划去；第三步：若数列中的末项小于它前一项的平方，则质数已全部筛出；否则返回第二步。 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; &#125; for (int j = 2; i * j &lt;= n; j ++) vis[i * j] = true; &#125;&#125; 其中，prime数组存储质数，vis数组用于标记（即上文中“划去数字”），变量cnt则存储[2,N][2,N][2,N]中质数的个数。 复杂度：O(nln⁡n)\\mathcal O(n\\ln{n})O(nlnn) 适用范围：普及T2及以下 但是继续观察算法发现：我们其实无需将所有iii的倍数删去，只需删去前一步得出的质数的所有倍数即可。 这与前文介绍的埃氏法核心相符。因此将jjj循环迁移至条件判断中即可： 12345678void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) vis[j] = true; &#125; &#125;&#125; 优化复杂度：O(nlog⁡log⁡n)\\mathcal O(n\\log{\\log n})O(nloglogn) 适用范围：普及T3及以下 线性筛/欧拉筛：实质是埃氏筛的线性优化。因为在埃氏筛中，有些数字被重复筛了多次（例如30会被2、3、5筛到）。本着线性优化的原则，我们需要找到一个方法，使得每个合数仅被筛选一次。主要思想如下： 我们发现，线性筛和埃氏筛均使用了质数的nnn倍为合数的结论。我们只需要保证每一个数仅被它自身的最小质因数筛出即可。即对于数字mmm，m⋅pim\\cdot p_im⋅pi​是一个合数，且m⋅pim\\cdot p_im⋅pi​只会被pip_ipi​筛出。 123456789void get(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) &#123; vis[prime[j] * i] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及、提高 例题： P5736 【深基7.例2】质数筛 P5723 【深基4.例13】质数口袋 Part3. 因数 因数定义： 对于一个数nnn，若存在一个正整数mmm使得m∣nm\\mid nm∣n，则称mmm是nnn的因数。 Div1. 因数分解法 试除法：万能暴力解法。即遍历[2,n][2,\\sqrt n][2,n​]间的所有数mmm，若可以整除nnn，则mmm和nm\\frac{n}{m}mn​均为nnn的因数。特殊情况：n\\sqrt nn​为整数时，因数仅有n\\sqrt nn​本身，因此需特判。 123456789101112vector&lt;int&gt; get(int n) &#123; vector&lt;int&gt; ret; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret.push_back(i); ret.push_back(n / i); &#125; if (n % (i * i) == 0) ret.pop_back(); &#125; sort(ret.begin(), ret.end()); return ret;&#125; 复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：普及T1 Div2.最大公约数 辗转相除法： 又是我们大名鼎鼎的欧几里得老先生提出的一套公约数算法，整个算极其简洁：核心只有一行，即： 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数 可以写出： 123int gcd(int a, int b) &#123; return b ? gcd(a, a % b) : a; &#125; 但是为什么gcd(a,b)=gcd(a,a mod b)gcd(a,b)=gcd(a,a\\bmod b)gcd(a,b)=gcd(a,amodb)呢？我们可以通过以下方法证明： 假设如下关系：A=B⋅C+DA=B\\cdot C + DA=B⋅C+D。其中被除数AAA，除数BBB，商CCC，余数DDD。则A mod B=A mod C=DA\\bmod B=A\\bmod C=DAmodB=AmodC=D。 首先证明充分性：令A=a⋅kA=a\\cdot kA=a⋅k、B=b⋅kB=b\\cdot kB=b⋅k，即二者有相同因子kkk。 代入初始除法算式得：D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C)D=A-B\\cdot C\\rightarrow a\\cdot k-b\\cdot k\\cdot C\\rightarrow k(a-b\\cdot C)D=A−B⋅C→a⋅k−b⋅k⋅C→k(a−b⋅C) 接着由于加减乘法的封闭性，即一个整数进行加减乘运算得到的结果同样是一个整数。可以得出：D=k⋅N∣N∈N+D=k\\cdot N\\mid N\\in \\mathbb{N_+}D=k⋅N∣N∈N+​。即DDD（A mod BA\\bmod BAmodB）与AAA有共同因子。 接下来证必要性。令B=b⋅qB=b\\cdot qB=b⋅q、D=d⋅qD=d\\cdot qD=d⋅q Stein算法： 上一个方法的明显缺点在于，它处理大质数的效率并不好（但总体来说是很好的），因为它使用了取余运算，这会减慢一些速度。可以理解，生在2000多年前——一个没有电脑和OI的古希腊社会，这个算法已经足够兼顾常规效率和手推难度了。但是步入21世纪，加快的生活节奏毒瘤数据使得人们对更快算法的需求空前高涨。Stein算法便应运而生。 算法流程如下： 任意给定两个正整数，先判断它们是否都是偶数，若是，则用2约简，若不是，则执行第二步。 若两数是一奇一偶，则偶数除以2，直至两数都成为奇数。再以较大的数减较小的数，接着取所得的差与较小的数，若两数一奇一偶，仍然偶数除以2，直至两数都成为奇数。再次以大数减小数。不断重复这个操作，直到所得的减数和差相等为止。 两数相等时，第一步中约掉的若干个2与第二步中最终的等数的乘积就是所求的最大公约数。 123456789101112131415161718192021222324int gcd(int a, int b) &#123; int p = 0, t; if (!(1 &amp; a) &amp;&amp; !(1 &amp; b)) &#123; a &gt;&gt;= 1; b &gt;&gt;= 1; p++; &#125; while (!(1 &amp; a)) a &gt;&gt;= 1; while (!(1 &amp; b)) b &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; while (a = ((a - b) &gt;&gt; 1)) &#123; while (!(1 &amp; a)) a &gt;&gt;= 1; if (a &lt; b) &#123; t = a; a = b; b = t; &#125; &#125; return b &lt;&lt; p;&#125; 这个算法的优点在于：它大大优化了大质数的运算。但可惜的是，它的代码量膨胀了8倍，因此不太建议赛时使用。毕竟C++都给你内置了__gcd()函数嘛，干嘛不偷个懒？ Div3. 最小公倍数 我们可以简单概括成一句话： 两个数的最小公倍数等于这两个数的乘积与这两个数最大公约数的商 即：lca(a,b)=a⋅bgcd(a,b)lca(a,b)=\\frac{a\\cdot b}{gcd(a,b)}lca(a,b)=gcd(a,b)a⋅b​ 凭啥呀？ 我们假设两个数AAA和BBB有最大公约数xxx，则A=a⋅xA=a\\cdot xA=a⋅x，且B=b⋅xB=b\\cdot xB=b⋅x。并且aaa和bbb一定互质（若不互质，AAA和BBB的最大公约数就不会是xxx，而是一个比xxx大的值）。 由乘法交换律，可知：A⋅B=B⋅A→A⋅b⋅x=B⋅a⋅xA\\cdot B = B\\cdot A\\rightarrow A\\cdot b \\cdot x=B\\cdot a\\cdot xA⋅B=B⋅A→A⋅b⋅x=B⋅a⋅x 消去xxx得：A⋅b=B⋅aA\\cdot b=B\\cdot aA⋅b=B⋅a。因为aaa、bbb互质，所以A⋅bA\\cdot bA⋅b或者B⋅aB\\cdot aB⋅a即为两个数的最小公倍数。得证。 例题： P1075 [NOIP2012 普及组] 质因数分解 P2424 约数和 （需要逆向思维） Part4. 欧拉函数相关 Div1. 欧拉函数推导 问：论牧师欧拉有多么的高产 答：平均每年800页数学论文你说高不高产嘛 欧拉函数，记作φ(n)\\varphi(n)φ(n)。表示[1,n)[1,n)[1,n)中与nnn互质的数的个数，即∀m∈[1,n)\\forall m\\in [1,n)∀m∈[1,n)，满足gcd(n,m)=1gcd(n,m)=1gcd(n,m)=1的mmm的总个数即为φ(n)\\varphi(n)φ(n)的值。举个例子，φ(3)=2\\varphi(3)=2φ(3)=2，因为在[1,3)[1,3)[1,3)中，111和222均与333互质。特殊地，φ(1)=1\\varphi(1)=1φ(1)=1。 欧拉函数有如下计算公式：若nnn可被表示为n=∏i=1kpiαin=\\prod\\limits_{i=1}^{k}p_i^{\\alpha_i}n=i=1∏k​piαi​​（算术基本定理分解式）的形式，则φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk)=n∗∏i=1k(1−1pi)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})=n*\\prod\\limits_{i=1}^{k}(1-\\frac{1}{p_i})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk​1​)=n∗i=1∏k​(1−pi​1​)。 推导思想即为用nnn减去所有[1,n)[1,n)[1,n)中所有与nnn不互质的数。在计算机上实现，首先需要分解质因数。思路如下：首先抛出第一个质因数p1p_1p1​，那么将[1,n][1,n][1,n]中所有的p1p_1p1​的倍数删去，因而可以保证筛出的数一定是nnn的质因子，否则他们将存在最大公约数p1p_1p1​。那么能被p1p_1p1​整除的数的个数（也就是nnn以内p1p_1p1​的倍数个数）为[np1][\\frac{n}{p_1}][p1​n​]——其中的中括号代表整除。 因此我们离解出欧拉函数就进了一步了，我们的过渡式子就是TS1(n)=n−[np1]−[np2]−⋯−[npk−1]−[npk]TS_1(n)=n-[\\frac{n}{p_1}]-[\\frac{n}{p_2}]-\\dots-[\\frac{n}{p_{k-1}}]-[\\frac{n}{p_k}]TS1​(n)=n−[p1​n​]−[p2​n​]−⋯−[pk−1​n​]−[pk​n​]。 好耶 别急着好耶，我们可以发现一个小小的推导谬误（可能并不是很容易发现）。当我们用p2p_2p2​去筛数时，使用的算式仍然是[np2][\\frac{n}{p_2}][p2​n​]。对于形如p1np2mp_1^np_2^mp1n​p2m​的数，会被重复筛去多次，导致多减，最终结果会小于φ(n)\\varphi(n)φ(n)。有些抽象，我们来看这张图： 易知[1,30][1,30][1,30]中可被222整除的数字共有30÷2=1530\\div 2=1530÷2=15个，能被555整除的数字共有30÷5=630\\div 5=630÷5=6个。但是如果说能被222和555整除的数字共有15+6=2115+6=2115+6=21个，显然不合常理，因为101010、202020、303030都既能被222整除，也能被555整除，如果不加排除，他们将会被减去2次。因此需要补偿损失，正确的计算方法是（仅计算能被222和555整除的数的总个数）： 能被222整除的：30÷2=1530\\div 2=1530÷2=15个 能被555整除的：30÷5=630\\div 5=630÷5=6个 同时被222和555整除的：30÷lca(2,5)=30÷10=330\\div lca(2,5)=30 \\div 10=330÷lca(2,5)=30÷10=3个 总个数：15+6−(2−1)×3=1815+6-(2-1)\\times 3=1815+6−(2−1)×3=18个（就是被绿圈和橙圈捆住的的数的个数） 那么对于222、333、555整除问题，中间的303030被重复加了3次，需减去两次平衡收支。此即容斥原理的简单思想表示。 回到欧拉函数推导上来：过渡公式TS1TS_1TS1​中的容斥问题可以解决一部分了。对于可同时被两个不同质数整除的数（例如6=2×36=2\\times36=2×3、15=3×515=3\\times515=3×5），我们加上它的总个数。 得到TS2=TS1+[np1p2]+[np1p3]+⋯+[np1pk]+[np2p3]+[np2p4]+⋯+[npk−1pk]TS_2=TS_1+[\\frac{n}{p_1p_2}]+[\\frac{n}{p_1p_3}]+\\dots+[\\frac{n}{p_1p_k}]+[\\frac{n}{p_2p_3}]+[\\frac{n}{p_2p_4}]+\\dots+[\\frac{n}{p_{k-1}p_k}]TS2​=TS1​+[p1​p2​n​]+[p1​p3​n​]+⋯+[p1​pk​n​]+[p2​p3​n​]+[p2​p4​n​]+⋯+[pk−1​pk​n​]。 当然这又有一个小问题没完没了了是不是？：对于p1 p2 p3p_1\\;p_2\\;p_3p1​p2​p3​的公倍数，会被先减去3次，然后被上一步的操作加上3次，总体不加不减。还是回到上图：中间的303030会被每个颜色的圈先减去一次、共3次，上一步的补偿操作，可以看作又被橙绿圈（橙圈和绿圈的交集）、蓝绿圈、蓝橙圈一共加上了3次。减3次加3次相当于没动，为了让它被算上，我们需要加上它，对于φ(n)\\varphi(n)φ(n)则是全部减去（因为括号外有减号需要变号，不要忘记φ(n)\\varphi(n)φ(n)是由一系列不合规的数字个数相减得来的）。得到我们的过渡态3：TS3=TS2−[np1p2p3]−[np1p2p4]−[np1p2p5]−⋯−[npk−2pk−1pk]TS_3=TS_2-[\\frac{n}{p_1p_2p_3}]-[\\frac{n}{p_1p_2p_4}]-[\\frac{n}{p_1p_2p_5}]-\\dots-[\\frac{n}{p_{k-2}p_{k-1}p_{k}}]TS3​=TS2​−[p1​p2​p3​n​]−[p1​p2​p4​n​]−[p1​p2​p5​n​]−⋯−[pk−2​pk−1​pk​n​] 又是如上的容斥判断，这里我们省去讨论。将最终的产物合并得到：φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)！（我不会合并，但是你可以把φ(n)\\varphi(n)φ(n)括号拆开看看是不是上述形式。总之，欧拉牛逼！） QEDQEDQED，好耶！终于可以好耶了…… Div2. 欧拉函数代码实现 主要是如果压成一个Div会非常的长，因此这里新开一个Div2 我们明确了欧拉函数的推导，接下来就是整理思路写代码的时间了！我们也只需跟着原始思路走就可以了。再次回忆一下：首先我们需要筛出质因数，除去它的所有倍数，再用公式φ(n)=n∗(1−1p1)(1−1p2)…(1−1pk−1)(1−1pk)\\varphi(n)=n*(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_{k-1}})(1-\\frac{1}{p_k})φ(n)=n∗(1−p1​1​)(1−p2​1​)…(1−pk−1​1​)(1−pk​1​)代入pip_ipi​就可以了。 1234567891011long long eular(int n) &#123; long long res = n; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; res = res * (i - 1) / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125; 时间复杂度：O(n)\\mathcal O(\\sqrt n)O(n​) 适用范围：All Clear Div3. 欧拉函数推论 若ppp为质数，则φ(p)=p−1\\varphi(p)=p-1φ(p)=p−1 让我们回到欧拉函数的定义上去：φ(i)\\varphi(i)φ(i)是[1,i][1,i][1,i]中与iii互质的数的个数（特殊地，φ(1)=1\\varphi(1)=1φ(1)=1）。那么对于ppp这个质数，有多少数与它互质呢？ 很显然，答案是p−1p-1p−1个！因为ppp的质因子只有ppp本身，若不止ppp一个质因子，很显然它不是一个质数。因此φ(p)=p(1−1p)=p−1\\varphi(p)=p(1-\\frac{1}{p})=p-1φ(p)=p(1−p1​)=p−1。 假设pkp_kpk​是一个质数，pk∣ip_k\\mid ipk​∣i（或i mod pk=0i\\bmod p_k=0imodpk​=0），且φ(i)\\varphi(i)φ(i)的值已知，那么φ(pk∗i)=pk⋅φ(i)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)φ(pk​∗i)=pk​⋅φ(i) 凭啥呀？ 因为pkp_kpk​已经是一个质数，换句话说：在这个条件下pkp_kpk​是pk∗ip_k*ipk​∗i的一个质因子。在计算φ(i)\\varphi(i)φ(i)时，pkp_kpk​就已经作为一个质因子以(1−1pk)(1-\\frac{1}{p_k})(1−pk​1​)的形式乘进去了。此时φ(i)\\varphi(i)φ(i)可以写作 φ(i)=i(1−1p1)(1−1p2)…(1−1pk)…(1−1pn)……(1)\\varphi(i)=i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})\\dots (1-\\frac{1}{p_n})\\dots \\dots(1)φ(i)=i(1−p1​1​)(1−p2​1​)…(1−pk​1​)…(1−pn​1​)……(1) 那么函数值多乘了一个pkp_kpk​ φ(pk∗i)=pk⋅i(1−1p1)(1−1p2)…(1−1pk)…(1−1pn)……(2)\\varphi(p_k*i)=p_k\\cdot i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\dots(1-\\frac{1}{p_k})\\dots (1-\\frac{1}{p_n})\\dots\\dots(2)φ(pk​∗i)=pk​⋅i(1−p1​1​)(1−p2​1​)…(1−pk​1​)…(1−pn​1​)……(2) 我们发现：(2)式中包含了(1)式，只是头上乘以了pkp_kpk​。因而得到φ(pk∗i)=φ(i)⋅pk\\varphi(p_k*i)=\\varphi(i)\\cdot p_kφ(pk​∗i)=φ(i)⋅pk​ 假设pkp_kpk​是一个质数，pk∤ip_k\\nmid ipk​∤i（或i mod pk≠0i\\bmod p_k\\neq0imodpk​​=0），且φ(i)\\varphi(i)φ(i)的值已知，那么φ(pk∗i)=pk⋅φ(i)⋅(1−1pk)=φ(i)⋅(pk−1)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)\\cdot(1-\\frac{1}{p_k})= \\varphi(i)\\cdot(p_k-1)φ(pk​∗i)=pk​⋅φ(i)⋅(1−pk​1​)=φ(i)⋅(pk​−1) 这东西长得和性质2很相似，唯一不同的是pkp_kpk​不再是iii的一个质因子了。但是pkp_kpk​变成了pk∗ip_k*ipk​∗i的质因子。因此我们计算φ(pk∗i)\\varphi(p_k*i)φ(pk​∗i)的值时，不仅需要在头部乘上pkp_kpk​，而且还需要将(1−1pk)(1-\\frac{1}{p_k})(1−pk​1​)乘进去： φ(pk∗i)=pk⋅i⋅(1−1p1)…(1−1pn)(1−1pk)\\varphi(p_k*i)=p_k\\cdot i\\cdot (1-\\frac{1}{p_1})\\dots(1-\\frac{1}{p_n})(1-\\frac{1}{p_k})φ(pk​∗i)=pk​⋅i⋅(1−p1​1​)…(1−pn​1​)(1−pk​1​) 因为pk⋅(1−1pk)=pk−1p_k\\cdot (1-\\frac{1}{p_k})=p_k-1pk​⋅(1−pk​1​)=pk​−1，所以得到性质3，即φ(pk∗i)=pk⋅φ(i)⋅(1−1pk)=φ(i)⋅(pk−1)\\varphi(p_k*i)=p_k\\cdot\\varphi(i)\\cdot(1-\\frac{1}{p_k})= \\varphi(i)\\cdot(p_k-1)φ(pk​∗i)=pk​⋅φ(i)⋅(1−pk​1​)=φ(i)⋅(pk​−1)。 这三个性质将作为重点性质出现在欧拉函数筛法中。 Div4. 欧拉函数线性筛 我们已经接触了简单的欧拉函数计算方法，那么又该如何解决形如：“给定一个正整数i∈[x,y]i\\in [x,y]i∈[x,y]，求∑i=xyφ(i)\\sum\\limits_{i=x}^{y}\\varphi(i)i=x∑y​φ(i)的值”的问题呢？ 考虑继续使用上面的朴素算法，时间复杂度将会是nnn\\sqrt nnn​。明显无法满足需求，更何况，每个数与每个数之间的φ\\varphiφ值之间有一种推导关系，使得我们无需每次重新计算φ\\varphiφ值，而是用已经求出的φ(n)\\varphi(n)φ(n)来线性推出φ(i)\\varphi(i)φ(i)的值。 欧拉函数涉及到质因子的拆分，我们又需要在线性时间内求各种质数。自然而然想到了先前所学的线性筛： 12345678910111213int primes[N];bool st[N];int cnt = 0;void sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[++cnt] = i; for (int j = 1; primes[j] * i &lt;= n; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125; 我们运用这段代码可以得出[1,n][1,n][1,n]范围内所有的质数，用st[N]数组可以筛出所有的合数。也就是说对于筛出的合数，我们能够得知组成它的质因子是什么，比如st[primes[j]*i]=true;这一行代码。接着套用上述三种性质，我们可以得出φ\\varphiφ值。 此时我们就需要新建一个phi[N]数组来存储每个数的φ\\varphiφ值，并且在代码中三个地方加入对于三种性质的公式： 1234567891011121314151617181920212223typedef long long ll;ll primes[N];bool st[N];int cnt = 0;ll phi[N];void phi_sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; primes[j] * i &lt;= n; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) &#123; phi[primes[j] * i] = phi[i] * primes[j]; break; &#125; phi[primes[j] * i] = phi[i] * (primes[j] - 1); &#125; &#125;&#125; 没错我开了long long防止爆int 时间复杂度：O(n)\\mathcal O(n)O(n) 适用范围：普及&amp;提高 对于开头提出的求和问题，遍历phi[1]到phi[n]的所有值求和即可。 Div5. 欧拉定理 若正整数aaa与nnn互质，则有aφ(n)≡1(modn)a^{\\varphi(n)}\\equiv1\\pmod naφ(n)≡1(modn) 对于它的证明，百度百科中如此写到： 取mmm的缩系a1,a2,…,aφ(m)a_1,a_2,\\dots,a_{\\varphi(m)}a1​,a2​,…,aφ(m)​，故aa1,aa2,…,aaφ(m)aa_1,aa_2,\\dots,aa_{\\varphi(m)}aa1​,aa2​,…,aaφ(m)​也为mmm的缩系。有∏i=1φ(m)ai≡∏i=1φ(m)aai≡aφ(m)∏i=1φ(m)ai(modm)\\prod\\limits_{i=1}^{\\varphi(m)}a_i\\equiv\\prod\\limits_{i=1}^{\\varphi(m)}aa_i\\equiv a_{\\varphi(m)}\\prod\\limits_{i=1}^{\\varphi(m)}a_i\\pmod mi=1∏φ(m)​ai​≡i=1∏φ(m)​aai​≡aφ(m)​i=1∏φ(m)​ai​(modm) 通俗来讲就是这样： 在[1,n][1,n][1,n]中取所有与nnn互质的数a1,a2…,aφ(n)a_1,a_2\\dots,a_{\\varphi(n)}a1​,a2​…,aφ(n)​，很容易知道这样的aaa共有φ(n)\\varphi(n)φ(n)个（根据欧拉函数定义得来）。它们都与nnn互质。 给这列数同时乘上aaa，得到aa1,aa2,…,aaφ(n)aa_1,aa_2,\\dots,aa_{\\varphi(n)}aa1​,aa2​,…,aaφ(n)​。它们也都和nnn互质，并且各不相同。 提出括号里乘了φ(n)\\varphi(n)φ(n)次的aaa，得到以下关系式：aφ(n)[a1a2…aφ(n)]≡a1a2…aφ(n)(modn)a^{\\varphi(n)}[a_1a_2\\dots a_{\\varphi(n)}]\\equiv a_1a_2\\dots a_{\\varphi(n)}\\pmod naφ(n)[a1​a2​…aφ(n)​]≡a1​a2​…aφ(n)​(modn) 那么根据同余号两端的消去原则（左右两端两个项相同且与模nnn互质），可以消去a1a2…aφ(n)a_1a_2\\dots a_{\\varphi(n)}a1​a2​…aφ(n)​。得到aφ(n)≡1(modn)a^{\\varphi(n)}\\equiv1\\pmod naφ(n)≡1(modn)，欧拉定理得证。 特殊地，如果ppp是一个质数，有aφ(p)≡1(modp)⇒ap−1≡1(modp)a^{\\varphi(p)}\\equiv1\\pmod p\\Rightarrow a^{p-1}\\equiv1\\pmod paφ(p)≡1(modp)⇒ap−1≡1(modp)。这被称作费马小定理（先前的费马素性检验就是基于这个原理编写的）。 真不知道明明可以写得通俗点为什么非得省那点空间写看起来那么高深莫测的专业术语，真的是只写给自己看的。 Div6. 降幂算法 尤其对于绿题以上的题目，题面中可能出现“答案可能很大，请对大质数ppp取余”的字样。这意味着题目可能涉及到大规模的幂运算，需要我们用简便的方法计算幂。对于一般的题目，我们使用快速幂。 快速幂：快速幂思想如下： ab={ab2×ab2,b mod 2=0a×ab−12×ab−12,b mod 2=1a^b= \\begin{cases}a^{ \\frac{b}{2}}\\times a^{ \\frac{b}{2}},&amp; b\\bmod 2=0\\\\a\\times a^{ \\frac{b-1}{2}}\\times a^{ \\frac{b-1}{2}},&amp;b\\bmod2=1 \\end{cases}ab={a2b​×a2b​,a×a2b−1​×a2b−1​,​bmod2=0bmod2=1​ 我们将指数bbb分解为若干2n2^n2n的和（二进制表示），例如：a11=a20⋅a21⋅a23a^{11}=a^{2^0}\\cdot a^{2^1}\\cdot a^{2^3}a11=a20⋅a21⋅a23，因为(11)10=(1011)2(11)_{10}=(1011)_2(11)10​=(1011)2​。因而不必将aaa连续乘11次，效率大幅提升。 1234567891011typedef long long ll;int qpow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; &#125; return res;&#125; 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 适用范围：基本All Clear 欧拉降幂：上面方法一个缺点在于无法处理过大的指数，在处理类似于a2na^{2^n}a2n的计算时将会疯狂掉san。接下来介绍一种使用上面讲到的欧拉定理来解决大指数幂运算的方法。 欧拉降幂核心公式：ak mod p=ak mod φ(p)+φ(p) mod pa^k\\bmod p=a^{k\\bmod\\varphi(p)+\\varphi(p)}\\bmod pakmodp=akmodφ(p)+φ(p)modp（又称 扩展欧拉定理 ） 也就是说：我们只需要算出q=k mod φ(p)+φ(p)q=k\\bmod\\varphi(p)+\\varphi(p)q=kmodφ(p)+φ(p)的值，再用快速幂算法，将qqq作为新指数带入计算即可。当然，这里的kkk可能会爆long long，因此可以选择使用字符串进行高精度计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef long long ll;ll primes[N];bool st[N];int cnt = 0;int qpow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; &#125; return res;&#125;ll eular(int n) &#123; ll res = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[++cnt] = i; res = res * (i - 1) / i; while (n % i == 0) n /= i; &#125; for (int j = 1; i * primes[j] &lt;= n; j++) &#123; st[i * primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125; if (n &gt; 1) res = res * (n - 1) / n; return res;&#125;int edp(int a, string k, int p) &#123; ll phi = eular(p); int drop = 0; for (int i = 0; i &lt; k.length(); i++) &#123; drop *= 10; drop += k[i] % phi; &#125; drop += phi; return qpow(a, drop, p);&#125; 其中eular(int n)函数用于计算欧拉函数的值、edp(int a, string k, int p)用于计算降幂后的指数、qpow(int a, int k, int p)是快速幂算法。 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 适用范围：所有 扩展欧拉定理可谓是欧拉定理的一般形式，它的定义如下：对于任意正整数aaa、kkk、ppp，满足： $ak\\equiv\\begin{cases}ak&amp;(\\bmod;p ),gcd(a,p)\\neq1,k&lt;\\varphi§\\a{k\\bmod\\varphi§+\\varphi§}&amp;(\\bmod;p),gcd(a,p)\\neq1,k\\geq\\varphi§\\a{k\\bmod\\varphi§}&amp;(\\bmod;p),gcd(a,p)=1\\end{cases} $ 其中第二个式子就是欧拉降幂的核心公式。 扩展欧拉定理的证明见这里。因为太复杂了我不会证 例题： P2158 [SDOI2008] 仪仗队 （欧拉函数板子） P1447 [NOI2010] 能量采集（上一个问题的变式） P1226 [模板] 快速幂 P5091 [模板] 扩展欧拉定理 （欧拉降幂） P4139 上帝与集合的正确用法 （欧拉降幂+递归） Part5. 同余方程的解法 这里会涉及到一元线性同余方程，一元线性同余方程组和高次同余方程的算法解法。 Div.1 裴蜀定理 很多人会把他读成裴除（chú）（比如我的某位好友），这个名词正确的读法是裴蜀（shǔ）。或者可以直接改称作“贝祖定理”，它的提出者艾蒂安·裴蜀估计怎么也没想到后人居然连他的名字都读不对（想想如果这种事情发生到你身上会怎么样）。你也可以读他名字的法语发音BeˊzoutB\\acute ezoutBeˊzout（显得你很优雅且有文化）。 切入正题，裴蜀定理表述为：对于任意正整数aaa，bbb，总有整数xxx、yyy，使得ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)，其中(a,b)(a,b)(a,b)等价于gcd(a,b)gcd(a,b)gcd(a,b)，是数论中最大公约数的表述方式。 首先可以知道at+bn=d (n,t∈Z n,t≠0)at+bn=d\\;\\;\\;(n,t\\in\\mathbb Z\\;\\;\\;n,t\\neq0)at+bn=d(n,t∈Zn,t​=0)且(a,b)∣d(a,b)\\mid d(a,b)∣d，因为aaa和bbb都具有约数(a,b)(a,b)(a,b)，让他们分别乘上另两个数ttt和nnn并不会改变(a,b)(a,b)(a,b)这一约数。所以假设d=k⋅(a,b),k∈Zd=k\\cdot(a,b),k\\in\\mathbb Zd=k⋅(a,b),k∈Z，有atk+bnk=(a,b)a\\frac{t}{k}+b\\frac{n}{k}=(a,b)akt​+bkn​=(a,b)。在这里，x=tk y=nkx=\\frac{t}{k}\\;\\;y=\\frac{n}{k}x=kt​y=kn​。 Div2. 扩展欧几里得（EXGCD） 加了“扩展”二字是不是感觉逼格上来了？ 扩展欧几里得算法用于求出线性同余方程的解。线性同余方程，即形如ax≡b(modp)ax\\equiv b\\pmod pax≡b(modp)的方程，我们需要求出xxx的值。 回忆一下欧几里得算法的核心思路：(a,b)={(a,a mod b)a mod b≠0aa mod b=0(a,b)=\\begin{cases}(a,a\\bmod b)&amp;a\\bmod b\\neq0\\\\a&amp;a\\bmod b=0\\end{cases}(a,b)={(a,amodb)a​amodb​=0amodb=0​。 再看看刚刚讲到的裴蜀定理，发现(a mod b)x+by=k⋅(a,a mod b)=k⋅(a,b)=d(a\\bmod b)x+by=k\\cdot(a,a\\bmod b)=k\\cdot(a,b)=d(amodb)x+by=k⋅(a,amodb)=k⋅(a,b)=d。根据余数的定义，有：(a−⌊ab⌋⋅b)x+by=d(a-\\lfloor\\frac{a}{b}\\rfloor\\cdot b)x+by=d(a−⌊ba​⌋⋅b)x+by=d。 那么我们的任务就是求出这里的xxx和yyy值，因此拆开括号，整理出aaa和bbb的系数：ax+b(y−⌊ab⌋x)=dax+b(y-\\lfloor\\frac{a}{b}\\rfloor x)=dax+b(y−⌊ba​⌋x)=d。观察裴蜀定理的形式：ax+by=(a,b)ax+by=(a,b)ax+by=(a,b)，我们得出的式子中，yyy变成了y−⌊ab⌋xy-\\lfloor\\frac{a}{b}\\rfloor xy−⌊ba​⌋x。因此每次递归时需要将yyy的值减去⌊ab⌋x\\lfloor\\frac{a}{b}\\rfloor x⌊ba​⌋x。 既然我们设计的是一个递归算法，我们就必须明确它的递归出口。根据欧几里得算法，当a mod b=0a\\bmod b=0amodb=0时，(a,b)=a(a,b)=a(a,b)=a。我们把aaa和a mod ba\\bmod bamodb代入发现：ax+(a mod b)y=(a,b)=aax+(a\\bmod b)y=(a,b)=aax+(amodb)y=(a,b)=a，得到ax+0y=aax+0y=aax+0y=a，此时yyy可取任意整数值，x=1x=1x=1。这里我所取的解是{x=1y=0\\begin{cases}x=1\\\\y=0\\end{cases}{x=1y=0​。 最后，因为这本质上还是一个欧几里得算法，所以返回(a,b)(a,b)(a,b)是有必要的（事实上exgcd算法返回的(a,b)(a,b)(a,b)将作为推导式中的ddd参与运算）。我们可以写出如下函数。 12345678910int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125; 时间复杂度：O(log⁡n)\\mathcal O(\\log n)O(logn) 但是，题目中一般不会给出裴蜀定理那样的形式，而是形如ax≡b(modm)ax\\equiv b\\pmod max≡b(modm)的形式，让你求出xxx的值，并且上述方法仅求出了一元线性同余方程的一组特解，如果题目中让你求出最小正整数解呢？接下来就是解决上述问题的方法： 1. 同余—等式互转（自己起的名字）： 在上面的介绍中，我们遇到了一个问题：如何将ax≡b(modm)ax\\equiv b\\pmod max≡b(modm)这样的同余式变为ax+by=cax+by=cax+by=c这样的二元一次不定方程的裴蜀定理形式呢？ 考虑到同余方程的定义（或者你可以把以下关系死记住），得到ax mod m=bax\\bmod m=baxmodm=b。接着由余数定义，得到ax=by+m,y∈Zax=by+m,y\\in\\mathbb Zax=by+m,y∈Z，移项得到：ax−by=max-by=max−by=m。提出负号，令b′=−bb^\\prime=-bb′=−b，则ax+b′y=max+b^\\prime y=max+b′y=m。它有解的充要条件是m∣(a,b)m\\mid(a, b)m∣(a,b)。经过如上变换后就变成了裴蜀定理的形式，可以直接用exgcd求解xxx和yyy。 2. 最值解问题： 二元一次不定方程通解的证明 Div3. 中国剩余定理（CRT） 又称孙子定理（但我认为还是中国剩余定理听起来更有实力一些），最早见于《孙子算经》中“物不知数”问题，首次提出了有关一元线性同余方程的问题与解法。 对于一元线性同余方程：S→{x≡a1(modp1)x≡a2(modp2)⋮x≡ak(modpk)S\\rightarrow\\begin{cases}x\\equiv a_1\\pmod{p_1}\\\\x\\equiv a_2\\pmod{p_2}\\\\\\vdots\\\\x\\equiv a_k\\pmod{p_k}\\end{cases}S→⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​(modp1​)x≡a2​(modp2​)⋮x≡ak​(modpk​)​，可以构造以下方法求出通解。 首先，令M=p1⋅p2⋅p3…pk=∏i=1kpiM=p_1\\cdot p_2\\cdot p_3\\dots p_k=\\prod\\limits_{i=1}^{k}p_iM=p1​⋅p2​⋅p3​…pk​=i=1∏k​pi​。 然后，令Mi=Mpi (1≤i≤k)M_i=\\frac{M}{p_i}\\;(1\\leq i\\leq k)Mi​=pi​M​(1≤i≤k)，即除了pip_ipi​外所有ppp的乘积。 接着，令tit_iti​为MiM_iMi​在模pip_ipi​意义下的逆元，即ti⋅Mi≡1(modpi)t_i\\cdot M_i\\equiv1\\pmod{p_i}ti​⋅Mi​≡1(modpi​)。 所以，SSS的通解为：x=a1t1M1+a2t2M2+⋯+aktkMk+kM=kM+∑i=1kaipiMix=a_1t_1M_1+a_2t_2M_2+\\dots+a_kt_kM_k+kM=kM+\\sum\\limits_{i=1}^{k}a_ip_iM_ix=a1​t1​M1​+a2​t2​M2​+⋯+ak​tk​Mk​+kM=kM+i=1∑k​ai​pi​Mi​。 Div4. Baby Step Giant Step算法（BSGS） 这个算法用于解决一元高次同余方程问题，模意义下的对数也可以求。又称“北上广深算法”（想出这种名字的人真是人才）。 高次同余方程长成这个样子： ax≡b(modm)a^x\\equiv b\\pmod max≡b(modm) 发现xxx跑到了指数上边真是变态呢。这种问题显然没公式解，于是苦恼的人们只得选择一条略显暴力的求解道路，即搜索。严格来说，BSGS所使用的是双搜索，其中的一个变量的搜索步长会长于另一个变量的搜索步长，因而得名“大步小步算法”。或者叫北上广深/拔山盖世算法！ 朴素BSGS（aaa与mmm互质）：不妨令x=At−Bx=At-Bx=At−B，原式为aAt−B≡b(modm)a^{At-B}\\equiv b\\pmod maAt−B≡b(modm)。根据消去原则，两边同乘aBa^BaB得aAt≡baB(modm)a^{At}\\equiv ba^B\\pmod maAt≡baB(modm)。 接下来我们对同余号右侧的部分求值，再任命一个固定的ttt值，使得左侧模mmm的值等于右侧模mmm的值。为了快速比对左右侧的值，我们选择将右侧预先计算出来的值存入一个哈希表中，让baB mod m→Bba^B\\bmod m\\rightarrow BbaBmodm→B（键为baBba^BbaB，对应值为BBB）。接着就是选择ttt值，计算aAt mod ma^{At}\\bmod maAtmodm并比对了。 关于哈希表冲突，我们希望找到x,x=At−Bx,x=At-Bx,x=At−B的最小值，因而BBB需要尽可能大。每次冲突即代表一个更大的BBB值被发现了。因此无需处理冲突问题。 对于ttt的选择。可以发现BBB有φ(m) mod t\\varphi(m)\\bmod tφ(m)modt个可能的取值，AAA有⌊φ(m)/t⌋\\lfloor\\varphi(m)/t\\rfloor⌊φ(m)/t⌋个。ttt取⌈φ(m)⌉\\lceil\\sqrt{\\varphi(m)}\\rceil⌈φ(m)​⌉时最佳。因此代码就可以写出来了。 123456789101112131415161718ll bsgs(ll a, ll b, ll m) &#123; unordered_map&lt;ll, ll&gt; hash; ll bs = 1; int t = sqrt(m) + 1; for (int B = 1; B &lt;= t; B++) &#123; bs *= a; bs %= m; hash[b * bs % m] = B; &#125; ll gs = bs; for (int A = 1; A &lt;= t; A++) &#123; auto iter = hash.find(gs); if (iter != hash.end()) return A * t - it-&gt;second; gs *= bs; gs %= m; &#125; return -1;&#125; 时间复杂度：O(m)\\mathcal O(\\sqrt m)O(m​) 扩展BSGS（aaa和mmm不互质）： 例题： P1082 [NOIP2012 提高组] 同余方程 (exgcd) P5656 [模板] 二元一次不定方程 (exgcd) P1495 [模板] 中国剩余定理（CRT）/ 曹冲养猪 P1516 青蛙的约会 （CRT+exgcd） P3846 [TJOI2007] 可爱的质数/ [模板] BSGS P2485 [SDOI2011] 计算器 （欧拉降幂+乘法逆元+BSGS） P3306 [SDOI2013] 随机数生成器 （等比数列推导+BSGS） P4195 [模板] 扩展 BSGS/exBSGS Part6. 乘法逆元 乘法逆元定义如下（注意和矩阵求逆不是一个东西）： 若a⋅x≡1( mod b)a\\cdot x\\equiv1(\\bmod\\;b)a⋅x≡1(modb)，且aaa与bbb互质，则xxx是aaa在模bbb条件下的乘法逆元，记作a−1a^{-1}a−1 简单来说乘法逆元xxx就是模bbb意义下的aaa的倒数。 费马小定理求逆元：大部分题目会给出一个质数模数，因而互质是可以保证的。此时我们的乘法逆元就是使式子a⋅x≡1( mod p)a\\cdot x\\equiv1(\\bmod\\;p)a⋅x≡1(modp)成立的xxx值，考虑到模数ppp为质数，可以带回开头所说的费马小定理中。 得到ap−1≡1( mod p)a^{p-1}\\equiv1(\\bmod\\;p)ap−1≡1(modp)，由于aaa与ppp互质，消去得：a⋅ap−2≡1( mod p)a\\cdot a^{p-2}\\equiv1(\\bmod\\;p)a⋅ap−2≡1(modp)，所以乘法逆元为ap−2 mod pa^{p-2}\\bmod\\;pap−2modp。 123int inv(int a, int p) &#123; return qpow(a, p - 2, p);&#125; 扩展欧几里得求逆元：这是万能的方法，对任意模数均成立。它不像上面费马小定理那样限制模数必须是质数，因而只要时间充裕，都建议使用这种求逆元的方式。 因为ax≡1(modb)ax\\equiv 1\\pmod bax≡1(modb)，运用同余-等式互转可以得到ax−1=by→ax+by′=1(modb),y′=−yax-1=by\\rightarrow ax+by^\\prime=1\\pmod b,y^\\prime=-yax−1=by→ax+by′=1(modb),y′=−y。符合exgcd的形式。 12345678910111213141516int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int a, int m) &#123; int x, y; exgcd(a, m, x, y); return (x + m) % m;&#125; 递推求逆元： 例题： P3811 [模板] 模意义下的乘法逆元 （递推求逆元） 来张弔图 Part7. 矩阵相关 矩阵，是一个按照长方排列的实数或复数集合。它最早用来表示方程组中的系数和常数，简单理解就是它将nnn元一次方程组中的系数，按照未知数的顺序依次挑出它们的系数组合为矩阵的某一行。nnn元一次方程的矩阵有nnn列，而行数则取决于方程组中方程的个数。 Div1. 初等行变换 考虑这个方程组： {2x+3y=−1…1x−2z=6…2x+2y−4z=−2…3\\begin{cases}2x+3y=-1&amp;\\dots1\\\\x-2z=6&amp;\\dots2\\\\x+2y-4z=-2&amp;\\dots3\\end{cases}⎩⎪⎨⎪⎧​2x+3y=−1x−2z=6x+2y−4z=−2​…1…2…3​ 按照如上所述，将它转换为系数矩阵（只有x,y,zx,y,zx,y,z的系数）就是： (2301−2012−4)\\begin{pmatrix}2&amp;3&amp;0\\\\1&amp;-2&amp;0\\\\1&amp;2&amp;-4\\end{pmatrix}⎝⎛​211​3−22​00−4​⎠⎞​ 你也可以写成增广矩阵（与系数矩阵相比多了一列常数，即等号右边的常数，这里用竖线隔开）的形式： (230−11−20612−4−2)\\left(\\begin{array}{ccc|c}2&amp;3&amp;0&amp;-1\\\\1&amp;-2&amp;0&amp;6\\\\1&amp;2&amp;-4&amp;-2\\end{array}\\right)⎝⎛​211​3−22​00−4​−16−2​⎠⎞​ 不难看出第一列代表了xxx的系数，第二列和第三列是yyy和zzz的系数。那么如果需要求解这个矩阵（得到方程组的解），我们应该通过初等行变换将它变成方便我们求解的模式。初等行变换内容如下（最好用方程组消元的思想简化理解）： 交换某两行 把矩阵的某一行同乘以一个非零的数 把某行的若干倍加和到另一行 假设我们有一个nnn元线性方程组，如何设计算法使计算机能够快速求出它的解呢。我们需要引入三角矩阵的概念： 顾名思义，系数排列看起来像一个三角形的矩阵，叫做三角矩阵。分为上三角矩阵和下三角矩阵。前者的非零系数均分布在对角线的右上方、后者都在左下方，例如矩阵：U→(522170−249−10076400028)U\\rightarrow\\begin{pmatrix}5&amp;2&amp;2&amp;1&amp;7\\\\0&amp;-2&amp;4&amp;9&amp;-1\\\\0&amp;0&amp;7&amp;6&amp;4\\\\0&amp;0&amp;0&amp;2&amp;8\\end{pmatrix}U→⎝⎜⎜⎛​5000​2−200​2470​1962​7−148​⎠⎟⎟⎞​就是一个上三角矩阵（这里是增广矩阵）。通常用字母UUU表示，求解线性方程组时经常化为这种形式方便求解：本例中当最后一个未知数（见最后一行）已知时，可以通过向上代入求解每一行中待求的未知数值。 那么如何将一个一般矩阵转换为上三角矩阵呢？答案是前面介绍过的初等行变换！步骤如下： 枚举每一列ccc，选出无序组中第ccc列系数绝对值最大的一行ppp，并移到无序组的最上边。 ppp行通过自乘，将第ccc列的系数变成111，并标记ppp为有序。 通过加减有序组中某一行的非零倍，将之后所有行的第ccc列系数化为000。 文字还是太抽象，我们来举个例子： 令矩阵A→(2−11141−151110)A\\rightarrow\\left(\\begin{array}{ccc|c}2&amp;-1&amp;1&amp;1\\\\4&amp;1&amp;-1&amp;5\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)A→⎝⎛​241​−111​1−11​150​⎠⎞​（有序组用绿色表示） 枚举第一列，c=1c=1c=1。开始时，所有行均无序。选出绝对值最大的那一项，本例中为第二行，进行移动，原矩阵变为： (41−152−1111110)\\left(\\begin{array}{ccc|c}4&amp;1&amp;-1&amp;5\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​421​1−11​−111​510​⎠⎞​ 第二步，自乘并标记有序，因此第一行除以444，原矩阵就变成了： (10.25−0.251.252−1111110)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\2&amp;-1&amp;1&amp;1\\\\1&amp;1&amp;1&amp;0\\end{array}\\right)⎝⎛​121​0.25−11​−0.2511​1.2510​⎠⎞​ 第三步，将无序组的第ccc列消成000。本例中，我们让第二行减去二倍第一行；第三行直接减去第一行，得到： (10.25−0.251.250−1.51.5−1.500.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\0&amp;-1.5&amp;1.5&amp;-1.5\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.25−1.50.75​−0.251.51.25​1.25−1.5−1.25​⎠⎞​ 枚举第二列，此时c=2c=2c=2。第一步，选出第二列系数绝对值最大的那一行，移到无序组最上端。本例中无需移动，自乘−23-\\frac{2}{3}−32​，标记有序，原矩阵为： (10.25−0.251.2501−1100.751.25−1.25)\\left(\\begin{array}{ccc|c}\\textcolor{green}{1}&amp;\\textcolor{green}{0.25}&amp;\\textcolor{green}{-0.25}&amp;\\textcolor{green}{1.25}\\\\\\textcolor{green}{0}&amp;\\textcolor{green}{1}&amp;\\textcolor{green}{-1}&amp;\\textcolor{green}{1}\\\\0&amp;0.75&amp;1.25&amp;-1.25\\end{array}\\right)⎝⎛​100​0.2510.75​−0.25−11.25​1.251−1.25​⎠⎞​ 最终的最终，第三行减0.750.750.75倍第二行，得到我们心心念念的上三角矩阵： U→(10.25−0.251.2501−11002−2)U\\rightarrow\\left(\\begin{array}{ccc|c}1&amp;0.25&amp;-0.25&amp;1.25\\\\0&amp;1&amp;-1&amp;1\\\\0&amp;0&amp;2&amp;-2\\end{array}\\right)U→⎝⎛​100​0.2510​−0.25−12​1.251−2​⎠⎞​ 我们假设从左到右，分别为xxx、yyy、zzz的系数，竖线右侧为常数。矩阵可以改写成方程组的形式： {x+0.25y−0.25z=1.25y−z=12z=−2\\begin{cases}x+0.25y-0.25z=1.25\\\\y-z=1\\\\2z=-2\\end{cases}⎩⎪⎨⎪⎧​x+0.25y−0.25z=1.25y−z=12z=−2​ 根据最后一行，显然z=−1z=-1z=−1。将zzz代入2式，解得y=0y=0y=0，以此类推，由下向上代入解出的值即可，本例的唯一解是：{x=1y=0z=−1\\begin{cases}x=1\\\\y=0\\\\z=-1\\end{cases}⎩⎪⎨⎪⎧​x=1y=0z=−1​。 然而心细的你估计发现了疏漏之处：“求一元二次方程时都要先检验根是否存在（Δ\\DeltaΔ判别式法）再来作答，你这里怎么没有讨论根的分布情况呢？” 事实上，矩阵的解的分布确实不止一种情况，这里是矩阵有唯一解的情况。类比高中立体几何求平面法向量的情景，我们通常都要令某个坐标为111或者是其他方便于计算的值，这里就是矩阵有无数组解的经典例子。要想系统分析矩阵方程解的数量情况，我们需要引入秩的概念。 Div2. 秩 在上一节中我们通过初等行变换求出了矩阵的解，然而并不是所有矩阵都能轻而易举求出唯一解，因为它可能无解、也有可能无唯一解（默认最高次数为一）。类比一元二次方程中的Δ\\DeltaΔ判别式法，矩阵是否也有判断根存在性的方法？ 答案是：有滴！在矩阵运算中，我们使用秩来描述矩阵的一些关于解的个数的关系。秩被定义为：将矩阵通过初等行变换后形成的梯形矩阵中非零行的个数。试看如下例子： 定义一个3×23\\times23×2的矩阵：(231693072)\\begin{pmatrix}2&amp;3&amp;1\\\\6&amp;9&amp;3\\\\0&amp;7&amp;2\\end{pmatrix}⎝⎛​260​397​132​⎠⎞​ 经过初等行变换后出现了这样的情况： (4−10000072)\\begin{pmatrix}4&amp;-1&amp;0\\\\0&amp;0&amp;0\\\\0&amp;7&amp;2\\end{pmatrix}⎝⎛​400​−107​002​⎠⎞​(第二行减去乘3的第一行，第一行乘2减去第三行) 第二行变成了纯000的一行，一、三行说什么都无法消成一个未知数的形式。如果写成方程组就是： {4x−y=a17y+2z=a2\\begin{cases}4x-y=a_1\\\\7y+2z=a_2\\end{cases}{4x−y=a1​7y+2z=a2​​ 它有无数组解，原因是：矩阵的秩与矩阵增广矩阵的秩相等且小于了它的阶。简单来说就是你用两个方程去求三个未知数的值（初一内容），当然是有无数多组解。 规定对于矩阵AAA，它的秩用R(A)R(A)R(A)表示（r(A)r(A)r(A)、rk(A)rk(A)rk(A)、rank(A)rank(A)rank(A)均可）。因此令方程组的nnn阶增广矩阵秩为R(A)R(A)R(A)，系数矩阵的秩为R(B)R(B)R(B)。矩阵有无数组解的条件就是R(B)&lt;nR(B)&lt;nR(B)&lt;n（严格来说：有无数组解的充要条件是R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n） 看第二个例子： 定义增广矩阵：A→(28313−2271)A\\rightarrow\\left(\\begin{array}{cc|c}2&amp;8&amp;3\\\\1&amp;3&amp;-2\\\\2&amp;7&amp;1\\end{array}\\right)A→⎝⎛​212​837​3−21​⎠⎞​；它的系数矩阵：B→(281327)B\\rightarrow\\begin{pmatrix}2&amp;8\\\\1&amp;3\\\\2&amp;7\\end{pmatrix}B→⎝⎛​212​837​⎠⎞​。 增广矩阵变换后：(01220−25003)\\left(\\begin{array}{cc|c}0&amp;1&amp;2\\\\2&amp;0&amp;-25\\\\0&amp;0&amp;3\\end{array}\\right)⎝⎛​020​100​2−253​⎠⎞​；系数矩阵：(012000)\\begin{pmatrix}0&amp;1\\\\2&amp;0\\\\0&amp;0\\end{pmatrix}⎝⎛​020​100​⎠⎞​ 根据定义，得到R(A)=3R(A)=3R(A)=3，R(B)=2R(B)=2R(B)=2，此时R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)。方程组无解。因而矩阵无解的充要条件是R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)。简单理解起来就是方程组中的两个方程起了冲突，矩阵AAA被省去的其中一步变换是：(01220−25015)\\left(\\begin{array}{cc|c}0&amp;1&amp;2\\\\2&amp;0&amp;-25\\\\0&amp;1&amp;5\\end{array}\\right)⎝⎛​020​101​2−255​⎠⎞​，第一行和第三行相当于要你求解如下的方程组：{y=2y=5\\begin{cases}y=2\\\\y=5\\end{cases}{y=2y=5​。显然矛盾，因此矩阵无解。 加上第一节里面的结论，我们总结出了矩阵解分布的三种情况（方程组的增广矩阵为AAA、系数矩阵为BBB，阶为nnn）： 当R(A)=R(B)=nR(A)=R(B)=nR(A)=R(B)=n时，矩阵有唯一解 当R(A)=R(B)&lt;nR(A)=R(B)&lt;nR(A)=R(B)&lt;n时，矩阵有无数解 当R(A)&gt;R(B)R(A)&gt;R(B)R(A)&gt;R(B)时，矩阵无解 因此就有了一套组合算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 110#define NO_SOLUTION -1#define INFINITE 0#define SOLVE_OK 1using namespace std;typedef long long ll;double mat[N][N];int n;double eps = 1e-6; int solve() &#123; int rank = 0; for (int c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; if (fabs(mat[i][c]) &gt; fabs(mat[t][c])) t = i; &#125; if (fabs(mat[t][c]) &lt; eps) continue; for (int i = c; i &lt;= n; i++) swap(mat[r][i], mat[t][i]); for (int i = n; i &gt;= c; i--) mat[r][i] /= mat[r][c]; for (int i = r + 1; i &lt; n; i++) &#123; if (fabs(mat[i][c]) &gt; eps) &#123; for (int j = n; j &gt;= c; j--) &#123; mat[i][j] -= (mat[r][j] * mat[i][c]); &#125; &#125; &#125; r++; rank = r; &#125; if (rank &lt; n) &#123; for (int i = rank; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; if (fabs(mat[i][j]) &gt; eps) return NO_SOLUTION; &#125; &#125; return INFINITE; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; mat[i][n] -= mat[i][j] * mat[j][n]; &#125; &#125; return SOLVE_OK;&#125; int main() &#123; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) cin&gt;&gt;mat[i][j]; &#125; int res = solve(); if (res != SOLVE_OK) cout&lt;&lt;res&lt;&lt;endl; else for (int i = 0; i &lt; n; i++) &#123; if (fabs(mat[i][n]) &lt; eps) mat[i][n] = fabs(mat[i][n]); printf(&quot;x%d=%.2lf\\n&quot;, i + 1, mat[i][n]); &#125; return 0;&#125; 时间复杂度：O(n3)\\mathcal O(n^3)O(n3) 以后上大学解高次线性方程就可以用这段程序秒了。 Div3. 矩阵基本运算 1. 加法： (238142)+(604335)=(2+63+08+41+34+32+5)=(8312477)\\begin{pmatrix}2&amp;3&amp;8\\\\1&amp;4&amp;2\\end{pmatrix}+\\begin{pmatrix}6&amp;0&amp;4\\\\3&amp;3&amp;5\\end{pmatrix}=\\begin{pmatrix}2+6&amp;3+0&amp;8+4\\\\1+3&amp;4+3&amp;2+5\\end{pmatrix}=\\begin{pmatrix}8&amp;3&amp;12\\\\4&amp;7&amp;7\\end{pmatrix}(21​34​82​)+(63​03​45​)=(2+61+3​3+04+3​8+42+5​)=(84​37​127​) 注意类比nnn元一次方程组的加减消元，两个矩阵相加意味着同一位置的元素相加。需要注意：只有同型的矩阵才有加法运算（同型即行数列数相等）。 可以知道，四则运算的加法交换律和结合律仍然适用于矩阵加法。 2. 减法： (238142)−(604335)=(2−63−08−41−34−32−5)=(−434−21−3)\\begin{pmatrix}2&amp;3&amp;8\\\\1&amp;4&amp;2\\end{pmatrix}-\\begin{pmatrix}6&amp;0&amp;4\\\\3&amp;3&amp;5\\end{pmatrix}=\\begin{pmatrix}2-6&amp;3-0&amp;8-4\\\\1-3&amp;4-3&amp;2-5\\end{pmatrix}=\\begin{pmatrix}-4&amp;3&amp;4\\\\-2&amp;1&amp;-3\\end{pmatrix}(21​34​82​)−(63​03​45​)=(2−61−3​3−04−3​8−42−5​)=(−4−2​31​4−3​) 加法的逆运算，让矩阵同一位置的元素相减即可。也是仅限于同型矩阵之间才可做减法。 3. 数乘： 4⋅(142615360)=(1×44×42×46×41×45×43×46×40×4)=(41682442012240)4\\cdot\\begin{pmatrix}1&amp;4&amp;2\\\\6&amp;1&amp;5\\\\3&amp;6&amp;0\\end{pmatrix}=\\begin{pmatrix}1\\times4&amp;4\\times4&amp;2\\times4\\\\6\\times4&amp;1\\times4&amp;5\\times4\\\\3\\times4&amp;6\\times4&amp;0\\times4\\end{pmatrix}=\\begin{pmatrix}4&amp;16&amp;8\\\\24&amp;4&amp;20\\\\12&amp;24&amp;0\\end{pmatrix}4⋅⎝⎛​163​416​250​⎠⎞​=⎝⎛​1×46×43×4​4×41×46×4​2×45×40×4​⎠⎞​=⎝⎛​42412​16424​8200​⎠⎞​ 即矩阵中每个元素都跟数字相乘。符合乘法交换律和结合律 矩阵的加法、减法和数乘合称为矩阵的线性运算 4. 转置： 矩阵AAA的转置矩阵用ATA^TAT表示。 (142615)T=(164125)\\begin{pmatrix}1&amp;4&amp;2\\\\6&amp;1&amp;5\\end{pmatrix}^T=\\begin{pmatrix}1&amp;6\\\\4&amp;1\\\\2&amp;5\\end{pmatrix}(16​41​25​)T=⎝⎛​142​615​⎠⎞​ 直观来讲就是将原矩阵旋转一下（行和列互换）。满足如下性质： (AT)T=A(A^T)^T=A(AT)T=A (转置一次后再转置一次还是原来的矩阵) (λA)T=λAT(\\lambda A)^T=\\lambda A^T(λA)T=λAT （常数转置后就是它本身） (AB)T=ATBT(AB)^T=A^TB^T(AB)T=ATBT （上一条是它的特殊形式，类比两数乘积的幂） 5. 共轭： 矩阵AAA的共轭矩阵用A‾\\overline AA表示。 A=(2+i85−4i2i)A=\\begin{pmatrix}2+i&amp;8\\\\5-4i&amp;2i\\end{pmatrix}A=(2+i5−4i​82i​) A‾=(2−i85+4i−2i)\\overline A=\\begin{pmatrix}2-i&amp;8\\\\5+4i&amp;-2i\\end{pmatrix}A=(2−i5+4i​8−2i​) 类比共轭复数的定义：实部不变、虚部取相反数。矩阵共轭变换就是将矩阵中的所有复数变为其共轭形式。 6. 共轭转置： 矩阵AAA的共轭转置矩阵记作A∗A^*A∗、A‾T\\overline A^TAT、AT‾\\overline{A^T}AT或AHA^HAH。 A=(2+i85−4i2i1+i2−2i)A=\\begin{pmatrix}2+i&amp;8\\\\5-4i&amp;2i\\\\1+i&amp;2-2i\\end{pmatrix}A=⎝⎛​2+i5−4i1+i​82i2−2i​⎠⎞​ AH=(2−i5+4i1−i8−2i2+2i)A^H=\\begin{pmatrix}2-i&amp;5+4i&amp;1-i\\\\8&amp;-2i&amp;2+2i\\end{pmatrix}AH=(2−i8​5+4i−2i​1−i2+2i​) 字面意思，先取共轭，再转置。它具备转置矩阵的三条性质。 Div4. 矩阵乘法 只有一个矩阵的行数和另一个矩阵的列数相等时才可进行乘法运算。 例如一个n×pn\\times pn×p矩阵A→(142308)A\\rightarrow\\begin{pmatrix}1&amp;4&amp;2\\\\3&amp;0&amp;8\\end{pmatrix}A→(13​40​28​)和一个p×mp\\times mp×m矩阵B→(264138)B\\rightarrow\\begin{pmatrix}2&amp;6\\\\4&amp;1\\\\3&amp;8\\end{pmatrix}B→⎝⎛​243​618​⎠⎞​。记它们的乘积C=ABC=ABC=AB。则CCC中的某个元素ci,j=ai,1b1,j+ai,2b2,j+⋯+ai,pbp,j=∑k=1nai,kbk,jc_{i,j}=a_{i,1}b_{1,j}+a_{i,2}b_{2,j}+\\dots+a_{i,p}b_{p,j}=\\sum\\limits_{k=1}^{n}a_{i,k}b_{k,j}ci,j​=ai,1​b1,j​+ai,2​b2,j​+⋯+ai,p​bp,j​=k=1∑n​ai,k​bk,j​。并且CCC是一个n×mn\\times mn×m的矩阵。 因此AB=(1×2+4×4+2×31×6+4×1+2×83×2+0×4+8×33×6+0×1+8×8)=(24263082)AB=\\begin{pmatrix}1\\times2+4\\times4+2\\times3&amp;1\\times6+4\\times1+2\\times8\\\\3\\times2+0\\times4+8\\times3&amp;3\\times6+0\\times1+8\\times8\\end{pmatrix}=\\begin{pmatrix}24&amp;26\\\\30&amp;82\\end{pmatrix}AB=(1×2+4×4+2×33×2+0×4+8×3​1×6+4×1+2×83×6+0×1+8×8​)=(2430​2682​) 它满足结合律、分配律，但是大多数情况下不满足交换律。交换律不成立可以看到下面这个例子： 首先根据定义，CCC矩阵的行列数取决于做乘法的两个矩阵AAA和BBB的行列数，比如8×38\\times38×3矩阵和3×43\\times43×4矩阵相乘，得到一个8×48\\times48×4矩阵，但是将它颠倒顺序，让一个3×43\\times43×4矩阵与8×38\\times38×3矩阵相乘，结果将是一个4×84\\times84×8矩阵，和前者行列数相反。 对于结果是正方形矩阵的，可以自己随便设置两个矩阵进行计算。但是部分矩阵仍然可以进行交换律运算：矩阵乘一个单位矩阵/数量矩阵[AE=EAAE=EAAE=EA/A(kE)=(kE)AA(kE)=(kE)AA(kE)=(kE)A]、矩阵乘它的伴随矩阵（AA∗=A∗AAA^*=A^*AAA∗=A∗A）。 Div5. 其他常用类型的矩阵 1. 零矩阵：顾名思义，由000组成的矩阵称作零矩阵。零矩阵不可逆，且任何符合条件的矩阵与一个零矩阵的积均为零矩阵。 2. 单位矩阵：形如(100010001)\\begin{pmatrix}1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\end{pmatrix}⎝⎛​100​010​001​⎠⎞​的矩阵被称作单位矩阵，通常用字母EEE或III表示。单位矩阵指仅对角线系数为111、且其他系数为000的矩阵。nnn阶矩阵与它的逆矩阵相乘得到的结果就是一个nnn阶单位矩阵，即AA−1=EAA^{-1}=EAA−1=E。 3. 数量矩阵：形如(k000k000k),k∈R\\begin{pmatrix}k&amp;0&amp;0\\\\0&amp;k&amp;0\\\\0&amp;0&amp;k\\end{pmatrix},k\\in\\mathbb R⎝⎛​k00​0k0​00k​⎠⎞​,k∈R的矩阵叫数量矩阵，可以看作实数kkk与单位矩阵EEE进行数乘运算后的结果，通常表示成kE,k∈RkE,k\\in\\mathbb RkE,k∈R。矩阵与一个数量矩阵的乘积满足乘法交换律。 4. 逆矩阵：如果存在一个矩阵BBB和单位矩阵EEE，使得AB=E=BAAB=E=BAAB=E=BA，则称矩阵AAA可逆，BBB是AAA的逆矩阵，也可记作A−1A^{-1}A−1。单位矩阵的逆矩阵是它本身；零矩阵不可逆。nnn阶矩阵可逆的充要条件是R(A)=nR(A)=nR(A)=n。 5. 对称矩阵：转置矩阵与自身相等的矩阵叫做对称矩阵，特征是所有元素关于对角线对称，例如：(035308580)\\begin{pmatrix}0&amp;3&amp;5\\\\3&amp;0&amp;8\\\\5&amp;8&amp;0\\end{pmatrix}⎝⎛​035​308​580​⎠⎞​。对称矩阵必为方形矩阵，反之不一定成立，对于一个方形矩阵AAA，A+ATA+A^TA+AT必定是对称矩阵。 Div6. 矩阵的几何表示 平面直角坐标系上，一个向量a⃗=(1,2)\\vec a=(1,2)a=(1,2)可以被表示成[12]\\begin{bmatrix}1\\\\2\\end{bmatrix}[12​]的形式，即[xy]\\begin{bmatrix}x\\\\y\\end{bmatrix}[xy​]。 计算机中，用两个不共线向量i⃗\\vec ii和j⃗\\vec jj​能够表示整个平面直角坐标系。运用一点高中数学的空间几何知识，这里的i⃗\\vec ii和j⃗\\vec jj​被称作基底（当然，如果需要描述三维空间坐标系，则需要三个不共线的基底向量）。于是我们使用矩阵[xixjyiyj]\\begin{bmatrix}\\textcolor{red}{x_i}&amp;\\textcolor{green}{x_j}\\\\\\textcolor{red}{y_i}&amp;\\textcolor{green}{y_j}\\end{bmatrix}[xi​yi​​xj​yj​​]来描述这个平面直角坐标系就是非常简洁明了且优雅的了。 假设我们常规想法中的平面直角坐标系是[1001]\\begin{bmatrix}\\textcolor{red}{1}&amp;\\textcolor{green}{0}\\\\\\textcolor{red}{0}&amp;\\textcolor{green}{1}\\end{bmatrix}[10​01​]，经过一轮线性变换后得到的新坐标系是：[231−2]\\begin{bmatrix}\\textcolor{red}{2}&amp;\\textcolor{green}{3}\\\\\\textcolor{red}{1}&amp;\\textcolor{green}{-2}\\end{bmatrix}[21​3−2​]。用一张图看一下变换后的坐标系： 如果在最开始的坐标系中有一个向量a⃗→[57]\\vec a\\rightarrow\\begin{bmatrix}5\\\\7\\end{bmatrix}a→[57​]，我们如何在新的坐标系中表示它呢？再根据我们高中数学所学，只需要算出5i⃗+7j⃗5\\vec i+7\\vec j5i+7j​的值即可。因为i⃗\\vec ii是xxx轴的基底，相当于xxx上的一个单位，我们求新向量时只需求出在新的参考系中的新xxx值和yyy值，因而直接用xxx方向的系数乘以一个单位即可，在这里就是5⋅[21]+7⋅[3−2]5\\cdot\\begin{bmatrix}\\textcolor{red}{2}\\\\\\textcolor{red}{1}\\end{bmatrix}+7\\cdot\\begin{bmatrix}\\textcolor{green}{3}\\\\\\textcolor{green}{-2}\\end{bmatrix}5⋅[21​]+7⋅[3−2​]，得到a⃗→[31−9]\\vec a\\rightarrow\\begin{bmatrix}31\\\\-9\\end{bmatrix}a→[31−9​]。 抽象之后变成： [abcd][xy]=x[ac]+y[ad]=[ax+bycx+dy]\\begin{bmatrix}\\textcolor{red}{a}&amp;\\textcolor{green}{b}\\\\\\textcolor{red}{c}&amp;\\textcolor{green}{d}\\end{bmatrix}\\begin{bmatrix}x\\\\y\\end{bmatrix}=x\\begin{bmatrix}\\textcolor{red}{a}\\\\\\textcolor{red}{c}\\end{bmatrix}+y\\begin{bmatrix}\\textcolor{green}{a}\\\\\\textcolor{green}{d}\\end{bmatrix}=\\begin{bmatrix}\\textcolor{red}{a}x+\\textcolor{green}{b}y\\\\\\textcolor{red}{c}x+\\textcolor{green}{d}y\\end{bmatrix}[ac​bd​][xy​]=x[ac​]+y[ad​]=[ax+bycx+dy​] TODOTODOTODO 例题： P3389 [模板] 高斯消元法 （上三角矩阵的转换） P2455 [SDOI2006] 线性方程组 （前一道题的升级版） Part8. 组合计数 StarterDiv1. 阶乘概述 阶乘，数学中用!!!表示，n!,n∈Nn!,n\\in\\mathbb Nn!,n∈N表示n×(n−1)×(n−2)⋯×2×1n\\times(n-1)\\times(n-2)\\dots\\times2\\times1n×(n−1)×(n−2)⋯×2×1的值，即∏i=0n−1(n−i)\\prod\\limits_{i=0}^{n-1}(n-i)i=0∏n−1​(n−i) 特殊地，0!=10!=10!=1。 StarterDiv2. 常用排列总结 1. 排列数：数学中用AnmA_{n}^{m}Anm​表示（ArrangementArrangementArrangement，老教材记作PnmP_{n}^{m}Pnm​，PermulationPermulationPermulation）。表示从mmm个数中选择nnn个进行排列，公式为：Anm=n(n−1)(n−2)…(n−m+1)=n!(n−m)!A_{n}^{m}=n(n-1)(n-2)\\dots(n-m+1)=\\frac{n!}{(n-m)!}Anm​=n(n−1)(n−2)…(n−m+1)=(n−m)!n!​ 为啥呢？，有弔图为证↓ 2. 组合数：假设有mmm个物品，从中任选出nnn个排成一组，叫做组合；所有可能的选法总数叫做组合数。用CnmC_{n}^{m}Cnm​表示，计算公式为：Cnm=AnmAmm=n!m!(n−m)!C_{n}^{m}=\\frac{A_{n}^{m}}{A_{m}^{m}}=\\frac{n!}{m!(n-m)!}Cnm​=Amm​Anm​​=m!(n−m)!n!​。简记为：乌鸦坐飞机 弔图×2↓ GZ表示就凭这几张图他能速通整个组合数的内容 StarterDiv3. 二项式定理 学过初中的大家都知道：(x+y)2=x2+2xy+y2(x+y)^2=x^2+2xy+y^2(x+y)2=x2+2xy+y2，这是完全平方和公式。高中的一些牛逼娃还知道完全立方和公式，也就是：(x+y)3=(x+y)(x2+xy+y2)=x3+3y2x+3xy2+y3(x+y)^3=(x+y)(x^2+xy+y^2)=x^3+3y^2x+3xy^2+y^3(x+y)3=(x+y)(x2+xy+y2)=x3+3y2x+3xy2+y3。这些式子其实都是可以由二项式定理套出来的。 二项式定理定义式如下： (x+y)n=(n0)xny0+(n1)xn−1y1+(n2)xn−2y2+⋯+(nn−1)x1yn−1+(nn)x0yn=∑k=0n(nk)xn−kyk(x+y)^n=\\begin{pmatrix}n\\\\0\\end{pmatrix}x^ny^0+\\begin{pmatrix}n\\\\1\\end{pmatrix}x^{n-1}y^1+\\begin{pmatrix}n\\\\2\\end{pmatrix}x^{n-2}y^2+\\dots+\\begin{pmatrix}n\\\\n-1\\end{pmatrix}x^1y^{n-1}+\\begin{pmatrix}n\\\\n\\end{pmatrix}x^0y^n=\\sum\\limits_{k=0}^{n}\\begin{pmatrix}n\\\\k\\end{pmatrix}x^{n-k}y^k(x+y)n=(n0​)xny0+(n1​)xn−1y1+(n2​)xn−2y2+⋯+(nn−1​)x1yn−1+(nn​)x0yn=k=0∑n​(nk​)xn−kyk 这里出现的(nk)=n!k!(n−k)!\\begin{pmatrix}n\\\\k\\end{pmatrix}=\\frac{n!}{k!(n-k)!}(nk​)=k!(n−k)!n!​。是不是突然发现它和组合数公式的共同之处喽？但是这一章并不会用它，只是作补充知识的说…… 有这三条就够了，接下来进入组合计数的内容。 Div1. 高考娃狂喜——组合数计算 一个小栗子： 宇宙榜一大学阿福大学的榜一博士后导师黑虎阿福给你出了一道难题： 给你两个正整数aaa和bbb（a≥ba\\geq ba≥b），让你求出CbaC_{b}^{a}Cba​的值。 你：“这还不简单？” 阿福： “好的，我这里将aaa设为208509042085090420850904，bbb设为177209317720931772093，请你求解。” 你： “WTF？” 于是你决定用程序来代替人脑，阿福教授也做出了一定让步，让你求出Cba mod pC_{b}^{a}\\bmod pCba​modp的值。但是不幸的是，人类的计算机科学水平自从2024之后就被来自几光年外的八体星人文明发出的“侄子一号（NEPHEW 1）”探测僚机锁定了，因此你需要设计一个高效的计算方式，而不是妄想着用2077年的赛博机器运行暴力计算，来解决这个问题。 一旦你的运行时间超过一秒，阿福教授就会使用战技“乌鸦坐飞机”对你造成大量阶乘伤害。已经学习了阶乘的你想必已了解了它的威力，所以还是老老实实推导公式吧！ 递推版： 组合数递推公式：Cab=Ca−1b+Ca−1b−1C_{a}^{b}=C_{a-1}^{b}+C_{a-1}^{b-1}Cab​=Ca−1b​+Ca−1b−1​。 分析思路类似于动态规划问题：我们要从aaa个物品中挑选bbb个出来，求组合数。 上图中，若包含这个红色物体，那么我们只需再从剩下的a−1a-1a−1个物体里挑选，因为红色物体自身占据了bbb个位置中的其中一个，因此留给其他物体的总名额就只有b−1b-1b−1个，因此该情况下组合数：Ca−1b−1C_{a-1}^{b-1}Ca−1b−1​；同样地，若不包含红色物体，从剩下的a−1a-1a−1个物体中选出bbb个，因为在该情况下红色的物体不计入组合，因此剩余名额还是bbb个，组合数就是Ca−1bC_{a-1}^{b}Ca−1b​。最后，因为从aaa个物体里选，只有包含红色和不包含红色两种情况（就好像你的双亲，不是你的母亲就是你的父亲），因此可以做到不重不漏。所以总组合数就是Ca−1b−1+Ca−1bC_{a-1}^{b-1}+C_{a-1}^{b}Ca−1b−1​+Ca−1b​。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 2010using namespace std;int c[N][N];void Csieve(int p) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % p; &#125; &#125;&#125;int main() &#123; int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; Csieve(p); cout&lt;&lt;c[a][b]&lt;&lt;endl; return 0;&#125; 时间复杂度：O(N2)\\mathcal O(N^2)O(N2) 适用于a,b≤105a,b\\leq10^5a,b≤105的大部分情况。 预处理版： 但是众所周知，递归有两大痛点：对于主观思维来说，是边界问题；对于客观条件来说，是内存。递归过程中CPU里储存了大量的未运行或者待返回的函数实例，当aaa和bbb的值增大时，尽管它能在时间方面表现出色，但是内存就不那么理想了，反而会显得臃肿至极。当题目中给出a,b≥105a,b\\geq10^5a,b≥105时，建议用这种方法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;int fact[N], infact[N];int qpow(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int a, int p) &#123; return qpow(a, p - 2, p);&#125;int C(int a, int b, int p) &#123; return ((fact[a] % p) * (infact[b] % p)) % p * infact[a - b] % p; &#125;int main() &#123; int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; fact[0] = infact[0] = 1; for (int i = 1; i &lt;= N; i++) &#123; fact[i] = (ll) fact[i - 1] * i % p; infact[i] = (ll) infact[i - 1] * inv(i, p) % p; &#125; cout&lt;&lt;C(a, b, p)&lt;&lt;endl; return 0;&#125; 时间复杂度：O(Nlog⁡N)\\mathcal O(N\\log N)O(NlogN) 适用范围，a,b≥105a,b\\geq10^5a,b≥105且a,ba,ba,b均在int范围内的大部分情况。 Lucas定理优化版： LucasLucasLucas定理如下：Cab≡Ca mod pb mod p⋅Ca÷pb÷p(modp)C_{a}^{b}\\equiv C_{a\\bmod p}^{b\\bmod p}\\cdot C_{a\\div p}^{b\\div p}\\pmod pCab​≡Camodpbmodp​⋅Ca÷pb÷p​(modp)（ppp为质数）。证明在此（建议直接背结论）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef long long ll;int p;int qpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int a) &#123; return qpow(a, p - 2);&#125;int C(int a, int b) &#123; int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) &#123; res = (ll) res * j % p; res = (ll) res * inv(i) % p; &#125; return res;&#125;ll lucas(int a, int b) &#123; if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (ll) C(a % p, b % p) * lucas(a / p, b / p) % p;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; int n, m; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; cout&lt;&lt;lucas(n + m, n)&lt;&lt;endl; &#125; return 0;&#125; 时间复杂度：O(N)\\mathcal O(N)O(N) 其本质是套用LucasLucasLucas定理计算CabC_{a}^{b}Cab​，因为是模ppp意义下的除法，因而我们使用逆元来操作除法。 适用范围，a,ba,ba,b在long long范围内的大部分情况。 高精度版（选修）： 什么？你厌倦了组合数后面挂着的模ppp？不妨试试高精度版的组合数计算吧！它适用于作业上的题目求解！（虽然前面几种也可以，毕竟手算的题数据很小取不取模都一样）是不是心动了呢？ 常规思路来说，我们的组合数公式经过一轮分式化简可以得到：Cab=a×(a−1)×(a−2)×⋯×(a−b+1)b×(b−1)×(b−2)×⋯×2×1C_{a}^{b}=\\frac{a\\times(a-1)\\times(a-2)\\times\\dots\\times(a-b+1)}{b\\times(b-1)\\times(b-2)\\times\\dots\\times2\\times1}Cab​=b×(b−1)×(b−2)×⋯×2×1a×(a−1)×(a−2)×⋯×(a−b+1)​。因此我们可以实现高精度的乘除法来计算这个炒鸡长的算式，但是这样不仅效率低下，手写和调试的难度也会增加。我们急切地想知道如何简化成一种高精度算法。 我们看到了Part1里面讲的算术基本定理，将组合数转化为p1c1p2c2p3c3...pkckp_{1}^{c_1}p_{2}^{c_2}p_{3}^{c_3}...p_{k}^{c_k}p1c1​​p2c2​​p3c3​​...pkck​​的质数乘积分解式，最后我们只需要解决质数头顶的指数即可。我们使用以下这个公式： α(n!)=⌊np⌋⋅⌊np2⌋⋅⋯⋅⌊npk⌋,pk≤n,n,k∈Z\\alpha(n!)=\\lfloor\\frac{n}{p}\\rfloor\\cdot\\lfloor\\frac{n}{p^2}\\rfloor\\cdot\\dots\\cdot\\lfloor\\frac{n}{p^k}\\rfloor,p^k\\leq n, n,k\\in\\mathbb Zα(n!)=⌊pn​⌋⋅⌊p2n​⌋⋅⋯⋅⌊pkn​⌋,pk≤n,n,k∈Z。 用它可以计算出n!n!n!中pip_ipi​的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;typedef long long ll;vector&lt;int&gt; num;ll primes[N], sum[N];bool st[N];int cnt = 0;void prime_sieve(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[++cnt] = i; for (int j = 1; i * primes[j] &lt;= n; j++) &#123; st[i * primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;int get(int a, int p) &#123; int res = 0; while (a) &#123; res += a / p; a /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) &#123; vector&lt;int&gt; res; int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i] * b; res.push_back(t % 10); t /= 10; &#125; while (t) &#123; res.push_back(t % 10); t /= 10; &#125; return res;&#125;int main() &#123; int a, b; cin&gt;&gt;a&gt;&gt;b; prime_sieve(a); for (int i = 1; i &lt;= cnt; i++) sum[i] = get(a, primes[i]) - get(b, primes[i]) - get(a - b, primes[i]); vector&lt;int&gt; res; res.push_back(1); for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= sum[i]; j++) &#123; res = mul(res, primes[i]); &#125; &#125; for (int i = res.size() - 1; i &gt;= 0; i--) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0;&#125; 时间复杂度：O(NN)\\mathcal O(N\\sqrt N)O(NN​) 适用范围，a,ba,ba,b在int范围内。 有了这段代码，我们就可以完成开头阿福教授的原问题了（不模不限数据）！ Div2. 世界上最OI的IDE——Catalan数 当你翻开Catalan数的介绍文章，并大学特学了一番，感觉自己完全掌握了这神奇的数列，正当你兴致勃勃地打开题库搜索到一道Catalan数的题目正准备大展身手时，你会发现，面对这神奇的题干，不同于往常秒模板题的你，你甚至完全看不出来它和Catalan数有任何的关系，而且很有可能，你其实连Catalan数究竟是什么东西都不知道！ 苏子愀然，正襟危坐而问客曰：“何为其然也？” 其实还真不能让那些博客背上黑锅，这种现象与Catalan数本身的应用有很大的关系。 Catalan数，或者习惯叫卡特兰数、明安图数，是组合数学中常用的特殊数列。数列如下：“1,1,2,5,14,42,132,429,1430,4862,…1,1,2,5,14,42,132,429,1430,4862,\\dots1,1,2,5,14,42,132,429,1430,4862,…”，它是一个无穷数列，数与数之间看起来似乎也没什么太大联系……其实它和斐波那契数列有类似之处，它们不具有特定的数学意义（只是斐波那契的递推方法简单得多罢了），只是一个十分普遍的数学规律。所以学习时应该挂靠于例子本身而不是一味依赖于定义所写，那我们就开始吧： 用最经典的例子写出来就是： 给你一个u×vu\\times vu×v的网格，你将从原点(0,0)(0,0)(0,0)开始移动。对于每次移动，你只能向上/向右一格（yyy坐标/xxx坐标加一），但是需要保证你总向右走的次数不少于向上走的次数，问从原点到A(n,n)A(n,n)A(n,n)有多少种不同的合法路径？ 假设你某时刻走到了点M(s,t)M(s,t)M(s,t)，根据题目要求，意味着需要保证s≥ts\\geq ts≥t。我们拟合一条经过点MMM的正比例函数，不难看出它的斜率k≤1k\\leq1k≤1。对于这个u×vu\\times vu×v的网格，所有的点都在整数刻度上。我们接着画出直线y=x+1y=x+1y=x+1的图像，然后尽可能画几条不合法的路径出来比对一下，你会发现：不合法的路径与直线y=x+1y=x+1y=x+1至少有一个交点，合法路径一定与y=x+1y=x+1y=x+1没有交点。用一张图来直观体会一下： 终点A(5,5)A(5,5)A(5,5)，其中红线为不合法路径，蓝线为合法路径。不难发现，不合法的路径与绿线（y=x+1y=x+1y=x+1）都有至少一个交点，因为它们在某次移动后的端点与原点拟合而成的正比例函数的斜率k&gt;1k&gt;1k&gt;1，因此不是合法路径。 那么如何来计算合法和不合法路径的条数呢？直接求出合法路径不好求，规律不好找，因此我们计算出总路径数量，减去不合法数量即是合法路径数量。 可以看到，无论选择什么样的路径，在不左移、不下移的前提下，到达A(n,n)A(n,n)A(n,n)，你都只能移动2n2n2n次（小学内容，把横线和竖线平移到一块数格子），其中右移nnn次、上移nnn次。转化一下，就是在2n2n2n次移动中选出nnn次进行右移操作，总数就是C2nnC_{2n}^nC2nn​。 因为所有路径，包括合法的和不合法的路径都最终抵达了A(5,5)A(5,5)A(5,5)，难以将内鬼剔除出来。我们选择将不合法路径关于判定线y=x+1y=x+1y=x+1对称过去，它们的新终点将是A′(4,6)A^\\prime(4,6)A′(4,6)，也就是A′(n−1,n+1)A^\\prime(n-1,n+1)A′(n−1,n+1)。根据上面的推导方法，这里就是在2n2n2n轮移动中挑出n−1n-1n−1次右移操作，于是不合法路径的数量就是：C2nn−1C_{2n}^{n-1}C2nn−1​，合法路径数量是：f=C2nn−C2nn−1f=C_{2n}^{n}-C_{2n}^{n-1}f=C2nn​−C2nn−1​。 （至于为什么用右移次数而不是上移次数，是因为上移受到限制，这意味着你可以一直右移到x=5x=5x=5而无需担心条件限制；但是你就不能先一直上移到y=5y=5y=5，因为这不符合题目要求） 扩展：如果题干中指明向右走的次数不少于向上走的次数±t\\pm t±t，则只需将判定线上下平移为y=x+1±ty=x+1\\pm ty=x+1±t即可。 那这些又和宇宙第一IDE有什么关系呢 应用场景一：括号匹配 将向右走转化为左括号“（”，向上走转化为右括号“）”。对于每一次输入，检查一下左括号输入次数是否永不小于右括号输入次数。若是，当输入最后一个右括号，使左右括号数量相同时，即为匹配成功；若不是，且左括号个数大于右括号个数，则表明括号等待补全；若不是，且左括号个数小于右括号个数，即立即宣布失配。 应用场景二：合法进出栈序列计数问题 假设一个初始为空的栈，有2n2n2n次操作，nnn次进栈，nnn次出栈，请问合法进出栈序列总数（空栈不出）是多少？ 答案就是Catalan数，自行套公式计算。 应用场景三：圆的不相交弦计数问题 假设一个圆周上分布着偶数个点，对这些点两两连线，使相连的线不相交的所有方案数。其中一个合法解如下图： 聪明如你，答案还是Catalan数！那么如何转化为已知问题求解呢？ 我们将出发点标记为左括号“（”，从出发点引出去的线与其他线/点的所有交点标记为右括号“）”。当所有点两两连接完毕时，根据场景一的模型，一旦左右括号失配即代表不合法，否则合法。因此这个问题也就变成了：给定2n2n2n个左括号和右括号，求出使左右括号匹配的排列个数。在这里，如果问题无解，将会是这样： 例题： P3807 [模板] 卢卡斯定理/Lucas 定理 P5014 水の三角(修改版) （Catalan数公式变形推导）","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"一命已出，前来还愿","slug":"thanks","date":"2023-11-12T01:42:41.000Z","updated":"2023-11-12T01:45:04.509Z","comments":true,"path":"2023/11/12/thanks/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/thanks/","excerpt":"","text":"","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"}]},{"title":"Latex常用符号大全","slug":"latex-symbols","date":"2023-11-12T01:23:35.000Z","updated":"2023-11-26T00:56:36.729Z","comments":true,"path":"2023/11/12/latex-symbols/","link":"","permalink":"https://justpureh2o.github.io/2023/11/12/latex-symbols/","excerpt":"","text":"Part1. 运算符 Div1. 基本运算 加号：+++，键盘上有 减号：−-−，键盘上有 乘号（叉乘）: $ \\times $ \\times 乘号（数量积/点乘）：⋅\\cdot⋅ \\cdot 除号：÷\\div÷ \\div 开方/N次方根：ABCN\\sqrt[N]{ABC}NABC​ \\sqrt[N]&#123;ABC&#125; 乘方/N次幂：ANA^NAN A^N 下标：ANA_NAN​ A_N 分数：AB\\frac{A}{B}BA​ \\frac&#123;A&#125;&#123;B&#125; 等于号：===，键盘上有 约等号：≈\\approx≈ \\approx 加粗 ≈\\thickapprox≈ \\thickapprox 不等号：≠\\neq​= \\neq 恒等号/定义为：≡\\equiv≡ \\equiv 大于号：&gt;\\gt&gt; \\gt 小于号：&lt;\\lt&lt; \\lt 大于等于：≥\\geq≥ \\geq 小于等于：≤\\leq≤ \\leq 远大于：≫\\gg≫ \\gg 远小于：≪\\ll≪ \\ll 正负：±\\pm± \\pm 负正：∓\\mp∓ \\mp Div.2 几何表示 垂直：⊥\\perp⊥ \\perp 平行：∥\\parallel∥ \\parallel 角/无标记角：∠\\angle∠ \\angle 角/标记角：∡\\measuredangle∡ \\measuredangle 一般全等：≅\\cong≅ \\cong 相似：∼\\sim∼ \\sim，加粗 ∼\\thicksim∼ \\thicksim 三角形：△\\triangle△ \\triangle 正方形：□\\square□ \\square 圆：⊙\\odot⊙ \\odot 向量：AB⃗\\vec{AB}AB \\vec_&#123;AB&#125; 或 AB→\\overrightarrow{AB}AB \\overrightarrow&#123;AB&#125; Div.3 集合 属于：∈\\in∈ \\in 不属于：∉\\notin∈/​ \\notin 子集：⫅\\subseteqq⫅ \\subseteqq 真子集：⫋\\varsubsetneqq \\varsubseteqq 或 ⫋\\subsetneqq⫋ \\subsetneqq 真子集/直线在平面上：⊂\\subset⊂ \\subset 正整数集：N∗N^*N∗ N^* 或 N+N_+N+​ N_+ 并集：∪\\cup∪ \\cup 交集：∩\\cap∩ \\cap 补集：∁UA\\complement{_U^A}∁UA​ \\complement&#123;_U^A&#125; Div.4 逻辑符号 因为：∵\\because∵ 所以：∴\\therefore∴ 存在：∃\\exists∃ \\exists 不存在：∄\\nexists∄ \\nexists 任意/对于所有：∀\\forall∀ \\forall 空集：∅\\varnothing∅ \\varnothing 逻辑或：∪\\cup∪ \\cup 或 ∨\\lor∨ \\lor 逻辑与：∩\\cap∩ \\cap 或 ∧\\land∧ \\land 逻辑非：¬\\lnot¬ \\lnot 充分条件/右双箭头：⇒\\Rightarrow⇒ \\Rightarrow 大小写敏感 必要条件/左双箭头：⇐\\Leftarrow⇐ \\Leftarrow 大小写敏感 充要条件/双向双箭头：⇔\\Leftrightarrow⇔ \\Leftrightarrow 大小写敏感 Div.5 高级数学 成正比：∝\\propto∝ \\propto 定积分：∫ab\\int_{a}^{b}∫ab​ \\int_&#123;a&#125;^&#123;b&#125; 多重积分：∬ab\\iint_{a}^{b}∬ab​ \\iint_&#123;a&#125;^&#123;b&#125; 及 ∭ab\\iiint_{a}^{b}∭ab​ \\iiint_&#123;a&#125;^&#123;b&#125; 导函数/上撇号：′\\prime′ \\prime 求和：∑i=1n\\sum_{i=1}^{n}∑i=1n​ \\sum_&#123;i=1&#125;^&#123;n&#125; 求积：∏i=1n\\prod_{i=1}^{n}∏i=1n​ \\prod_&#123;i=1&#125;^&#123;n&#125; 字母数位/平均数：ABCD‾\\overline{ABCD}ABCD \\overline&#123;ABCD&#125; 整除符号：∣\\mid∣ \\mid 新定义运算符：⊕\\oplus⊕ \\oplus 及 ⊗\\otimes⊗ \\otimes 及 ⊖\\ominus⊖ \\ominus 扰动值：K~\\tilde{K}K~ \\tilde&#123;K&#125; 高德纳箭头/上箭头：3↑↑23\\uparrow \\uparrow 23↑↑2 3\\uparrow \\uparrow 2 Div.6 常数 无穷大/无限：∞\\infty∞ \\infty 圆周率：π\\piπ \\pi 普朗克常数：ℏ\\hbarℏ \\hbar 或 ℏ\\hslashℏ \\hslash Div.7 注音 一声：eˉ\\bar{e}eˉ \\bar&#123;e&#125; 二声/法语闭音符：eˊ\\acute{e}eˊ \\acute&#123;e&#125; 三声：eˇ\\check{e}eˇ \\check&#123;e&#125; 四声/法语重音符：eˋ\\grave{e}eˋ \\grave&#123;e&#125; 字母双点/德语特殊字母/特殊拼音：u¨\\ddot{u}u¨ \\ddot&#123;u&#125; 特殊发音符：a~\\tilde{a}a~ \\tilde&#123;a&#125; 抑扬符：a^\\hat{a}a^ \\hat&#123;a&#125; Div.8 希腊/希伯来字母 小写希腊字母 α\\alphaα \\alpha β\\;\\;\\;\\;\\betaβ \\beta χ\\;\\;\\;\\;\\chiχ \\chi δ\\;\\;\\;\\;\\deltaδ \\delta ϵ\\;\\;\\;\\;\\epsilonϵ \\epsilon η\\;\\;\\;\\;\\etaη \\eta γ\\gammaγ \\gamma ι\\;\\;\\;\\;\\iotaι \\iota κ\\;\\;\\;\\;\\kappaκ \\kappa λ\\;\\;\\;\\;\\lambdaλ \\lambda μ\\;\\;\\;\\;\\muμ \\mu ν\\;\\;\\;\\;\\nuν \\nu ooo o ω\\;\\;\\;\\;\\omegaω \\omega ϕ\\;\\;\\;\\;\\phiϕ \\phi π\\;\\;\\;\\;\\piπ \\pi ψ\\;\\;\\;\\;\\psiψ \\psi ρ\\;\\;\\;\\;\\rhoρ \\rho σ\\sigmaσ \\sigma τ\\;\\;\\;\\;\\tauτ \\tau θ\\;\\;\\;\\;\\thetaθ \\theta υ\\;\\;\\;\\;\\upsilonυ \\upsilon ξ\\;\\;\\;\\;\\xiξ \\xi ζ\\;\\;\\;\\;\\zetaζ \\zeta 变量希腊字母 ϝ\\digammaϝ \\digamma ε\\;\\;\\;\\;\\varepsilonε \\varepsilon ϰ\\;\\;\\;\\;\\varkappaϰ \\varkappa φ\\;\\;\\;\\;\\varphiφ \\varphi ϖ\\;\\;\\;\\;\\varpiϖ \\varpi ϱ\\;\\;\\;\\;\\varrhoϱ \\varrho ς\\varsigmaς \\varsigma ϑ\\;\\;\\;\\;\\varthetaϑ \\vartheta 大写希腊字母（仅展示大小写字母样式有差别者） Δ\\DeltaΔ \\Delta Γ\\;\\;\\;\\;\\GammaΓ \\Gamma Λ\\;\\;\\;\\;\\LambdaΛ \\Lambda Ω\\;\\;\\;\\;\\OmegaΩ \\Omega Φ\\;\\;\\;\\;\\PhiΦ \\Phi Π\\;\\;\\;\\;\\PiΠ \\Pi Ψ\\PsiΨ \\Psi Σ\\;\\;\\;\\;\\SigmaΣ \\Sigma Θ\\;\\;\\;\\;\\ThetaΘ \\Theta Υ\\;\\;\\;\\;\\UpsilonΥ \\Upsilon Ξ\\;\\;\\;\\;\\XiΞ \\Xi 希伯来文字母 ℵ\\alephℵ \\aleph ℶ\\;\\;\\;\\;\\bethℶ \\beth ℸ\\;\\;\\;\\;\\dalethℸ \\daleth ℷ\\;\\;\\;\\;\\gimelℷ \\gimel","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"}]},{"title":"DC Doujin 2023 EP1 先行预告","slug":"dcd2023ep1-trailer","date":"2023-11-05T04:32:52.000Z","updated":"2023-11-05T05:25:44.130Z","comments":true,"path":"2023/11/05/dcd2023ep1-trailer/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/dcd2023ep1-trailer/","excerpt":"","text":"DC Doujin 2023，点击访问。 DC Doujin将在11月带来他的第一部视频作品“一触即发 A Cusp Before It Rings”。这个视频，对日常学校干饭的情景进行真实再现。其中由木稿比你铁饰演的受伤学生受到热烈关注，其原型是初中部的一位学生，我们将其镜头化，力求最真实地表现出其强烈的反差感。 禁止用于商业用途，转载请注明出处 DC Doujin。 Copyright © 2023 DC Doujin, JustPureH2O. All Rights Reserved.","categories":[],"tags":[{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"}]},{"title":"《原神》枫丹语言考究","slug":"fontainish-research","date":"2023-11-05T02:59:02.000Z","updated":"2023-11-05T04:30:50.613Z","comments":true,"path":"2023/11/05/fontainish-research/","link":"","permalink":"https://justpureh2o.github.io/2023/11/05/fontainish-research/","excerpt":"","text":"起因 这天月假，当我正为即将到来的水神池子疯狂做任务屯原石时，在列表里看到了一个悬赏整整30原石的世界任务。本着不放过任何一个给原石的任务的宗旨，我来到了秋分山西侧，白淞镇东北方向的海边房屋处。只见一位男子全身掩埋在海沙之下、动弹不得，面前摆放着一只散发香味的甜甜花酿鸡。我看他精神失常，满嘴都是“新型美容方式”的胡话又哭又闹，呜呜呜呜，好可怜呀。于是我决定帮他一把……找出了幕后黑手，此时他举起一个木牌，只见上面用老米祖传的架空文字写了一些东西，随着剧情推进，我们得知这是“抗议”（protest）。枫丹作为两个月前才开放的新国家，其文学文化充满乐子的xxs神明固然吸引了我。于是我决定用手头上有限的图片资料，整理出一份类似于枫丹语言图鉴的资料来。以便后期深入探究枫丹的风土人情。 初探 这是在上一部分中提到的，写有“抗议”（protest）的木牌，其中各个字母的对应关系已经标注出来了（相信不用标注也看得出来）。不难发现，最后一个字母与倒数第四个字母是相同的，恰巧对应上protest中字母t的位置。某种方面上证明了这一猜测的正确性，但是鉴于这抽象到与原英文字母完全不搭边的枫丹字体~~（很水体）~~实在是太过亮眼，我的内心还是有一点怀疑和否定的。那么我们将这七个字母挨个抽取出来，放到别的语境中去转译，不就可以验证它的准确性了吗？ 其实也无需这么麻烦，读完前面的大佬对提瓦特通用语的解析。我们惊奇地发现，这很水体居然与提瓦特通用语的字母如出一辙： 图片来源于：哔哩哔哩，语颂源，【原神考据】提瓦特通用文 当然也有一些变化，比如哪里可能突然多出来一横、又或者是将圆弧形的笔画变得棱角分明。图中的S和E就是两个典型例子。考虑到可能是手写体带来的美化、钝化等，我接下来去到了枫丹的主城区中，分别在蒸汽鸟报社、卡郎代沙龙前拍下了这几张图片~~（因为他们离锚点非常的近，不需要跑图）~~。 我们根据已经解译出来的提瓦特通用语字母进行对拍，发现蒸汽鸟报社的招牌上写着：LOISEAU DE VAPEUR。明显是法语，但是其中的VAPEUR和英语的VAPOR（蒸气）非常相似，因此对拍基本无误。但是由于我本人不懂法语，解释不了第一个词，只能求助于度娘。度娘也是给我甩了一个解释：鸟。并纠正了一个小错误：LOISEAU应为L’OISEAU。完美契合蒸汽鸟报社的招牌。 同理，卡郎代沙龙的门牌上写着：CARITAT。推测其原型是18世纪的姓氏德·卡里塔，孔多塞侯爵（Nicolas de Caritat）的妻子便是18世纪的一位著名沙龙主人。 最后放出蒸汽鸟报社门前牌子上的翻译： Exploring the manufacture of security machinery 探秘发条机关（守卫机器）的制造流程 Joyous tour through the aquatic workshop 水下工坊快乐一日游游记 Exclusive compilation of the past top duellists 旧时顶级决斗代理人的独家专访合集 Interview with the deboard restaurant artists 采访德波饭店的艺术家们 Iridescene tour and the new trend of music 虹彩巡游之旅，以及新派音乐","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"}]},{"title":"常用算法模板","slug":"common-algo-templates","date":"2023-10-28T06:11:51.000Z","updated":"2023-11-05T02:33:44.995Z","comments":true,"path":"2023/10/28/common-algo-templates/","link":"","permalink":"https://justpureh2o.github.io/2023/10/28/common-algo-templates/","excerpt":"","text":"1. Trie树（字典树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int son[N][70], idx = 0, cnt[N];int map(char c) &#123; // 字符映射到对应数字 if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return c - &#x27;0&#x27;; if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 11; if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 37;&#125;void insert(char s[]) &#123; // 插入一个字符串 int len = strlen(s); int p = 0; // 指针 for (int i = 0; i &lt; len; i++) &#123; // 遍历字符串中每一个字符 int u = map(s[i]); // 映射到数字 if (!son[p][u]) son[p][u] = ++idx; p = son[p][u] // 更新指针，指向下一个节点 &#125; cnt[p]++;&#125;bool query(char s[]) &#123; // 查询一个字符串 int len = strlen(s); int p = 0; for (int i = 0; i &lt; len; i++) &#123; // 遍历+查找 int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return false; &#125; return cnt[p];&#125;int count(char s[]) &#123; // 对指定字符串计数 int len = strlen(s); int p = 0; // 可以用 if (query(s)) 代替下边的遍历查找 for (int i = 0; i &lt; len; i++) &#123; int u = map(s[i]); if (son[p][u]) p = son[p][u]; else return 0; &#125; return cnt[p];&#125; 并查集 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int p[N];int find(int x) &#123; // 查找父节点+路径压缩 if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;void merge(int a, int b) &#123; // 合并两个集合 p[find(a)] = find(b);&#125;bool query(int a, int b) &#123; // 查询两个节点是否在同一个集合中 return find(a) == find(b);&#125; 单调队列 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];deque&lt;Node&gt; q;void peak(int k) &#123; // 查找区间最值，n为数组大小，k为区间大小，即区间中有k个元素 for (int i = 1; i &lt;= N; i++) &#123; // while (!q.empty() &amp;&amp; nodes[i].val &lt;= q.back().val) q.pop_back(); // 查找区间最小值，将大于号改为小于号 while (!q.empty() &amp;&amp; nodes[i].val &gt;= q.back().val) q.pop_back(); // 当新进元素大于队尾元素，删除队尾直到队尾大于新元素，或者直到队列为空 q.push_back(nodes[i]); // 将新进元素压入队尾 if (i - q.front().idx == k) q.pop_front(); // 滑出队头元素所在区间，弹出队头 if (i &gt;= k) cout&lt;&lt;q.front().val&lt;&lt;endl; &#125; &#125; 单调栈 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std; struct Node &#123; int idx; // 下标 int val; // 数值 &#125; nodes[N];stack&lt;Node&gt; stk;int ans[N];void NGE(int k) &#123; // 查找下一个更大的元素，即NGE问题 for (int i = 1; i &lt;= N; i++) &#123; // while (!stk.empty() &amp;&amp; nodes[i].val &lt; stk.back().val) // NSE问题，下一个更小的元素，仅改变大于小于号 while (!stk.empty() &amp;&amp; nodes[i].val &gt; stk.top().val) stk.pop(); // 将栈顶比当前更小的元素弹出 if (stk.empty()) ans[i] = 0; // 查无 else ans[i] = s.top(); // 顶为最大 stk.push(nodes[i]); // 压入当前 &#125; &#125; 单源最短路径 朴素Dijkstra 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稠密图，使用邻接矩阵存图int g[N][N], dist[N];bool st[N];int n; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 dist[1] = 0; // 起点最短路径就是0 for (int i = 1; i &lt;= n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; // 循环所有未确定距离的点，找出最小值 &#125; st[t] = true; // 标记访问 for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); // 间接的路径：从起点经t再连接到j点 &#125; &#125;&#125; 单源最短路径 堆优化Dijkstra 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define N 10010#define INF 0x3f3f3f3fusing namespace std;// 对于稀疏图，使用接表存图int head[N], e[N], w[N], ne[N];int idx = 0;void add(int a, int b, int x) &#123; idx++; e[idx] = b; w[idx] = x; ne[idx] = head[a]; head[a] = idx;&#125;int dist[N];bool st[N];int n;typedef pair&lt;int, int&gt; PIR; // 二元组存储点序号-距离 priority_queue&lt;PIR, vector&lt;PIR&gt;, greater&lt;PIR&gt; &gt; heap; void dijkstra() &#123; memset(dist, INF, sizeof dist); // 初始化距离，开始时均为正无穷，或者为-1 heap.push((PIR) &#123;1, 0&#125;); // 初始点入队，序号为1距离为0 while (!heap.empty()) &#123; // 堆不空时 PIR t = heap.top(); // 优先队列，队头元素总为未确定点中最近的一个 int id = t.first, dis = t.second; if (st[id]) continue; for (int i = head[id]; ~i; i = ne[idx]) &#123; int j = e[i]; // 边终点 if (dist[j] &gt; dis + w[i]) &#123; dist[j] = dis + w[i]; // 更新最短距离 heap.push((PIR) &#123;j, dist[j]&#125;); // 更新的点压入优先队列 &#125; &#125; &#125;&#125; 背包类动态规划 01背包 想象你在一个绝版手办售卖会上。这里的每种手办由于需要保证它的稀有程度，活动主办方提前向卖家商议了一个计策：即保证每种老婆 手办有且只能有一个。这样他们就可以开出天价 （但要保证在物价局划定的价格上限内） （爆long long也没问题！）。那么作为一个资深 御宅 手办收藏家的你，自然不会错过这次难得的机会，你出门时偷偷拿走了麻麻の钱包，发现里面有NNN元现金（假定你不知道麻麻の银行卡密码），那么你可以买到手办的最大价值是多少？ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = c; j &gt;= v[i]; j--) &#123; // 倒着循环，c为容量上限，防止做减法时减为负数内存异常 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 但是最后还是被麻麻发现力（悲 背包类动态规划 完全背包 这种问题类似于西方魔幻小说里的情节：一位勇士无意间闯进了古代君王的藏宝阁，受金钱和权力的蛊惑。看着地上不尽的金币与皇冠，他拿出了一个麻袋。他想要在麻袋规定的最大容量内装尽可能最大价值的物品，超出规定容量，这个袋子很可能破掉，导致财宝落入山谷、沼泽等任何危险的地方。这位勇士十分谨慎，他不希望总重量超过额定重量，那么他能装的最大物品价值是多少？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; // 完全背包，即每个物品数量有无限个，可以自由装配 for (int i = 1; i &lt;= n; i++) &#123; // 对于每个物品，从1到n for (int j = v[i]; j &lt;= c; j++) &#123; // 正着循环，与01背包相反，c为容量上限 // 由于计算当前状态需用到dp[j-v[i]]状态，若升序循环，这个状态总会在前几步被算出 dp[j] = max(dp[j], dp[j - v[i]] + w[i]); // 状态递推（一维压缩） // 若不选该物品，则状态的剩余容量仍然为j，若选择则为j-v[i]，相应的需要加上物品价值 // dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) // 若不选择当前物品，最大价值为dp[i-1][j]，即前一个/i-1个物品，容量上限为j (j&lt;=c)时的最大价值 // 若选择当前物品，最大价值为dp[i][j-v[i]]+w[i]，因为每种物品可以放入无限个，放入第i个物品后仍然可以继续放入相同物品直到超出容量上限j &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 然而我们的勇士痴迷于装入财宝，忽视了高悬在他头顶的致命机关，随着绳子断裂，我们的勇士就此葬身于这个隐蔽的藏宝阁中，带不走任何一枚金币。因此我们的最大价值应该是000 因此我们应该拒绝这种来历不明的诱惑，青少年反诈，从我做起！ 背包类动态规划 多重背包 《竞赛班传奇》 第一部，第一幕 人物：“和蔼可亲滴”福建籍物理竞赛教练 茂华；“偷奸耍滑的”山东老家OIer 国祯；“热心尽职喜欢让同学们多多预习物理知识的”物理课代表曹牧 茂华上场，开玩笑的语气说 茂华： 电荷量滴单位是~库 仑，符号C（写下一个大C），艹！ 全班哄笑，国祯猥琐的笑，茂华眉头一蹙，表情严肃，严肃语气 茂华： 国祯！还在那里笑，曹牧，检查一下国祯有没有记笔记！ 曹牧起身走向国祯，其他人目光盯着曹牧，国祯将物理书翻开，指着笔记处，曹牧低头查看，然后抬头 曹牧： 他写了，但是…… 严肃的，急速的，愤怒之极的，气震寰宇的，振聋发聩的，势如破竹的，响彻云霄的，如雷贯耳的，不共戴天的，耳机党爆炸的，外放党社死的 茂华： 站起来！没写笔记！ 国祯吓一跳，乖乖站起，曹牧缓缓退回，众人起哄国祯，茂华声音略小 茂华： 在这里偷奸耍滑是会被刷出去滴。到时候你竞赛搞不好，高考也考滴西撇，看你到时候怎么办！ 国祯： （解释的语气）我没有偷奸耍滑！ 茂华语气有所缓和 茂华： 那你把这道题解出来，你就可以坐下了 题面： 给定NNN个物品，背包最大容量CCC。对于第iii种物品，给定每个iii种物品的大小ViV_iVi​，价值WiW_iWi​，以及个数SiS_iSi​，试求出背包可以装下物品的最大价值AAA。 国祯小嘴一撇，这还不简单？他立马拿起了一支0.5mm的黑色签字笔在草稿纸上飞速演算。得益于他积累了一坤年的OI知识，2分钟后，在众人惊异的目光中，国祯自信满满地拿出了写有正确答案的草稿纸。他将右手伸得十分用力，好像要把草稿纸怼到茂华脸上一样，他的嘴角浮现出一抹byd笑容。 只见茂华呆立原地，嘴巴微张，如同按下了暂停键。3秒钟的寂静过后，下课铃如同国祯的战鼓一般敲响，宣告这次对决以国祯的大比分取胜而落下帷幕。茂华直立的双腿尴尬的向门口转去，颤抖的双唇之间轻飘飘冒出了两个字：“下课”。随后咬紧嘴唇，一步一步踱向门外。 国祯如获新生。在众人崇拜和惊诧的目光中，他迷失了自我，他快步走向一体机，熟练地打开希沃白板，好像已经练习过成千上万遍似的，将一句话加粗写在了白板上： 通常情况下，多重背包的思路是将一堆A物品拆分成n个A物品，每个物品只能使用一次，便可转化为01背包问题 他不管大家是否了解01背包的含义，他此刻只想在众人面前分享打败茂华的喜悦感，以及打败茂华所需要的知识，这又何尝不是一种爱屋及乌的思想呢？ 第二天，当上午的物理课准时来到，茂华却没有准时跨进教室的门。通常情况下，他每次课前都会提前2分钟来到教室里对同学进行题目过关。 1分钟后，茂华挟着几本不合身份的普及组信息竞赛导论及考纲，昂首阔步地走进了一班教室。他大声说着：“通常情况下。这是国祯同学昨天下课后给你们上的课里的一句原话！” 原来茂华前一天下课后并没有跑回办公室又哭又闹大发牢骚，而是现场网购了信息竞赛教程，准备在第二天的物理课上给国祯单独上节课：学生是永远无法击败老师滴！ 他打开了浏览器，输入一行神秘的IP地址，按下回车，一个界面清爽的网站跳了出来。顶端用紫色的大写字母写着MHOI四个大字。 “牛逼吧，这是我连夜赶工自创的网站，”他笑着打开了题目列表中的第一道题，标题： 国祯接招 。国祯轻蔑地瞥了一眼，题干还是昨天那样，一模一样，“看好了国祯，”他指向下排的一行小字，“数据范围：n≤10000n \\leq 10000n≤10000！看你那吃了食的小脑袋还能不能算出这道题目。” 显然，茂华是有备而来，国祯倒吸一口冷气。手工计算绝对是行不通了，但是对于竞赛班的高思娃国祯，绝对是有两把刷子的，毕竟正如茂华所说：“偷奸耍滑耍小聪明早就被刷下去了”。 面对如此巨大的物品总数，一些牛逼娃想到了用二进制拆分表示物品个数的方法。尽管换汤不换药，本质还是一个01背包问题，但是经过祖先们灵魂的注入，茂华是肯定不敢把你踢出竞赛班滴。 ForExampleFor ExampleForExample 假设原有10个价值为2的物品，将10分为1+2+4+3，等同于有4个不同的01物品，价值分别为12=2，22=4，42=8，32=6，即2，4，8，6 国祯很快在VSCode上写出了一段教科书式的、注释易懂的模板代码，这次就算是物竞数竞化竞生竞的人也可以轻易看懂了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int idx = 0;// 记录数组下标 int main() &#123; int n, c; cin&gt;&gt;n&gt;&gt;c; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; // v w n // 即体积，价值，个数 cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; int k = 1; // 记录2的幂，初始值为2的0次幂，即1 //if (s == 0) s = INF; // 当题目中说数量0时默认为无限次时可以使用，这其实已经属于混合背包（多重+完全）的范畴 while (k &lt;= s) &#123; // 个数可以继续被分解 s -= k; // 更新个数 idx++; // 新的下标 v[idx] = a * k; // 分解后该物品的大小 w[idx] = b * k; // 分解后该物品的价值 k *= 2; // k更新为2的下一个幂 &#125; if (s) &#123; // 若无法被完全分解，剩下一部分 idx++; // 记录新的下标 v[idx] = a * s; // 大小 w[idx] = b * s; // 价值 &#125; &#125; // 01背包模板 for (int i = 1; i &lt;= n; i++) &#123; for (int j = c; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125; &#125; cout&lt;&lt;dp[c]; return 0; &#125; 国祯长舒一口气，这次他又获得了胜利。评测点加载了几秒。国祯定住了，#10号点出现一个大大的WrongAnswerWrong AnswerWrongAnswer。国祯感觉堕入了万丈深渊，只见茂华狂笑了起来，带动全班其他同学的笑容，一班霎时被笑声吞没。国祯盯着评测信息，783ms783ms783ms的运行时间让他更为疑惑，莫非茂华手动写了一个错误答案？ 国祯尴尬的转向各位同学，其他同学瞬间停止了笑容。先前还在交头接耳的同学们如同机器一般齐刷刷的转向国祯，给人一种惊悚透骨的感觉。他们异口同声张开了嘴，在茂华扭曲的笑容下，说出了让国祯后悔了一辈子的话来： “三年OI一场空，不开long long见祖宗！” OVER\\mathcal {OVER} OVER 背包类动态规划 混合背包 混合背包，顾名思义。它混合了多种背包，实际应用中这一类问题比较有现实意义。主要思路是，将分属于各个类型背包的物品用几个条件判断语句写出来，然后分别套用各类背包的解决方案进行求解。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N], v[N], dp[N];// 价值 占地 容量上限为N时最大价值 int main() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (A) &#123; // 01背包物品，写01背包模板 &#125; if (B) &#123; // 完全背包物品，写完全背包模板 &#125; if (C) &#123; // 其他…… &#125; &#125; return 0; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"}]},{"title":"国祯文集","slug":"gz-articles","date":"2023-10-26T09:29:45.000Z","updated":"2023-11-04T08:27:07.535Z","comments":true,"path":"2023/10/26/gz-articles/","link":"","permalink":"https://justpureh2o.github.io/2023/10/26/gz-articles/","excerpt":"","text":"曾茂华到底有多六 ——By 国祯 曾茂华是中国当代著名的科学家和教育家，他以“慈父”、“良师”、“学者”等称号闻名于世。 1：曾茂华的蠢行为 曾茂华的蠢行为: 他在大学期间参加了一个乐队，并担任主唱。然而，不幸的是，由于自己的疏忽，他犯下了一件愚蠢的事情——用刀砍掉了对方的手指头。这件事让他成了学校里的头号人物之一。从那以后，他再也不敢做任何愚蠢的事情了。这是因为他害怕自己会被开除出乐队或者成为众矢之的的对象。如果他继续做出这些错误的举动，那么他会失去自己的乐队成员资格，甚至还会遭到开除。所以，为了避免发生这样的悲剧，他必须要记住：永远不要犯错！ 2：为什么他会做出这种愚蠢的事情? 曾茂华的蠢行为发生在他身上，是因为他自己没有意识到他自己的愚蠢。他不知道怎么做才能让事情变得更好，他只想走捷径，而不是去努力做好事情。这种心态会导致他做出错误的决定，因为他会忽略一些重要的信息，或者选择性地记住某些信息。当我们看到一个人犯了下述三种类型的罪时，我们通常就能预测到这个人会再犯同样的问题：1. 根本不会思考问题2. 一味追求便利3. 盲目模仿别人 3: 该如何面对这个问题? 要想解决问题,首先要认识到自己的行为是愚蠢的。只有当你明白自己做了什么蠢事时,才能够改变你的行为来避免这种错误。其次，不要让别人知道你所犯下的错误。这并不是因为你不想坦白自己所犯错误,而是因为这样会给别人带来困扰。最后,如果你真的想要解决这个问题,可以尝试通过一些有趣的方式来实现它。例如,你可以去找一位专业人士帮助你分析一下这件事情,或者试着去找到一个愿意与你分享观点和建议的人。总之,如果你认为自己的行为很蠢,那么就要大胆地承认出来。只有敢于直面自己的无知,才能真正地改善自己的生活。 曾茂华先生不仅对科学领域做出了巨大贡献，而且为国家培养出一批优秀的人才。这些人中不乏有牛顿这样伟大的人物，也有王选这样杰出的人物。","categories":[],"tags":[{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"CSP-J 2023 游记","slug":"journey-to-the-cspj2023","date":"2023-10-24T08:21:36.000Z","updated":"2024-01-07T03:33:37.020Z","comments":true,"path":"2023/10/24/journey-to-the-cspj2023/","link":"","permalink":"https://justpureh2o.github.io/2023/10/24/journey-to-the-cspj2023/","excerpt":"","text":"又名：《第一次考就被小学生薄纱的一集》 本次考场：绵阳东辰国际学校 第一节 赛前准备 插一句：CSP-J 2023没有设置赛前试机环节（包括CSP-S，成都绵阳都这样），个人推测可能是由于开放自选Windows和Linux系统带来的结果。如果你听见诸如：不要操作电脑，违者将作作弊处理 的话时，请将你按捺不住的双手安稳的放在双腿上，避免出现意料之外的事来。 然而赛前试机仍然是必要的一环（但是如果考场纪律有要求那就算了），因为这样可以让选手对机器有一个初步的了解。因为我本人习惯使用Win+E打开文件系统管理器，用Win+V记录剪切板数据，可是这些功能在考场电脑上都无法使用，进行赛前试机不仅可以避免因赛时临时发现无法使用某些功能而带来的苦恼心态爆炸点+1，而且还可以将IDE环境调整到个人喜欢的状态（例如缺省源代码，相当于每次新建代码不用重新打头文件）。选手可以不占用正式比赛时间完成一些个性化操作，方便赛时操作，其重要性不言而喻。 当然，开赛前乱猜试题PDF密码是极其无意义且几乎不可能成功的一件事，更不要使用暴力破解密码工具破解文件（相信守规矩的你也不会将这种工具带进考场里来），这么做不仅会被当做作弊者处理，而且造成的数据丢失也只能由你自己负责。 第二节 开赛之初 考场下发的PDF文件带有密码保护，输入时请务必瞪大眼睛区分大小写字母O、o与数字0；小写字母l、大写字母I与数字1，并且将其中的特殊字符认真核对一遍。本次考试，我有幸将密码中的数字0写成了小写字母o，于是浪费了宝贵的2分钟时间改正密码（真实情况是监考老师在黑板上书写密码时字迹不规范导致的混淆）。因此需要认真看好你的密码。 就我认为：在一开始就仔细写好文件重定向输入输出是极其重要的，因为随着考试时间的推进，你的思考重点将从细节性问题变为如何拿到更多的分数上骗分。你就会忽略重新写上两行重定向IO的代码，因而可能Au-&gt;Cu，光荣AFO。为了引起你的注意，使用极长的注释双斜线是可行的，我本人习惯打上断点。例如： 12//////////////////////////////////////////////// freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//////////////////////////////////////////////// freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 将比 12//freopen(&quot;uqe.in&quot;, &quot;r&quot;, stdin);//freopen(&quot;uqe.out&quot;, &quot;w&quot;, stdout); 显眼得多——尤其是当你喜欢为每行代码写上包含心血的易懂注释时。事后你可以通过长按Ctrl+逗号（Dev-C++）的方式快速且安全的删除这些斜线。 不仅如此，看好输入输出文件名也是一个非常重要的细节，建议直接复制粘贴。对于标准样例，直接选中PDF文字再复制一般都不是一个明智的做法，手动输入也是可行的，但是对拍有时会比较繁琐（例如普及组T3的样例）。这边传授一个方便的做法：选中代码左侧序号，在WPS中直接右键菜单点击消除文字即可（本次考试我就是使用的这个方便技巧快捷复制样例数据）。最好找张纸记下来，后面会讲到原因。 顺利解锁了PDF文件，你要做的第一件事就是将四道题全部读熟。对整场比赛的题目有大致的规划，有可能你先前做题时做过与T4极其相似的题目，那么放弃显然是一个很不划算的决策。将题目读熟，大概判断一下算法实现，评估自己哪些题能做好，哪些题要放一放/完全放弃。知己知彼方能百战百胜。 赛初的状态基本上决定了你整场比赛的表现，因此在赛初就做好一切细节方面的完全准备，对你的信心增长是非常重要的！ 第三节 赛中时期 那么你现在拿到了第一题（信心题）。一般来说，CSP的复赛，算法很少裸露地出现在题目之中，前两题近似看作数学题。保证你的数学思维在线，因为第一题的思路可能千奇百怪，如果你一段时间没有思路（对于第一题大概是5~15分钟），可以考虑先做其他题目。刷新一下思维定势，有可能T1的灵感就乍现于其他题目之中。 在符合时间规划的前提下尽可能多去造hack数据，写出一段代码（尤其是T3放大模拟时）后，千万保证没有任何逻辑问题。当然，不是所有人都能只看代码就能检查的出其中的逻辑漏洞。因此你需要多造hack数据。hack数据多数情况下包括这几个要素：方程的特殊解、极端值/边界值、大数据（int越界）。在规划好的时间内想尽办法为你的代码多挑几根刺出来，你的代码才能更加趋近于满分解。 千万不要看你旁边的人！！！ 除非S组巨佬闯进了J组蒟蒻区，否则千万不要在比赛中途去看任何人的任何行为。一方面，你的行为可能被视作交谈作弊喜提CCF全国通报、禁赛3年大礼包；另一方面，如果你抱着嘲笑别人的心态去观察别人，那么你的脸很可能就会被你自己打烂。我在考试时因为瞧不起隔壁的一位小学生，当他开始疯狂敲代码时，我自己的心态就爆炸了——把所有人，不分男女、年龄高低，都当作你的敌人，轻视则死。同时这也给你带来一部分紧张感，会使你的发挥更佳。 给自己适当的放松与勉励，要相信，上天不是无故给你这个周末不用冒着风雨大太阳上补习班的珍贵机会（对于高中生，则是周六不用坐在教室里上正课的机会）。当你完全确认你的代码已经完美无瑕时，告诉自己：*同学们都还在悲催的上着课，我却在外边快乐的敲着代码。*如此一来可以起到调整心态的作用。 别激动到顺手关了PDF文件。如果你还记得或者是在草稿纸上写了密码，那无所谓；但是如果你没写，你的处境就非常尴尬，这时你可以举手找老师再要，但这绝对对你的心态是一个不小的打击。 第四节 赛末时期 经历三个半小时的不懈奋斗，比赛终于迎来最后的半小时。无论你的完成情况如何，一定要用这最后的时间好好检查一下你的代码。瞄一眼你是否有与下面类似的代码： 12freopen(&quot;uqe2.in&quot;, &quot;r&quot;, stdin); // 危freopen(&quot;uqe2.out&quot;, &quot;w&quot;, stdout); // 爆零警告 这段代码的主人是个懒人无疑了，如果你把CCF提供的附加样例复制了出来。切记最后把文件名里的序号删除，否则你就可以AFO了。 或者以下的代码： 1234#include &lt;Windows.h&gt;//其他的代码if (system(&quot;fc uqe.out uqe.ans&quot;)) cout&lt;&lt;&quot;WA&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;AC&quot;&lt;&lt;endl; 这位同学也是个Windows爱好者受害者无疑了，CCF明文规定了测试用系统为NOI Linux。因此不存在Windows.h这个头文件，如果你忘记删除了，那一定是个大大滴CE。正式比赛时，用bits/stdc++.h万能头即可(Windows和Linux通用）。我有一个考S组的朋友，因为忘记删除这个对拍头文件而喜提一个0分，直接亏大发。 不要忘记将你的重定向取消注释。你连读入输出都没有了，属实是可以AFO了。最后三分钟，请将你的蹄子挪开键盘鼠标。否则可能会越改越慌，不妨好好回想一下这周老师留了什么作业，你缺了哪些课需要去补，总之不要再动你的鼠标键盘了！如果实在是不放心编译问题，按一下F11，通过即可。保证你的工作目录下只留.cpp文件，所以将你复制的样例文件和编译的exe文件全部删除。 第五节 考试结束 请你千万保持冷静，不要习惯性地把机器关机了。CCF明文规定：由关机造成的数据损失，责任由考生自负。只需要把你的IDE关闭就好。 回家后，把周一要交的作业补好。别再谈考试的事情了，让你自己有个好心情。毕竟不管你的表现怎么样，它都过去了不是吗？","categories":[],"tags":[{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}],"categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://justpureh2o.github.io/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.github.io/tags/%E6%95%B4%E6%B4%BB/"},{"name":"数学","slug":"数学","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"教程","slug":"教程","permalink":"https://justpureh2o.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"破解","slug":"破解","permalink":"https://justpureh2o.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"DC Doujin","slug":"DC-Doujin","permalink":"https://justpureh2o.github.io/tags/DC-Doujin/"},{"name":"DCD同人","slug":"DCD同人","permalink":"https://justpureh2o.github.io/tags/DCD%E5%90%8C%E4%BA%BA/"},{"name":"新闻","slug":"新闻","permalink":"https://justpureh2o.github.io/tags/%E6%96%B0%E9%97%BB/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"latex","slug":"latex","permalink":"https://justpureh2o.github.io/tags/latex/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.github.io/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.github.io/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.github.io/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}